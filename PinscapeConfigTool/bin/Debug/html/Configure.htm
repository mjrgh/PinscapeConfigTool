<!DOCTYPE html>
<html lang="fr">
<head>
   <meta http-equiv="X-UA-Compatible" content="IE=edge" charset="utf-8"/>
   <link rel="stylesheet" href="main.css"/>
   <link rel="stylesheet" href="jquery-ui/jquery-ui-1.11.4.css"/>
   <title>Paramètres du contrôleur Pinscape</title>
</head>
<body>

<script type="text/javascript" src="jquery-1.12.1.js"></script>
<script type="text/javascript" src="jquery-ui/jquery-ui-1.11.4.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="pins.js"></script>
<script type="text/javascript" src="keycaps.js"></script>


<script>

// Configuration sources
var ConfigSource = {
    Board: 1,           // loading from the board
    File: 2,            // configuration saved in a local file
    Factory: 3          // pre-set factory configuration
};

</script>


<h1>
   <img src="h1options.png" style="float: right;">
   Parametres
   <img src="h1options.png" style="vertical-align: middle; visibility: hidden;">
</h1>

<div>

   <p>
      <b>Paramètres de configuration pour l'ID CPU KL25Z
      <span id="CPUID">Inconnu</span></b>
   </p>
   <div id="heapInfo" style="display: none;">
      Mémoire utilisée: <span id="usedHeapBytes">Inconnu</span> de 16K bytes (<span id="freeHeapBytes">Unknown</span> bytes libres)
      <a href="#" class="shower">Explication</a>
      <div class="hider">
         Cela montre l'utilisation totale de la RAM sur le KL25Z pour votre configuration actuelle.
         L'utilisation de la mémoire est principalement statique, le logiciel alloue de la mémoire lors de l'initialisation
         après le démarrage de l'appareil. Vous ne devriez voir aucune fluctuation lors d'une utilisation normale.
         L'utilisation de la mémoire change uniquement lorsque vous ajoutez ou supprimez des fonctionnalités via les paramètres ci-dessous
         et ne se met à jour qu'après avoir enregistré les nouveaux paramètres. Puisque la mémoire est attribuée
         au démarrage, le logiciel n'a pas besoin de beaucoup de mémoire libre pour fonctionner, alors ne
         vous inquiétez pas si l'espace libre semble restreint. Nous montrons le chiffre de mémoire principalement pour
         les diagnostics et pour vous donner une idée de la marge qu'il vous reste pour activer des fonctionnalités supplémentaires.
      </div>
   </div>


   <!--  System type  ----------------------------------------------------->
   <hr>
   <div class="section" data-name="System Type">
      <div>
         <img src="hardwareSection.png" class="sectionIcon">
         <b>Type de système.</b>  Utilisez-vous cette KL25Z seule,
         ou avec un ensemble de cartes d'extension?  <a href="#" class="shower">Aide</a>

         <div class="hider">
            Si vous utilisez les <a href="http://mjrnet.org/pinscape/expansion-board.html" target="_blank">
            Cartes d'extension Pinscape</a> ou le <a href="https://www.vpforums.org/index.php?showtopic=42631" target="_blank">
            Tout-en-un Oak Micros Pinscape</a>, sélectionnez l'option correspondante ci-dessous, et l'outil
	    de configuration remplira automatiquement les affectations des broches tout au long de la configuration.
            Si vous utilisez la KL25Z seule ou si vous utilisez vos propres modules complémentaires personnalisés
            (par exemple, vos propres circuits d'amplification de sortie), sélectionnez «autonome» pour
            définir les affectations de broches individuelles en fonction de votre câblage.
         </div>

         <table class="radio">
            <tr>
               <td>
                  <label>
                     <img src="kl25z.png"><br>
                     <input type="radio" name="hardwareType" value="0">
                     Autonome KL25Z<br>
                     (ou vos propres tableaux personnalisés)
                  </label>
               </td>
               <td>
                  <label>
                     <img src="expansionStack.png"><br>
                     <input type="radio" name="hardwareType" value="1">
                     Cartes d'extension Pinscape<br>
                     &nbsp;
                  </label>
               </td>
               <td>
                  <label>
                     <img src="pinscapeAIO.png"><br>
                     <input type="radio" name="hardwareType" value="2">
                     Tout-en-un Pinscape<br>
                     &nbsp;
                  </label>
               </td>
                 <td>
                     <label>
                         <img src="pinscapeLite.png"><br>
                         <input type="radio" name="hardwareType" value="3">
                         Pinscape Lite<br>
                         &nbsp;
                     </label>
                 </td>
            </tr>
         </table>
         <input type="hidden" id="expBoardVersion">

         <!-- expansion board options - initially hidden -->
         <div id="expansionBoardOptions" style="height: 0px; overflow: hidden; margin: 1em 2em;">
            <b>Détails de la carte d'extension:</b>
            <input id="numMainBoards" type="hidden">
            <table class="inputs">
               <!--
               <tr>
                  <td>Number of main interface boards:</td>
                  <td><input type="text" id="numMainBoards" size="4" value="1">
               </tr>
               -->
               <tr>
                  <td>Nombre de cartes d'alimentation MOSFET:</td>
                  <td><input type="text" id="numPowerBoards" size="4" value="0">
               </tr>
               <tr>
                  <td>Nombre de cartes carillon:</td>
                  <td><input type="text" id="numChimeBoards" size="4" value="0">
               </tr>

            </table>

            <div>
               <label><input type="checkbox" id="ckExpBoardShowPins"> Afficher les affectations des broches KL25Z <b>(Mode Expert)</b></label>
               <div style="margin: 1ex 0px 0px 2em;">
                  Les affectations des broches KL25Z sont masquées par défaut car vous avez sélectionné une
                  configuration de la carte d'extension. Toutes les attributions de broches GPIO sont définies
		  automatiquement dans cette configuration correspond à vos tableaux, il n'est donc normalement
		  pas nécessaire de les afficher. Vous pouvez cocher la case ci-dessus si vous souhaitez voir
		  les attributions de broches de toute façon, mais sachez que toute modification que vous 
		  apportez aux paramètres des broches causent probablement des dysfonctionnements, car les cartes
		  sont câblées avec des broches GPIO spécifiques et que les paramètres du logiciel doivent 
		  correspondre pour fonctionner correctement.
               </div>
            </div>
         </div>
      </div>

      <script>

$("input:radio[name=hardwareType]").change(function(ev)
{
    // check which hardware configuration is now selected
    var d = $("#expansionBoardOptions");
    var v = $("input:radio[name=hardwareType]:checked").val();
    var fromUI = !!ev.originalEvent;

     // set up defaults for the new configuration
    switch (+v)
    {
    case 1:
        // Pinscape Expansion Boards, first release

        // use the expansion board settings view
        slideToggle(d, true, 250, fromUI);

        // use the expansion board output port aliases
        outPortAlias = expOutPortAlias;
        gpioPortAlias = expGpioPortAlias;

        // if the selection was made from the UI, apply the factory defaults
        if (fromUI)
            configToUI(expansionBoardFactoryConfig, expansionBoardFactoryXConfig, ConfigSource.Factory);

        // hide KL25Z pin assignments by default
        $("#ckExpBoardShowPins").prop("checked", false);
        break;

    case 2:
        // Pinscape AIO

        // use the expansion board settings view
        slideToggle(d, true, 250, fromUI);

        // use the Pinscape AIO output port aliases
        outPortAlias = aioOutPortAlias;
        gpioPortAlias = aioGpioPortAlias;

        if (fromUI)
            configToUI(pinscapeAIOFactoryConfig, pinscapeAIOFactoryXConfig, ConfigSource.Factory);

        // hide KL25Z pin assignments by default
        $("#ckExpBoardShowPins").prop("checked", false);
        break;

        case 3:
            // Pinscape Lite

            // use the expansion board settings view
            // future function to later enable this
            slideToggle(d, false, 250, fromUI);

            // use the Pinscape Lite output port aliases
            outPortAlias = liteOutPortAlias;
            gpioPortAlias = liteGpioPortAlias;

            if (fromUI)
                configToUI(pinscapeLiteFactoryConfig, pinscapeLiteFactoryXConfig, ConfigSource.Factory);

            // hide KL25Z pin assignments by default
            $("#ckExpBoardShowPins").prop("checked", false);
            break;

    default:
        // plain KL25Z or unknown

        // use the standalone settings view
        slideToggle(d, false, 250, fromUI);

        // use hardware pin names for the output ports (no board aliases)
        outPortAlias = { };
        gpioPortAlias = { };

        // set factory defaults if the change came from the UI
        if (fromUI)
            configToUI(standaloneFactoryConfig, standaloneFactoryXConfig, ConfigSource.Factory);
        break;
    }

    // show/hide items globally according to the type
    $(".expBoardOnly").css("display", (v == 1 || v == 2 || v == 3) ? "" : "none");
    $(".expBoardExclude").css("display", (v == 1 || v == 2 || v == 3) ? "none" : "");

    // update pin displays - this shows the pin selectors in standalone
    // mode, and hides them in expansion board mode, except when the "show
    // pins anyway" box is checked
    updatePinVisibility();

    // If the change came from a UI event, reset plunger pin assignments
    // for the new factory defaults.  Pass -1 for the previous type, since
    // the previous type is irrelevant: it's the pin wiring that's changing,
    // not the plunger type, so we need to reassign the pins no matter what
    // type is selected.
    if (fromUI)
        setPlungerPinFactoryDefaults(-1);

    // update pin warnings
    updatePinWarnings();
    
});

// "Show pin assignments" box - expansion board option.  By default, when
// this box is not checked and the expansion board configuration is active.
// All .expBoardPin elements are hidden - these are elements containing
// selectors for KL25Z pins wired to specific functions on the expansion
// boards.  .expBoardAlt elements are the converse - these show alternative
// text in expansion board mode, which can be used to fill in gaps left
// when the pin selections are missing.
$("#ckExpBoardShowPins").change(function() { updatePinVisibility(); });

function updatePinVisibility()
{
    // get the hardware mode
    switch (+$("input:radio[name=hardwareType]:checked").val())
    {
    case 0:
    default:
        // standalone mode/unknown - show pin selectors, hide special
        // expansion board alternate text
        $(".expBoardPin").show();
        $(".expBoardAlt").hide();
        $(".expBoardText").hide();
        $(".aioBoardText").hide();
        break;

    case 1:
        // expansion board mode - show the expansion board alternate text,
        // and hide the regular pin selectors, *unless* the "show pins anyway"
        // box is checked
        $(".expBoardPin").toggle(!!$("#ckExpBoardShowPins").prop("checked"));
        $(".expBoardAlt").show();
        $(".expBoardText").show();
        $(".aioBoardText").hide();
        break;

    case 2:
    case 3:
        // Pinscape AIO/Lite board mode - show the Pinscape AIO alternate text,
        // and hide the regular pin selectors, *unless* the "show pins anyway"
        // box is checked
        $(".expBoardPin").toggle(!!$("#ckExpBoardShowPins").prop("checked"));
        $(".expBoardAlt").show();
        $(".expBoardText").hide();
        $(".aioBoardText").show();
        break;
    }
}

$("#numMainBoards,#numPowerBoards,#numChimeBoards").change(function()
{
    // make sure we have a valid number
    var v = $(this).val().trim();
    if (!/^\d+$/.test(v))
        $(this).val($(this).data("oldVal"));

    // adjust the peripheral chip configuration
    expBoardAdjustChips();
});

// adjust the number of peripheral chips to match the expansion board setup
function expBoardAdjustChips()
{
    // get the hardware mode
    switch (+$("input:radio[name=hardwareType]:checked").val())
    {
    case 0:   // Standalone KL25Z
    default:  // or unknown/other
        break;

    case 1:   // Pinscape Expansion Boards
        // adjust the TLC5940 count: 2 per main board + 2 per power board
        $("#tlc_nchips").val(2*$("#numMainBoards").val() + 2*$("#numPowerBoards").val()).change();

        // adjust the 74HC595 count: 1 per chime board
        $("#hc595_nchips").val($("#numChimeBoards").val()).change();
        break;

    case 2:   // Pinscape All-In-One Board
        // adjust the TLC5940 count: 4 per main board + 2 per power board
        $("#tlc_nchips").val(4*$("#numMainBoards").val() + 2*$("#numPowerBoards").val()).change();

        // adjust the 74HC595 count: 1 per main board + 1 per chime board
        $("#hc595_nchips").val(1*$("#numMainBoards").val() + 1*$("#numChimeBoards").val()).change();
        break;

    case 3:   // Pinscape Lite Board
       // adjust the TLC5940 count: 1 per main board + 2 per power board
        $("#tlc_nchips").val(1*$("#numMainBoards").val() + 2*$("#numPowerBoards").val()).change();

        // adjust the 74HC595 count: 1 per chime board
        $("#hc595_nchips").val($("#numChimeBoards").val()).change();
        break;
    }
}

      </script>

   <!--  USB ID  ------------------------------------------------------------->
   <hr>
   <div class="section" data-name="USB ID">
      <div>
         <img src="usbident.png" class="sectionIcon">
         <b>Identification USB.</b>  C'est ainsi que le KL25Z est identifiée par
         Windows via le port USB.
      </div>

      <div>
         <select id="popUsbID" style="margin-right: 2em;">
            <option value="FAFA00F0">LedWiz Unit 1</option>
            <option value="FAFA00F1">LedWiz Unit 2</option>
            <option value="FAFA00F2">LedWiz Unit 3</option>
            <option value="FAFA00F3">LedWiz Unit 4</option>
            <option value="FAFA00F4">LedWiz Unit 5</option>
            <option value="FAFA00F5">LedWiz Unit 6</option>
            <option value="FAFA00F6">LedWiz Unit 7</option>
            <option value="FAFA00F7">LedWiz Unit 8</option>
            <option value="FAFA00F8">LedWiz Unit 9</option>
            <option value="FAFA00F9">LedWiz Unit 10</option>
            <option value="FAFA00FA">LedWiz Unit 11</option>
            <option value="FAFA00FB">LedWiz Unit 12</option>
            <option value="FAFA00FC">LedWiz Unit 13</option>
            <option value="FAFA00FD">LedWiz Unit 14</option>
            <option value="FAFA00FE">LedWiz Unit 15</option>
            <option value="FAFA00FF">LedWiz Unit 16</option>
            <option value="1209EAEA">Pinscape ID</option>
            <option value="00000000">Custom</option>
         </select>

         <span id="usbCustomFields">
            Fournisseur ID: <input type="text" size=4 id="txtUsbVendor">
            Produit ID: <input type="text" size=4 id="txtUsbProduct">
         </span>
         <span id="usbInfoFields">
         </span>

      </div>

      <div>
         <ul>
            <li>Si vous avez <b>réellement</b> une carte LedWiz sur votre système,
            choisissez <b>LedWiz Unit 8</b> pour la premiere carte LedWiz, 9 our la seconde, etc.
           

            <li>si vous <b>n'avez pas</b> de vraies cartes LedWiz, choisissez
            <b> Unit LedWiz 1 </b> pour la première carte, 2 pour la seconde, etc.
         </ul>

         <a href="#" class="shower">je veux plus de détails!</a>
         <div class="hider">
            <ul>
               <li><b>Pour la compatibilité LedWiz </b>, choisissez un numéro d'unité LedWiz.
               La compatibilité LedWiz permet aux anciens programmes, comme Future Pinball,
               de contrôler les sorties via cette unité Pinscape.

               <li>Les numéros de cartes LedWiz <b> doivent être uniques </b>.
               Assurez-vous de choisir un identifiant qui n'est pas utilisé par votre vrai LedWiz,
	       ou par un autre Contrôleur Pinscape.
               Les programmes sur le PC utilisent le numéro de carte pour distinguer les périphériques,
	       de sorte que chaque appareil a besoin d'un numéro différent.

               <li>Si les ID LedWiz provoquent des conflits sur votre système avec d'autres périphériques USB,
               vous pouvez essayer l'ID Pinscape. Cet identifiant est enregistré uniquement pour Pinscape,
	       il ne devrait donc entrer en conflit avec rien.
               Cependant, <b> l'utilisation de cet identifiant abandonnera la compatibilité LedWiz. </b> Cela
               signifie que des logiciels plus anciens comme Future Pinball ne pourront pas accéder
               aux fonctionnalités du contrôleur de sortie. Les logiciels plus récent basés sur DOF R3
               (comme Visual Pinball et PinballX) <b> seront </b> toujours en mesure de prendre le
               plein avantage des fonctionnalités de sortie. Les fonctionnalités d'entrée ne devraient pas
               être affecté d’une manière ou d’une autre.

               <li>L'option ID personnalisé est réservée aux techniciens qui font quelque chose de compliqué.
               Ne l'utilisez pas à moins d'avoir une bonne raison. Utiliser un ID personnalisé rendra les
	       fonctionnalités de sortie inaccessibles même à partir de DOF. (Les fonctionnalités d'entrée
	       continueront cependant de fonctionner.)
            </ul>
         </div>
      </div>
   </div>

   <script>
$("#popUsbID").change(function() {
    var v = $(this).val() || "";
    var vendor = v.substr(0, 4);
    var product = v.substr(4);
    $("#txtUsbVendor").val(vendor);
    $("#txtUsbProduct").val(product);

    // fill in the info fields
    $("#usbInfoFields").text("(USB Vendor ID " + vendor + ", Product " + product + ")");

    // show the custom ID fields if and only if the custom item is selected
    var custom = ($("#popUsbID option:selected").text() == "Custom");
    $("#usbCustomFields").css("display", custom ? "inline" : "none");
    $("#usbInfoFields").css("display", custom ? "none" : "inline");
});
$("#txtUsbVendor, #txtUsbProduct").change(function() {
    // normalize the updated value by parsing it as a hex number and then
    // formatting back into our standard format
    $(this).val(hex4(parseInt($(this).val(), 16)));

    // set the popup value
    var pop = $("#popUsbID");
    var newval = $("#txtUsbVendor").val() + $("#txtUsbProduct").val();
    ensureUsbId(newval);
    pop.val(newval).change();
});

// ensure that a USB ID is in the popup list, setting the "custom" entry if required
function ensureUsbId(val)
{
    // search the list
    var found = false;
    var pop = $("#popUsbID");
    pop.children().each(function() {
        if ($(this).val() == val) {
            found = true;
            return false;
        }
    });

    // if we didn't find it, set the custom element to the new value
    if (!found)
        pop.children().last().val(val);
}

   </script>

   <!-- Pinscape ID  ------------------------------------------------------->
   <hr>
   <div class="section" data-name="Pinscape ID">
      <img src="pinscapeID.png" class="sectionIcon">
      <b>Identifiant Pinscape.</b>  Ceci est un identifiant <b> distinct </b> 
	  du numero de carte LedWiz. DOF R3 et le <a class="dofconfigtool">
         DOF Config Tool </a> utilisé par cet identifiant pour identifier la carte.
      <b> Définissez ce paramètre sur 1 pour votre premier appareil, </b> 2 pour le second, etc.
      <p>
         Vous <b> n'avez </b> pas à copier ici le numéro de la carte LedWiz!
         Ceci n'a aucun rapport avec le numéro LedWiz. Ce paramètre
         <b> doit toujours </b> être <b> 1 </b> pour votre première (ou seule) carte Pinscape,
         ou DOF ne pourra pas y accéder.
      </p>

      <div>
         <select id="popPinscapeID" style="margin-right: 2em;">
            <option value="1">Pinscape Unit 1</option>
            <option value="2">Pinscape Unit 2</option>
            <option value="3">Pinscape Unit 3</option>
            <option value="4">Pinscape Unit 4</option>
            <option value="5">Pinscape Unit 5</option>
            <option value="6">Pinscape Unit 6</option>
            <option value="7">Pinscape Unit 7</option>
            <option value="8">Pinscape Unit 8</option>
            <option value="9">Pinscape Unit 9</option>
            <option value="10">Pinscape Unit 10</option>
            <option value="11">Pinscape Unit 11</option>
            <option value="12">Pinscape Unit 12</option>
            <option value="13">Pinscape Unit 13</option>
            <option value="14">Pinscape Unit 14</option>
            <option value="15">Pinscape Unit 15</option>
            <option value="16">Pinscape Unit 16</option>
         </select>
      </div>

   </div>


   <!-- reboot on disconnect ----------------------------------------------->
   <hr>
   <div class="section" data-name="Disconnect Reset">
      <img src="disconnect.png" class="sectionIcon">
      <b>Réinitialiser lors de la déconnexion. </b> Si la connexion USB est interrompue, et
      ne peut pas être rétabli dans un délai, la KL25Z peut se réinitialise automatiquement
      pour tenter de réparer tout ce qui ne va pas.
      Sélectionnez l'intervalle de temps (en secondes) avant que cela ne se produise.

      <div>
         <label><input type="checkbox" id="ckRebootEnable">Enabled</label>
         <div id="rebootOptions">       
            Temps avant le redémarrage (secondes):
            <input type="text" id="txtRebootTime" size=4 style="margin-left: 1em;">
         </div>
      </div>

      <div>
         <a href="#" class="shower">Details</a>
         <div class="hider">
            <b>Details</b><br>
            Sur certains systèmes, la KL25Z a du mal à rétablir une connexion USB,
	    par exemple après le redémarrage ou la mise hors tension du PC.
            Cela peut généralement être résolu en réinitialisant le KL25Z. Si vous définissez
            cette option, la KL25Z se réinitialise automatiquement lorsqu'elle détecte une
            connexion interrompue et ne peut pas se reconnecter dans le délai spécifié de la
            limite de temps. Le délai est là pour éviter les réinitialisations inutiles lorsque
            la connexion ne fonctionne que momentanément. Le réglage recommandé est de 10 secondes.
         </div>
      </div>
   </div>

   <script>
$("#ckRebootEnable").change(function(ev) {
    var show = $(this).prop("checked");
    slideToggle($("#rebootOptions"), show, 250, !!ev.originalEvent);
    if (show && $("#txtRebootTime").val() == 0)
        $("#txtRebootTime").val(10);
});

$("#txtRebootTime").change(function() {
    var val = $(this).val().trim();
    if (!/^\d+$/.test(val))
        $(this).val(+config.disconnectRebootTime);
    else if (+val < 1 && $("#ckRebootEnable").prop("checked"))
        $(this).val(1);
    else if (+val < 0)
        $(this).val(0);
    else if (+val > 255)
        $(this).val(255);
    else if (val != +val)
        $(this).val(+val);
});
   </script>


   <!-- TV On button ------------------------------------------------------->
   <a name="TVON"></a>
   <hr>
   <div class="section" data-name="TV ON">
      <img src="tvon.png" class="sectionIcon">
      <b>Interrupteur TV ON.</b>  Si un ou plusieurs de vos moniteurs doivent être allumés
      manuellement chaque fois que vous allumez votre pincab, vous pouvez utiliser cette fonction
      pour les activer automatiquement. Consultez le Guide de construction pour les instructions de câblage.

      <div>
         <div>
            <label><input id="tvOnEnabled" type="checkbox">Activer</label>
            <span style="margin-left: 2em;" id="tvOnTestButton">
               <a href="#" id="btnTvOnTest" class="button">Test</a>
            </span>
         </div>
         <div id="tvOnPins">
            <table class="inputs">
               <tr class="expBoardPin">
                  <td class="pinlabel">Entrée d'état de l'alimentation:</td>
                  <td>
                     <span class="pinselect" id="tvStatus"
                       data-cfg="TVon.statusPin" data-gpiotype="dig-in extern"
                       data-desc="TV ON Power Status Input" data-default="PTD2">
                     </span>
                  </td>
               </tr>
               <tr class="expBoardPin">
                  <td class="pinlabel">Sortie de verrouillage d'état:</td>
                  <td>
                     <span class="pinselect" id="tvLatch"
                       data-cfg="TVon.latchPin" data-gpiotype="dig-out extern"
                       data-desc="TV ON Status Latch" data-default="PTE0">
                     </span>
                  </td>
               </tr>
               <tr class="expBoardPin">
                  <td class="pinlabel">Sortie relais:</td>
                  <td>
                     <span class="pinselect" id="tvRelay"
                       data-cfg="TVon.relayPin" data-gpiotype="dig-out extern"
                       data-desc="TV ON Relay Output" data-default="PTD3">
                     </span>
                  </td>
               </tr>
               <tr>
                  <td>Délai de démarrage (secondes):</td>
                  <td><input type="text" id="tvDelay" size=4></td>
                  <td style="padding-left: 2em;">C'est le temps d'attente après la mise sous tension avant de pulser le relais</td>
               </tr>
            </table>
         </div>
      </div>
   </div>

   <script>

var oldTVOn = { };
$("#tvOnEnabled").click(function(ev) 
{
    // if we're disabling it, set the pins to NC, but save the
    // current values first in case the user re-enables it
    var ena = $(this).prop("checked");
    if (!ena)
    {
        function saveAndClear(id) { 
            oldTVOn[id] = $(id).val(); 
            $(id).val("No connected");
        }
        saveAndClear("#tvStatus .pinval");
        saveAndClear("#tvLatch .pinval");
        saveAndClear("#tvRelay .pinval");
    }

    // show or hide the pin assignment fields
    showTvOn(ena, true, ena);
});
$("#tvStatus, #tvLatch, #tvRelay").change(function()
{
    // if any of these are set, enable the whole feature
    var ena = $("#tvStatus .pinval").val() != "No connected"
              || $("#tvLatch .pinval").val() != "No connected";

    // If we're newly enabling it, show the details section.
    // Don't hide the section on disabling, though, since the
    // user might only be making a temporary change.
    var ck = $("#tvOnEnabled");
    if (ena && !ck.prop("checked"))
        showTvOn(true, false, false);

    // if we're loading the config, hide the section initially
    // no pins are enabled
    if (loadingConfig && !ena)
        showTvOn(false, false, false);

    // bring the checkbox into alignment with the settings
    ck.prop("checked", ena);
});

function showTvOn(show, scroll, setDefs)
{
    // show the pin selectors
    slideToggle($("#tvOnPins"), show, 250, scroll);
    $("#tvOnTestButton").toggle(show);
    $("#tvOnPins .pinselect").data("active", show);

    // set defaults if desired
    if (setDefs)
    {
        function def(id, def) {
            var ctl = $(id);
            if (ctl.val() == "No connected")
                ctl.val(oldTVOn[id] || def).change();
        }
        def("#tvStatus .pinval", "PTD2");
        def("#tvLatch .pinval",  "PTE0");
        def("#tvRelay .pinval", "PTD3");
    }

    // update pin warnings
    updatePinWarnings();
}

$("#btnTvOnTest").click(function(ev)
{
    // don't open the link
    ev.preventDefault();

    // check for pin changes
    function pin(sel) { var p = $(sel).val(); return p == "No connected" ? "NC" : p; }
    if (pin("#tvStatus .pinval") != config.TVon.statusPin
        || pin("#tvLatch .pinval") != config.TVon.latchPin
        || pin("#tvRelay .pinval") != config.TVon.relayPin)
    {
        if (!window.external.YesNoDialog(
            "Vous avez apporté des modifications à la configuration TV ON que vous n'avez pas"
            + "déjà programmé dans le KL25Z. La fenêtre du testeur reflétera"
            + "les paramètres actuels de l'appareil, pas vos nouvelles modifications non enregistrées."
            + "Si vous souhaitez tester vos nouveaux paramètres, cliquez sur \" Programmer KL25Z \" "
            + "avant de passer à la fenêtre du testeur."
            + "\ r \ n \ r \ n"
            + "Voulez-vous quand même ouvrir le testeur?"))
            return;
    }

    // show the dialog
    window.external.ShowTvOnTester(CPUID);
});
   </script>


   <!-- IR Remote Control -------------------------------------------------->
   <hr>
   <div class="section" data-name="IR Remote">
      <img src="irRemote.png" class="sectionIcon">
      <b>Télécommande IR.</b>  Le contrôleur peut envoyer et / ou recevoir des 
      signaux IR de télécommande si vous connectez des composants supplémentaires. C'est
      peut être utilisé avec la fonction <a href="#TVON"> TV ON </a> pour activer
      vos téléviseurs sous tension via les commandes IR au démarrage du système. Voir le 
      guide de construction pour plus de détails sur les composants requis et comment les
      connecter.
      Si vous n'avez aucun composant IR connecté ou si vous souhaitez les désactiver,
      définissez simplement ici les affectations des broches sur «Non connecté».

      <div id="irRemotePins">
         <table class="inputs">
            <tr class="expBoardPin">
               <td class="pinlabel">Broche LED IR (émetteur):</td>
                  <td>
                     <span class="pinselect" id="irTransmitter"
                       data-cfg="IRRemote.ledPin" data-gpiotype="pwm tpm extern"
                       data-desc="IR LED transmitter output pin" data-default="PTC9">
                     </span>
                  </td>
                  <td>
                     Nécessite une broche compatible PWM
                  </td>
               </tr>
               <tr class="expBoardPin">
                  <td class="pinlabel">Broche d'entrée du récepteur IR:</td>
                  <td>
                     <span class="pinselect" id="irReceiver"
                       data-cfg="IRRemote.sensorPin" data-gpiotype="interrupt-in extern"
                       data-desc="IR remote control receiver input pin" data-default="PTA13">
                     </span>
                  </td>
                  <td>
                     Nécessite une broche capable d'interrompre
                  </td>
               </tr>
            </table>
      </div>
      <div id="noIrRemotePins" style="display:none;">
         La version du micrologiciel installée sur votre appareil ne prend pas en charge la 
         fonctionnalités IR à distance. Mettez à jour le dernier micrologiciel pour activer ces fonctionnalités.
      </div>

      <div id="irCommands">
         <b>Liste des commandes IR.</b>  Vous pouvez programmer la carte Pinscape avec la télécommande
         de contrôle qu'il peut ensuite envoyer et recevoir. Chaque emplacement ci-dessous
         stocke un code.  <a href="#" id="helpIR">Help</a>
         <div>
            <table id="irCommandTab">
            </table>
         </div>
         <div id="irCommandTabStretchNote">
            <i><b>Note :</b>votre version actuelle du micrologiciel peut stocker jusqu'à
            <span id="irCommandTabMaxNote">0</span> codes. La liste ci-dessus se développera
	    automatiquement au fur et à mesure que vous remplissez de nouvelles lignes, jusqu'à
            la limite.</i>
         </div>
      </div>

   </div>

   <script type="text/javascript">

$("#helpIR").click(function(ev) {
    ev.preventDefault();
    window.external.ShowHelp("HelpIR.htm");
});

// Update the IR receiver and sender command pins.  The IR command
// table is only shown if we have at least one of these enabled.
$("#irTransmitter, #irReceiver").change(function() {
    var ena = $("#irTransmitter").children(".pinval").val() != "No connected"
              || $("#irReceiver").children(".pinval").val() != "No connected";
    slideToggle($("#irCommands"), ena, loadingConfig ? 0 : 250, false);
});

// Show the IR command selectors on the button inputs and the IR
// test buttons on the code slots only if we have an IR transmitter
// configured.
$("#irTransmitter").change(function() {
    var ena = $("#irTransmitter").children(".pinval").val() != "No connected";
    $("#buttonTab .keyIR, #irCommands .irTest").toggle(ena);
});

// Show the IR learn buttons on the code slots only if we have an
// IR receiver configured.
$("#irReceiver").change(function() {
    var ena = $("#irReceiver").children(".pinval").val() != "No connected";
    $("#irCommands .irLearn").toggle(ena);
});


// Build the IR command table rows using the number of slots in the
// firmware config.  This is a fixed maximum in the firmware, so it's
// only necessary to do this once when first loading the config.
var irCommandTabMax = 0;
function sizeIRCommandTab(config)
{
    // we only have to do this once per load
    if (irCommandTabMax)
        return false;
    
    // figure the table size
    var count = 0;
    $.each(config.IRCode1, function(key) { if (/\d+/.test(key)) ++count; });

    // remember it globally and set the note
    $("#irCommandTabMaxNote").html(irCommandTabMax = count);

    // build the table
    var tab = $("#irCommandTab");
    tab.html("<tr><th>#</th><th>IR Code</th><th></th><th>TV ON</th><th>Key</th><th>Description</th></tr>");
    for (var i = 1 ; i <= count ; ++i)
    {
        var row =
            "<tr class=\"irCommandRow buttonRow\" data-irrow=\"" + i + "\">"
            + "<td>" + i + "</td>"
            + "<td class=\"irCode\">"
            +   "<input type=\"text\" size=\"22\">"
            +   "<input type=\"hidden\" class=\"irFlags\">"
            +   "<input type=\"hidden\" class=\"irProtocol\">"
            +   "<input type=\"hidden\" class=\"irCodeLo\">"
            +   "<input type=\"hidden\" class=\"irCodeHi\">"
            + "</td>"
            + "<td class=\"irCodeCtls\">"
            +   "<span class=\"irLearn\" title=\"Apprenez un code à partir d'une télécommande\"></span>"
            +   "<span class=\"irTest\" title=\"Tester l'envoi de ce code\"></span>"
            + "</td>"
            + "<td>"
            +   "<span class=\"irTVON\" title=\"Envoyez cette commande au démarrage du système pour allumer vos téléviseurs sur le pincab\">"
            +   "</span>"
            + "</td>"
            + "<td>"
            +   "<span class=\"keymappingContainer\">"
            +     "<span class=\"keymapping\" id=\"keymapIR" + i + "\">"
            +       "<span class=\"keyname\"></span>"
            +       "<span class=\"keycode\"></span>"
            +       "<span class=\"keytype\"></span>"
            +     "</span>"
            +   "</span>"
            + "</td>"
            + "<td><input class=\"irDesc\" type=\"text\" size=20\"></td>"
            + "</tr>";
        tab.append($(row));
    }

    // schedule all rows for refresh when we're idle
    $("#irCommandTab .keymapping .keycode, #irCommandTab .keymapping .keytype").change(function(ev) {
        IRTabUpdate.touch($(this));
    });

    // set the hidden code component field change handlers
    $("#irCommandTab .irCode input:hidden").change(function() {
        IRTabUpdate.touch($(this));
    });

    // set the key and 'change' handler for typing in a code
    $("#irCommandTab .irCode input:text").keydown(function(ev)
    {
        switch (ev.keyCode)
        {
        case 13:
        case 10:
            // on Enter/Return, apply the change
            $(this).change();
            break;
            
        case 27:
            // on Escape, revert to the old code
            IRTabUpdate.touch($(this));
            break;
        }
    }).change(function()
    {
        // get the row
        var self = $(this);
        var td = self.parent();

        // parse the value
        self.removeClass("error").attr("title", "IR Code: Protocol.Flags.64BitCode as hex digits");
        var val = self.val();
        var protocol, flags, codeLo, codeHi;
        if (/^\s*$/.test(val))
        {
            // empty - set all fields to zero
            protocol = flags = codeHi = codeLo = 0;
        }
        else if (/^\s*([0-9a-f]{1,2})\s*\.\s*([0-9a-f]{1,2})\s*\.\s*([0-9a-f]{1,16})\s*$/i.test(val))
        {
            // valid format - pull out the components and set the new code value
            protocol = parseInt(RegExp.$1, 16);
            flags = parseInt(RegExp.$2, 16);
            var code = RegExp.$3;

            // break the code into two 8-character hex parts for high and low
            code = zeroPad(code, 16);
            codeHi = parseInt(code.substr(0, 8), 16);
            codeLo = parseInt(code.substr(8, 8), 16); 

            // if the protocol if 0, it means "empty"; normalize all fields to zero
            if (protocol == 0)
                flags = codeHi = codeLo = 0;

        }
        else
        {
            // invalid format - mark it as an error
            self.addClass("error").attr("title", "Format incorrect: utilisez Protocol.Flags.64BitCode, comme "
                                        + "chiffres hexadécimaux. Appuyez sur Echap pour revenir à la valeur précédente.");
            return;
        }

        // set the component fields
        td.children(".irProtocol").val(protocol);
        td.children(".irCodeHi").val(codeHi);
        td.children(".irCodeLo").val(codeLo);

        // The Flags field combines bit flags represented numerically in
        // the code, plus flags represented as buttons:
        //
        //   0x01  -> TV ON, represented via the TV ON button
        //   0x02  -> "ditto" protocol mode, represented in the numeric flags
        //
        // When applying the numeric value, then, we only want to change the
        // bits that are actually represented in the field, and keep the
        // separate button flags unchanged.
        var f = td.children(".irFlags");
        var nonNumFlags = 0x01;
        f.val((+f.val() & nonNumFlags) | (flags & ~nonNumFlags));

        // schedule an update
        IRTabUpdate.touch(td);
    });

    // set the key-mapping handler
    $("#irCommandTab .keymapping").click(keymappingClick);

    // set the code input handler
    $("#irCommandTab .irCode input:hidden").change(function(ev) {
        var self = $(this);
        IRTabUpdate.touch(self);
    });

    // set the Learn button handler
    $("#irCommandTab .irLearn").click(function(ev) {
        var code = window.external.ShowIRLearn(CPUID);
        if (code)
            $(this).parents(".irCommandRow").find(".irCode input:text").val(code).change();
    });

    // set the Test button handler
    $("#irCommandTab .irTest").click(function(ev)
    {
        // check for a change in configuration
        if (config.IRRemote.ledPin == "NC")
        {
            alert("L'émetteur IR n'est pas encore configuré sur l'appareil. "
                  + "Vous devrez enregistrer l'affectation des broches de l'émetteur IR "
                  + "en cliquant sur \Program KL25Z\ avant de pouvoir envoyer des codes.");
            return;
        }
        if (config.IRRemote.ledPin != $("#irTransmitter .pinval").val())
        {
            window.external.ShowAdviceDialog(
                "ReprogrammedIRLEDPin",
                "Vous avez modifié l'affectation des broches de la LED IR, mais vous "
                + "Je n'ai pas encore programmé le KL25Z avec les changements, donc"
                + "ceci enverra en utilisant l'ancienne affectation des broches. Si vous le souhaitez"
                + "pour tester avec la nouvelle affectation des broches, enregistrer la nouvelle broche"
                + "Paramètres en cliquant d'abord sur \Programmer KL25Z\ ");
        }

        // get try sending the code
        var btn = $(this);
        var code = $(this).parents(".irCommandRow").find(".irCode input:text").val();
        showCallResult(window.external.SendIRCommand(CPUID, code), {
            "ok": function() {
                btn.addClass("sending");
                var i = 0, flash = function() {
                    btn.toggleClass("sending");
                    if (i++ < 4) setTimeout(flash, 75);
                };
                setTimeout(flash, 75);
            }
        })
    });

    // set the TV ON button handler
    $("#irCommandTab .irTVON").click(function(ev)
    {
        // get the input.irFlags element in the row
        var self = $(this);
        var inp = self.parents(".irCommandRow").find(".irCode .irFlags");

        // invert the TV ON bit (0x01) in the flags and update the row
        inp.val(+inp.val() ^ 0x01);
        IRTabUpdate.touch(self);
    });

    // tell the caller we rebuilt the table
    return true;
}

function stretchIRTable()
{
    var last = 0;
    $("#irCommandTab .irCommandRow").each(function() {
        var tr = $(this);
        var idx = +tr.data("irrow");
        if (idx > irCommandTabMax) return false;
        if (idx >= last && +tr.find(".irCode .irProtocol").val() != 0)
            last = idx;
    });

    // show one blank row if we haven't maxed out the table
    if (last < buttonTabMax) ++last;

    $("#irCommandTab .irCommandRow").each(function() {
        $(this).toggle(+$(this).data("irrow") <= last);
    });

    $("#irCommandTabStretchNote").toggle(last < buttonTabMax);
}

function zeroPad(str, len)
{
    if (str.length < len)
    {
        var cnt = len - str.length;
        var zero = "0000000000000000";
        while (zero.length < cnt) zero += zero;
        str = zero.substr(0, cnt) + str;
    }
    return str;
}

function updateIRRow(tr)
{
    // flags represented via separate controls rather than numerically:
    //   0x01 -> TV ON
    var nonNumFlags = 0x01;

    // build the code from the components
    var td = tr.children(".irCode");
    var pro = +td.children(".irProtocol").val();
    var flags = +td.children(".irFlags").val();
    var codeLo = +td.children(".irCodeLo").val();
    var codeHi = +td.children(".irCodeHi").val();
    td.children("input:text").val(
        (pro == 0 ? "" :
         pro.toString(16)
         + "." + (flags & ~nonNumFlags).toString(16)
         + "." + (codeHi != 0 ? codeHi.toString(16) + zeroPad(codeLo.toString(16), 8) : codeLo.toString(16))
        ).toUpperCase()
    );

    // update the TV ON button from bit 0x01 in the flags
    tr.find(".irTVON").toggleClass("active", (flags & 0x01) != 0);

    // update the key cap
    updateKeyCap(tr.find(".keymapping"));
}

var IRTabUpdate = {
    touch: function(item) {  // item can be a button row element (TR) or any element within a row
        if (!item.is("tr"))
            item = item.parents("tr.irCommandRow");
        this.pending[item.data("irrow")] = item;
        if (!this.queued) {
            var self = this;
            setTimeout(function() { self.go(); }, 1);
            this.queued = true;
        }
    },
    pending: { },
    queued: false,
    go: function() {
        $.each(this.pending, function(key, val) {
            updateIRRow(val);
        });
        stretchIRTable();
        this.queued = false;
        this.pending = { };
    }
};

// prepare the IR command selector popup
function prepIRCommandSelector(curSelIdx, clickFunc)
{
    // start with the "none" row
    var lst = [];
    var ck = function(idx) {
        return "<span class='IRCheck'>"
            + (idx == curSelIdx ? "&#10004;" : "")
            + "</span>";
    };
    lst.push("<div data-idx='0'>"
             + ck(0)
             + "(No IR Command)"
             + "</div>");

    // build the list of commands
    $("#irCommandTab .irCommandRow").each(function() {
        var tr = $(this);
        var idx = +tr.data("irrow");
        if (idx <= irCommandTabMax && +tr.find(".irCode .irProtocol").val() != 0)
        {
            lst.push("<div data-idx=\"" + idx + "\">"
                     + ck(idx)
                     + "<span class='IRIdx'>#" + idx + ":</span>"
                     + "<span class='IRCode'>" + tr.find(".irCode input:text").val() + "</span>"
                     + "<span class='IRDesc'>" + tr.find(".irDesc").val() + "</span>"
                     + "</div>");
        }
    });

    // populate the command selector
    $("#IRCommandList").html(lst.join(""));

    // assign the click function to each row
    $("#IRCommandList > div").click(clickFunc);

    // return the number of command rows (excluding the "none" row)
    return lst.length - 1;
}
      
   </script>

   <!-- joystick enable ---------------------------------------------------->
   <hr>
   <div class="section" data-name="Joystick">
      <img src="joystick.png" class="sectionIcon">
      <b>Entrée joystick.</b>  Le contrôleur agit comme un joystick USB Windows
      pour envoyer la position du piston, les lectures de l'accéléromètre (pour pousser),
      et touchez les entrées du PC. Vous pouvez désactiver ses entrées si vous le souhaitez.

      <div>
         <label><input id="ckJoystick" type="checkbox"> Activer l'entrée par joystick</label>
      </div>

      <div>
         <a href="#" class="shower">Why would I want to disable this?</a>
         <div class="hider">
            <b>Pourquoi voudrais-je désactiver cela?</b><br>
            Par défaut, chaque carte Pinscape rapporte ses lectures d'accéléromètre
            au PC via l'interface joystick. Si vous en avez plus d'une d'installée, 
	    cela signifie que vous aurez plus d'un ensemble de ces rapports qui arrivent.
	    Les rapports supplémentaires peuvent semer la confusion dans certains logiciels de
	    flippers et peuvent également affecter les performances du système. Cette option
            vous permet de désactiver les rapports supplémentaires des unités secondaires. Si
            vous avez un tire-bille attaché à l'une des cartes, vous devriez considérer
            celui-là pour être sur votre carte principale et quitter son interface joystick
            activée. Vous devez désactiver l'interface du joystick sur toutes les autres cartes.
         </div>
      </div>

	  <div id="jsAxisFormat">
		 Joystick axis format: <select id="jsAxisList" style="margin: .5ex 1em .5ex 1em;">
			<option value="0">X/Y/Z</option>
			<option value="1">Rx/Ry/Rz</option>
		 </select>
		 <a href="#" class="shower">Qu'est-ce que c'est ça?</a>
		 <div class="hider">
			<p>
			   	Un vrai joystick signale la position du manche en envoyant une valeur "Axe X" pour la gauche / droite
				La position du manche et une valeur "Axe Y" pour la position haut / bas.
				Il peut également envoyer une valeur "Axe Z" pour représenter un autre contrôle comme un
				Manette de Gaz. Normalement, Pinscape utilise ces trois mêmes axes, en
				envoi de lectures d'accéléromètre sur les axes X et Y, et la lecture du piston
				sur l'axe Z. Le protocole USB pour les joysticks définit également
				un ensemble d'axes "rotationnels" appelés Rx, Ry et Rz. De vrais joysticks 
				autorisent les mouvements de torsion et rapportent ces mouvements sur ces axes "R".
				Si vous le souhaitez, Pinscape peut rapporter ses lectures normales sur les axes "R"
				à la place des axes X / Y / Z normaux.
			</p>
			<p>
               			Pourquoi voudriez-vous utiliser les axes "R"? Dans la plupart des cas, vous ne le feriez pas,
               			les paramètres X / Y / Z normaux sont recommandés car ils sont compatibles
               			avec la plupart des logiciels. Cependant, les axes "R" peuvent être utiles si vous avez
               			d'autres joysticks dans votre système qui sont en conflit avec Pinscape.
               			Si votre autre joystick signale son entrée sur les axes X / Y / Z normaux,
              			cela crée des problèmes avec VP ou d'autres logiciels, vous
               			pourrait être en mesure de résoudre le conflit en disant à Pinscape d'utiliser les
               			Axes Rx / Ry / Rz à la place.
			</p>
			<p>
				<b>Si vous modifiez les axes Pinscape, vous devez également reconfigurer
               			Visual Pinball et tout autre émulateur de flipper à utiliser les axes Rx / Ry / Rz.</b> 
			   	Future Pinball n'a aucun moyen de lire les axes Rx / Ry / Rz,
               			donc les utiliser dans Pinscape le rendra incompatible avec FP.
			   	Vous pourriez rencontrer la même limitation dans d'autres logiciels. Car
              			des problèmes de compatibilité, vous constaterez peut-être qu'il vaut mieux
               			reconfigurer l '<b> autre </b> joystick qui crée le conflit, si possible,
				car cela vous permettrait de continuer à utiliser les axes X / Y / Z compatibles pour Pinscape.
			</p>
		 </div>
	  </div>

	  <div id="jsReportTiming">
		 Intervalle de rapport du joystick (millisecondes): <input type="text" size="6" id="jsReportInterval">
		 <a href="#" class="shower">Explication</a>
		 <div class="hider">
			<p>
			   Cela vous permet de définir le temps entre les rapports du joystick que l'appareil 
				envoie au PC sur la connexion USB. Ces rapports envoient les informations actuelles
				sur les lectures de l'accéléromètre, la position du tire-bille, et l'état de la 
				pression des boutons pour tous les boutons attribués au joystick.
			</p>
			<p>
			   Pinscape est capable d'envoyer des rapports aussi rapidement tous les 1 à 2
				millisecondes. (La vitesse exacte dépend du type de tire-bille
				et autre matériel externe que vous utilisez.) Mais nous ne veulont pas
				envoyer de rapports aussi vite que possible, car Windows et Visual Pinball
				ne peuvent pas les digérer à ce rythme. Ce paramètre vous permet de ralentir
				les rapports à un taux approprié pour le PC.
			</p>
			<p>
			   <b>Recommandation : </b> commencer avec un temps d'entrée de <b> 8,333 ms </b>
				et un paramètre de "tremblement de l'accéléromètre" de <b> 2 </b>. Ceci 
				fonctionnent bien sur la plupart des systèmes, mais ce n'est pas nécessairement optimal pour
				tout le monde, car les caractéristiques de synchronisation de VP peuvent varier en fonction
				à la configuration de votre PC. Vous devrez peut-être expérimenter pour trouver les
				paramètres idéaux pour votre système. Après avoir ajusté le timing,
				testez le coup de coude avec VP. Si cela semble naturel, gardez les paramètres.
				Si la réponse de VP du coup de coude semble erratique (par exemple, il ignore
				certains coups de coude, mais réagit de manière excessive aux autres), essayez différents entrées.
				Il est préférable de maintenir le réglage dans une plage d'environ 5 ms à 20 ms.
				Tout ce qui est inférieur à 5 ms sera trop rapide à digérer pour Windows correctement,
				et tout ce qui dépasse 20 ms peut produire de la latence (les jeux répondent lentement
				aux pressions sur les boutons et aux coups de coude).
			</p>
		 </div>
	  </div>

	  <div id="accelStutter">
		 Accéléromètre "tremblement": <input type="text" size="6" id="accelStutterCount">
		 <a href="#" class="shower">Explication</a>
		 <div class="hider">
			<p>
			   Le paramètre de «tremblement» fonctionne avec le joystick <b>
				intervalle de rapport </b> ci-dessus pour définir l'intervalle entre les rapports de
				l'accéléromètre La lecture de l'accéléromètre est envoyée dans le cadre de rapport du 
				joystick de sorte que l'intervalle de base entre les lectures de l'accéléromètre est
				exactement identique à l'intervalle de rapport du joystick. Ce paramètre vous permet de 
				ralentir les lectures de l'accéléromètre à un multiple du joystick intervalle.
			</p>
			<p>
			   Le tremblement est le nombre de fois que chaque accéléromètre physique lit est répétée dans
				les rapports séquentiels du joystick. Si vous définissez le tremblement à 1, cela 
				signifie qu'une nouvelle lecture est envoyée avec chaque rapport de joystick envoyé au PC.
				Si vous le définissez sur 2, une nouvelle lecture est envoyée avec chaque <b> autre </b> rapport,
				et les rapports alternés simplement répéte la lecture précédente. Si vous le réglez sur 3,
				une nouvelle lecture est effectuée tous les trois rapports.
			</p>
			<p>
			   Pourquoi voudriez-vous ralentir les lectures de l'accéléromètre? Car VP ne peut pas utiliser les
				lectures si elles arrivent trop rapidement. Pour un meilleur résultats dans VP, les lectures
				doivent être envoyées qu'une seule fois par cycle vidéo.
				Si votre carte graphique est réglée sur une fréquence de rafraîchissement de 60 Hz, la vidéo,
				le cycle dure 16,667 millisecondes, donc VP fonctionnera mieux si vous envoyez la lectures
				de l'accéléromètre toutes les 16,667 ms. Cependant, vous voudrez peut-être envoyer les
				rapports du joystick plus rapidement que cela, de sorte que le bouton du joystick,
				les mises à jour soient envoyées plus près du temps réel. C'est là que le tremblement,
				le réglage entre en jeu: il vous permet d'envoyer des rapports de joystick à un
				rythme pour réduire la latence des boutons, mais ralenti l'accéléromètre, les lectures pour
				tenir compte de la lenteur de VP à les lire.
			</p>
			<p>
			   <b>Recommendation:</b> commencer par un intervalle de rapport du joystick de <b> 8,333 ms </b> et 
				un paramètre de tremblement de <b> 2 </b>. Cette volonté de lire l'accéléromètre à 60 Hz, ce
				qui est généralement optimal pour VP, mais enverra les mises à jour des entrées de bouton
				deux fois plus souvent, ce qui pourrait rendre d'autres programmes utilisant les boutons du
				joystick plus sensible. Le timing optimal dans VP peut varier selon la configuration de votre PC.
				Vérifiez le taux de rafraîchissement de votre carte vidéo (utilisez le taux de la carte vidéo,
				<b> pas </b> l'actualisation du moniteur taux). S'il ne s'agit pas de 60 Hz, choisissez un
				intervalle de rapport proche de 10 ms qui se divise uniformément dans l'intervalle de
				rafraîchissement, et choisissez un temps de tremblement égal à l'intervalle de rafraîchissement
				divisé par l'intervalle de rapport. Si votre carte vidéo s'actualise à 120 Hz, par exemple,
				utilisez un intervalle de 8,333 ms et réglez le tremblement sur 1.
			</p>			   
		 </div>
	  </div>

   </div>

   <script type="text/javascript">

$("#ckJoystick").change(function() {
	var ena = $(this).prop("checked");
    slideToggle($("#jsAxisFormat"), ena, loadingConfig ? 0 : 250, false);
});
	  
   </script>


   <!-- accelerometer settings --------------------------------------------->
   <hr>
   <div class="section" data-name="Accelerometer">
      <img src="orientation.png" class="sectionIcon">
      <b>Orientation de l'accéléromètre. </b> Si vous utilisez l'accéléromètre
      (pour la détection de nudge), le logiciel a besoin de savoir comment la KL25Z est orientée
      dans le pincab afin qu'il puisse signaler les mouvements dans la bonne direction. Installer
      la KL25Z dans l'une des orientations indiquées ci-dessous, au niveau du sol du pincab,
      avec les puces et les LED orientées vers le haut.

      <div>

         <table class="radio">
            <tr style="margin: auto;">
               <td>
                  <label>
                     <img src="accel-front.png"><br>
                     <input type="radio" name="accelOrientation" value="0">
                     Ports face à l'avant
                  </label>
               </td>
               <td>
                  <label>
                     <img src="accel-left.png"><br>
                     <input type="radio" name="accelOrientation" value="1">
                     Ports tournés vers la gauche
                  </label>
               </td>
               <td>
                  <label>
                     <img src="accel-right.png"><br>
                     <input type="radio" name="accelOrientation" value="2">
                     Ports orientés à droite
                  </label>
               </td>
               <td>
                  <label>
                     <img src="accel-rear.png"><br>
                     <input type="radio" name="accelOrientation" value="3">
                     Ports orientés vers l'arrière
                  </label>
               </td>
            </tr>
         </table>

      </div>


      <div id="newAccelFeatures">
         <div style="margin-top: 2em;"><b>Plage dynamique.</b>  Sélectionnez la plage pour les
            lectures de l'accéléromètre. Plages ci-dessus &plusmn;2G ont une précision inférieure.
            <a href="#" class="shower">Details</a>

            <div class="hider">
               <p>
                  Le matériel de l'accéléromètre de la KL25Z dispose de trois paramètres de plage natifs:
                  &plusmn;2G, &plusmn;4G, and &plusmn;8G.  (Un "G" est l'accélération de la gravité
		  terrestre, 9.8m/s&sup2;.)  L'appareil offre les options car chacun est un compromis
		  entre précision et gamem dynamique, et certaines applications se soucient davantage
		  de la précision tandis que d'autres se soucient plus de la portée. <i> La précision </i> 
		  est la capacité de discerner la différence entre les nudges qui sont très rapprochés
		  dans la force. <i> La plage dynamique </i> est la capacité de faire la différence
                  entre des coups de coude qui sont très éloignés en force. Dans la gamme 2G,
                  l'appareil a la meilleure précision, mais le compromis est que les lectures
                  sont plafonnés à 2G, donc les accélérations réelles supérieures à 2G lu comme 2G.
		  Les gammes 4G et 8G augmentent le plafond, permettant une vraie lectures jusqu'aux
		  limites respectives, mais le compromis est qu'ils perdent une partie de la capacité
		  de distinguer les lectures qui sont très proches les unes des autres.
               </p>
               <p>
                  Pour l'utilisation du flipper virtuel, les paramètres 1G ou 2G sont recommandés,
                  car la précision est plus importante pour nous que la portée. Ça le fait
                  plus réaliste si le jeu peut discerner de fines nuances de force.
                  Il n'est pas aussi important de distinguer les accélérations très élevées de
                  l'un comme de l'autre, car tout ce qui dépasse un certain point n'est qu'un
                  TILT quand même.
               </p>
               <p>
                  1G est la valeur par défaut car c'était le paramètre fixe dans les anciennes versions
                  du firmware Pinscape, avant que cette option n'existe. 1G produira les mêmes effets
		  que vous utilisez si vous aviez des versions précédentes installées.
                  Si vous le souhaitez, vous pouvez passer en 2G sans perte de précision, car 1G et 2G
		  utilisent les mêmes paramètres de périphérique natifs. Si vous changez pour 2G, vous
		  devez ajuster vos paramètres VP "gain d'axe" (dans les préférences clavier) pour
		  compenser, en doublant les anciens paramètres. De même, si vous décidez d'essayer
		  la 4G ou la 8G, doublez à nouveau les paramètres de gain en 4G, et encore une fois à 8G.
               </p>
            </div>

         <div style="margin-left: 2em; margin-top: 0ex;">
            <label><input type="radio" name="accelRange" value="0"> &plusmn;1G
             (réglage Pinscape original, plus haute précision)</label><br>
            <label><input type="radio" name="accelRange" value="1"> &plusmn;2G
             (même précision que &plusmn;1G mais avec une gamme plus large)</label><br>
            <label><input type="radio" name="accelRange" value="2"> &plusmn;4G
             (précision réduite, plage plus large)</label><br>
            <label><input type="radio" name="accelRange" value="3"> &plusmn;8G
             (précision la plus basse, plage la plus large)</label><br>
         </div>
      </div>

      <div style="margin-top: 2em;">
         <b>Centrage automatique. </b> Le contrôleur met automatiquement à zéro 
         l'accéléromètre après avoir été immobile pendant un certain temps. Cela
         compense toute inclinaison en position de montage. Si vous préfèrez,
         vous pouvez désactiver le centrage automatique et le centrer manuellement
         au besoin en utilisant le <a href="#" id="accJoystickLink">Joystick visuel</a>.

         <div id="autoCenterRadioButtons">
            <div>
               <label><input type="radio" name="autoCenterMode" value="255"> Centrer manuellement uniquement (pas de centrage automatique)</label>
            </div>
            <div>
               <label><input type="radio" name="autoCenterMode" value="0"> Centrage automatique avec heure par défaut (5 secondes)</label>
            </div>
            <div>
               <label><input type="radio" name="autoCenterMode" value="1"> Centrage automatique avec heure personnalisée</label>
               <div style="margin: 1ex 2em 0px 1em;" id="accelAutoCenterTimeDiv">
                  Temps par secondes: <input type="text" size="4" id="accelAutoCenterTime">
                  <span style="padding-left: 3em;"><i>1-60 secondes</i></span>
               </div>
            </div>
         </div>
      </div>
   </div>
   <div id="noNewAccelFeatures" style="display:none;">
      La version du micrologiciel installée sur votre appareil a une &plusmn; 1G fixe
      de plage dynamique de l'accéléromètre et centrage automatique (remise à zéro)
      après avoir été immobile pendant 5 secondes. Mettre à jour le dernier firmware
      si vous souhaitez personnaliser ces paramètres.
   </div>

   <script>
$("#accJoystickLink").click(function(ev) {
    ev.preventDefault();
    window.external.ShowJoystickViewer(CPUID);
});
$("#accelAutoCenterTime").change(function(ev) {
    var self = $(this);
    var v = self.val();
    self.toggleClass("error", v < 1 || v > 60);
});
$("#autoCenterRadioButtons input:radio[name=autoCenterMode]").change(function(ev) {
    var v = $("#autoCenterRadioButtons input:radio[name=autoCenterMode]:checked").val();
    $("#accelAutoCenterTimeDiv").toggle(v == 1);
});

   </script>



   <!-- plunger ------------------------------------------------------------>
   <hr>
   <div class="section" data-name="Plunger Sensor">
      <img src="plungerSection.png" class="sectionIcon">
      <b>Configuration du capteur de piston (tire-bille)</b>

      <div>
         Sensor type:
         <select id="plungerType" style="margin-left: 1em;">
            <option value="0">Aucun</option>
            <option value="1">TSL1410R</option>
            <option value="3">TSL1412S</option>
            <option value="5">Potentiomètre</option>
            <option value="6">AEDR-8300</option>
            <!-- <option value="8">TSL1401CL</option> -->
            <option value="9">VL6180X</option>
            <option value="10">AEAT-6012-A06</option>
            <option value="11">TCD1103</option>
         </select>
         <span style="margin-left: 2em;" id="plungerSensorButton">
            <a href="#" id="btnPlungerCal" class="button">Vue du capteur en direct</a>
         </span>

      </div>

      <div id="plungerPinGroup">
         <div id="plungerPinsTSL">
            <div id="tsl1410-1412-details">
               <img style="float: right; margin: 0px 0px 1em 2em;" src="TSL1410R.jpg">
               <b><span id="TSLName">TSL14xx</span> capteur optique. </b> C'est un grand
               capteur optique avec les pixels disposés sur une seule rangée, d'environ 3" de long.
               Nous détectons la position du piston en lisant l'image du capteur et à la recherche
	       de l'ombre projetée par le piston. Le bord de l'ombre nous raconte la position du piston.
            </div>
            <div id="tsl1401-details">
               <img style="float: right; margin: 0px 0px 1em 2em;" src="TSL1401CL.jpg">
               <b>TSL1401CL capteur de code à barres.</b> C'est un petit capteur optique que nous
               Utilisons pour lire la position du piston sur une «échelle» à code-barres. L'échelle a
               une série de minuscules codes à barres sur toute sa longueur, chaque code à barres représentant
               sa position. Lorsque le piston se déplace, le capteur glisse le long de l'échelle et
               nous pouvons lire la position actuelle en scannant le code à barres le plus proche. Cela
               nécessite la balance spécialement imprimée avec des codes à barres au format que
               le logiciel reconnaît.

               <div>
                  <b>Important! Ne confondez pas cela avec le TSL1410R. </b> Cette option
                  est pour le TSL14 <b> 01 </b> CL, qui est un capteur complètement différent
                  du TSL14 <b> 10 </b> R. Les deux sont aux extrêmes opposés de l'échelle de taille,
		  de sorte qu'ils ne peuvent pas être utilisés de manière interchangeable malgré le
                  noms confusément similaires. Le TSL1401CL mesure environ 8 mm de long et nous
                  utilisons la petite fenêtre pour lire un code-barres compact. L'<b> autre </b>
                  capteur mesure environ 3" de long et nous utilisons pour prendre des photos du piston
                  directement. Choisissez plutôt <b> TSL1410R </b> si vous utilisez cet autre capteur plus grand.
               </div>
            </div>
            <div class="expBoardPin">
               <b>Affectations des broches:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">SI (données série):</td>
                        <td>
                           <span class="pinselect" id="tsl_si"
                              data-cfg="plungerPins.a" data-gpiotype="dig-out extern"
                              data-desc="Plunger Sensor SI" data-default="PTE20">
                           </span>
                        </td>
                     </tr>
                     <tr>
                        <td class="pinlabel">CLK (horloge série):</td>
                        <td>
                           <span class="pinselect" id="tsl_clk"
                              data-cfg="plungerPins.b" data-gpiotype="dig-out extern"
                              data-desc="Plunger Sensor CLK" data-default="PTE21">
                           </span>
                        </td>
                     </tr>
                     <tr>
                        <td class="pinlabel">AO (données analogiques):</td>
                        <td>
                           <span class="pinselect" id="tsl_ao"
                              data-cfg="plungerPins.c" data-gpiotype="adc extern"
                              data-desc="Plunger Sensor AO" data-default="PTB0">
                           </span>
                        </td>
                        <td>Nécessite une broche compatible ADC (entrée analogique)</td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardText">
               Connectez le capteur au connecteur PISTON (JP2) sur la carte d'interface principale:
               <ul>
                  <li>Capteur AO1 / AO2 sur broche 1
                  <li>Capteur CLK sur broche 3
                  <li>Capteur VDD sur broche 5
                  <li>Capteur VPP (GND) sur broche 6
                  <li>Capteur SI sur broche 8
               </ul>
            </div>
            <div class="aioBoardText">
               Connectez le capteur aux connexions PISTON sur le Pinscape AIO:
               <ul>
                  <li>Capteur AO1/AO2 sur "Wiper"/INT
                  <li>Capteur CLK sur CHA/SCL
                  <li>Capteur VDD sur 3.3V
                  <li>Capteur VPP (GND) sur GND
                  <li>Capteur SI sur SDA
               </ul>
            </div>
         </div>
         <div id="plungerPinsPot">
            <div>
               <img src="slidePot.png" style="float: right; margin: 0px 0px 1em 2em;">
               <b>Potentionmètre. </b> Celui-ci utilise un potentiomètre à glissière,
               qui est une résistance variable avec un bouton de commande qui se déplace linéairement
               sur toute la longueur de l'appareil. Fixez le bouton de commande au piston de sorte
	       que le bouton se déplace avec le piston. 
               la résistance électrique change à mesure que le bouton bouge, proportionnellement à
               la position, afin que le contrôleur puisse déterminer la position du piston
               en lisant la tension sur l'entrée.
            </div>
            <div class="expBoardPin">
               <b>Affectations des broches:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">"Wiper = Essuie-glace":</td>
                        <td>
                           <span class="pinselect" id="pot_ao"
                              data-cfg="plungerPins.a" data-gpiotype="adc extern"
                             data-desc="Plunger Sensor AO" data-default="PTB0">
                           </span>
                        </td>
                        <td>Nécessite une broche ADC (entrée analogique)</td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardText">
               Connectez le capteur au connecteur PISTON (JP2) sur la carte d'interface principale:
               <ul>
                  <li>Pot wiper sur broche 1
                  <li>Une extrémité à résistance fixe sur broche 5
                  <li>Autre extrémité à résistance fixe sur borche 6
               </ul>
            </div>
            <div class="aioBoardText">
               Connectez le capteur aux connexions PISTON sur le Pinscape AIO:
               <ul>
                  <li>Pot wiper to Wiper
                  <li>Une extrémité à résistance fixe sur  3.3V
                  <li>Autre extrémité à résistance fixe sur GND
               </ul>
            </div>
            <div class="expBoardText">
               Remarque: ce paramètre de type de capteur peut être utilisé avec d'autres capteurs
               qui représente la position du piston en tant que niveau de tension analogique,
               comme un LVDT ou un télémètre infrarouge analogique. Connectez le capteur de
               la broche de sortie analogique à la broche JP2 1. Connectez l'alimentation du capteur à la broche 5 et
               GND à la broche 6.
            </div>
            <div class="aioBoardText">
               Remarque: ce paramètre de type de capteur peut être utilisé avec d'autres capteurs
               qui représente la position du piston en tant que niveau de tension analogique,
               comme un LVDT ou un télémètre infrarouge analogique. Connectez le capteur de
               broche de sortie analogique à essuie-glace. Connectez l'alimentation du capteur à 3,3 V et
               masse du capteur à GND.
            </div>
         </div>
         <div id="plungerPinsQuad">
            <div>
               <img src="aedr8300.png" style="float: right; margin: 0px 0px 1em 2em;">
               <b>Capteur de quadrature.</b>  Cela utilise un capteur optique qui suit sa
               position le long d'un rail de guidage réfléchissant spécial, avec des barres marquées à
               intervalles réguliers. Le capteur garde une trace de sa position en comptant
               les barres qu'il passe en se déplaçant.
            </div>
            <div class="expBoardPin">
               <b>Affectations des broches:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">Canal A:</td>
                        <td>
                           <span class="pinselect" id="quadrature_CHA"
                              data-cfg="plungerPins.a" data-gpiotype="interrupt-in extern"
                             data-desc="Quadrature Sensor Channel A" data-default="PTD0">
                           </span>
                        </td>
                        <td>Nécessite une broche capable d'interrompre</td>
                     </tr>
                     <tr>
                        <td class="pinlabel">Canal B:</td>
                        <td>
                           <span class="pinselect" id="quadrature_CHB"
                             data-cfg="plungerPins.b" data-gpiotype="interrupt-in extern"
                             data-desc="Quadrature Sensor Channel B" data-default="PTD5">
                           </span>
                        </td>
                        <td>Nécessite une broche capable d'interrompre</td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardText">
               Connectez le capteur au connecteur PLUNGER (JP2) sur la carte d'interface principale:
               <ul>
                  <li>Canal A (CHA) sur broche 3
                  <li>Canal B (CHB) sur broche 4
                  <li>Capteur 3.3V sur broche 5 (si nécessaire)
                  <li>Capteur GND sur borche 6
                  <li>Capteur 5V sur broche 7 (si nécessaire)
               </ul>
            </div>
            <div class="aioBoardText">
               Connectez le capteur aux connexions PISTON du Pinscape AIO:
               <ul>
                  <li>Canal A (CHA) sur CHA
                  <li>Canal B (CHB) sur CHB
                  <li>Capteur 3.3V sur 3.3V (si nécessaire)
                  <li>Capteur GND sur GND
                  <li>Capteur 5V sur 5V (si nécessaire)
               </ul>
            </div>
         </div>

         <div id="plungerPinsVL6180X">
            <div>
               <img src="VL6180X.png" style="float: right; margin: 0px 0px 1em 2em;">
               <b>Capteur de distance VL6180X. </b> Ce capteur détermine la distance
               à un objet proche en faisant rebondir des impulsions de lumière sur l'objet et
               mesurer le temps de retour de la lumière, en utilisant une horloge.
            </div>
            <div class="expBoardPin">
               <b>Affectations des broches:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">SDA:</td>
                        <td>
                           <span class="pinselect" id="VL6180X_SDA"
                              data-cfg="plungerPins.a" data-gpiotype="dig-out extern"
                             data-desc="VL6180X SDA" data-default="PTE20">
                           </span>
                        </td>
                     </tr>
                     <tr>
                        <td class="pinlabel">SCL:</td>
                        <td>
                           <span class="pinselect" id="VL6180X_SCL"
                             data-cfg="plungerPins.b" data-gpiotype="dig-out extern"
                             data-desc="VL6180X SCL" data-default="PTE21">
                           </span>
                        </td>
                     </tr>
                     <tr>
                        <td class="pinlabel">GPIO0/CE:</td>
                        <td>
                           <span class="pinselect" id="VL6180X_GPIO0CE"
                             data-cfg="plungerPins.c" data-gpiotype="dig-out extern"
                             data-desc="VL6180X GPIO0/CE" data-default="PTB0">
                           </span>
                        </td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardText">
               Connectez le capteur au connecteur PISTON (JP2) sur la carte d'interface principale:
               <ul>
                  <li>SDA sur broche 8
                  <li>SCL sur broche 3
                  <li>GPIO0/CE sur broche 1
                  <li>Capteur VIN sur broche 5
                  <li>Capteur GND sur broche 6
               </ul>
            </div>
            <div class="aioBoardText">
               Connectez le capteur aux connexions PISTON du Pinscape AIO:
               <ul>
                  <li>SDA sur SDA
                  <li>SCL sur SCL
                  <li>GPIO0/CE sur INT
                  <li>Capteur VIN sur 3.3V
                  <li>Capteur GND sur GND
               </ul>
            </div>
         </div>

         <div id="plungerPinsAEAT">
            <div>
               <img style="float: right; margin: 0px 0px 1em 2em;" src="AEAT6012.png">
               <b>Encodeur rotatif AEAT-6012-A06. </b> Il s'agit d'un capteur magnétique qui
               détecte l'orientation de rotation d'un aimant. Cela peut être utilisé pour
               détecter la position du pliston avec une liaison mécanique qui fait que
               l'essieu tourne lorsque le piston se déplace.
               <p>
                  <b>Important! </b> Ce capteur utilise une logique 5V, ce qui est incompatible
                  avec le KL25Z. Ne le connectez jamais directement à la KL25Z. 
                  une carte de décalage de niveau de tension bidirectionnelle est requise. Voir le
                  <a target="_blank" href="http://mjrnet.org/pinscape/BuildGuideV2/BuildGuide.php?sid=AEAT6012">
                  Guide de construction de Pinscape </a> pour obtenir des instructions.
               </p>
            </div>
            <div class="expBoardPin">
               <b>Affectations des broches:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">CS (sélection de puce):</td>
                        <td>
                           <span class="pinselect" id="AEAT6012_CS"
                              data-cfg="plungerPins.a" data-gpiotype="dig-out extern"
                             data-desc="Plunger Sensor CS" data-default="PTE21">
                           </span>
                        </td>
                        <td></td>
                     </tr>
                     <tr>
                        <td class="pinlabel">CLK (horloge de données):</td>
                        <td>
                           <span class="pinselect" id="AEAT6012_CLK"
                              data-cfg="plungerPins.b" data-gpiotype="dig-out extern"
                             data-desc="Plunger Sensor CLK" data-default="PTE22">
                           </span>
                        </td>
                        <td></td>
                     </tr>
                     <tr>
                        <td class="pinlabel">DO (sortie de données):</td>
                        <td>
                           <span class="pinselect" id="AEAT6012_DO"
                              data-cfg="plungerPins.c" data-gpiotype="dig-in extern"
                             data-desc="Plunger Sensor DO" data-default="PTE20">
                           </span>
                        </td>
                        <td></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardText">
               Connectez le capteur à une carte de changement de niveau bidirectionnelle et connectez
               le sélecteur de niveau au connecteur PISTON (JP2) sur la carte d'interface principale.
               <ul>
                  <li>Capteur VDD (broche 1) à Pinscape JP2 broche 7 (+ 5V)
                  <li>Capteur CSn (broche 2) vers le sélecteur de niveau HV1 - LV1 vers Pinscape JP2 broche 3 (PTE21)
                  <li>Capteur Vss (broche 3) vers le sélecteur de niveau HV GND
                  <li>Capteur CLK (broche 4) vers le sélecteur de niveau HV2 - LV2 vers Pinscape JP2 broche 4 (PTE22)
                  <li>Capteur DO (broche 5) vers le sélecteur de niveau HV3 - LV3 vers Pinscape JP2 broche 8 (PTE20)
                  <li>Décalage de niveau LV GND (masse) vers Pinscape JP2 broche 6 (GND)
                  <li>Shifter de niveau LV (alimentation logique) à Pinscape JP2 pin 5 (VCC)
                  <li>Décaleur de niveau HV (alimentation de l'appareil) vers Pinscape JP2 broche 7 (+ 5V)
               </ul>
            </div>
            <div class="aioBoardText">
               Connectez le capteur à une carte de changement de niveau bidirectionnelle et connectez
               le sélecteur de niveau aux connexions PISTON du Pinscape AIO.
               <ul>
                  <li>Capteur VDD (broche 1) à 5V
                  <li>Capteur CSn (broche 2) vers le sélecteur de niveau HV1 - LV1 vers CHA / SCL (PTE21)
                  <li>Capteur Vss (broche 3) vers le sélecteur de niveau HV vers GND
                  <li>Capteur CLK (broche 4) vers le sélecteur de niveau HV2 - LV2 vers CHB PTE22)
                  <li>Capteur DO (broche 5) vers le sélecteur de niveau HV3 - LV3 vers SDA (PTE20)
                  <li>Décalage de niveau LV GND (sol) vers GND
                  <li>Décalage de niveau LV (alimentation logique) à 3,3 V
                  <li>Manette de niveau HV (alimentation de l'appareil) à 5V
               </ul>
            </div>
         </div>

         <div id="plungerPinsTCD1103">
            <div>
               <img style="float: right; margin: 0px 0px 1em 2em;" src="TCD1103.png">
               <b>Capteur d'image linéaire TCD1103GFG. </b> Il s'agit d'un petit capteur d'image avec
               une seule ligne de 1500 pixels et une fenêtre d'image de 8 mm. Ce capteur détecte le
               position du piston en prenant une image optique le long de la longueur du piston,
               et l'analyser pour déterminer où se trouve le piston dans l'image.
               <p>
                  Ce capteur nécessite une configuration supplémentaire en plus de la puce du capteur. Il faut
                  une lentille optique pour focaliser l'image sur le capteur, et cela nécessite également
                  certains circuits d'interface spécifiques entre la puce du capteur et le KL25Z.
                  Voir le <a target="_blank" href="http://mjrnet.org/pinscape/BuildGuideV2/BuildGuide.php?sid=TCD1103">TCD1103</a>
                  Chapitre dans <a target="_blank" href="http://mjrnet.org/pinscape/BuildGuideV2/BuildGuide.php">Guide de construction Pinscape </a>
                  pour les instructions.
               </p>
            </div>
            <div class="expBoardPin">
               <b>Affectations des broches:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">fM (Horloge principale):</td>
                        <td>
                           <span class="pinselect" id="TCD1103_FM"
                              data-cfg="plungerPins.a" data-gpiotype="pwm tpm extern"
                             data-desc="Plunger Sensor fM" data-default="PTE21">
                           </span>
                        </td>
                        <td>Nécessite une broche compatible PWM</td>
                     </tr>
                     <tr>
                        <td class="pinlabel">OS (signal de sortie):</td>
                        <td>
                           <span class="pinselect" id="TCD1103_OS"
                              data-cfg="plungerPins.b" data-gpiotype="adc extern"
                             data-desc="Plunger Sensor OS" data-default="PTB0">
                           </span>
                        </td>
                        <td>Nécessite une broche ADC (entrée analogique)</td>
                     </tr>
                     <tr>
                        <td class="pinlabel">ICG (portail clair d'intégration):</td>
                        <td>
                           <span class="pinselect" id="TCD1103_ICG"
                              data-cfg="plungerPins.c" data-gpiotype="dig-out extern"
                             data-desc="Plunger Sensor ICG" data-default="PTE20">
                           </span>
                        </td>
                        <td></td>
                     </tr>
                     <tr>
                        <td class="pinlabel">SH (porte de décalage):</td>
                        <td>
                           <span class="pinselect" id="TCD1103_SH"
                              data-cfg="plungerPins.d" data-gpiotype="dig-out extern"
                             data-desc="Plunger Sensor ICG" data-default="PTE22">
                           </span>
                        </td>
                        <td></td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardText">
               Ce capteur nécessite un circuit imprimé spécial. Utilisez un ruban
               câble pour connecter le circuit imprimé du capteur au connecteur PLUNGER (JP2)
               sur la carte d'interface principale.
            </div>
            <div class = "aioBoardText">
               Ce capteur nécessite un circuit imprimé spécial. Utilisez un ruban
               câble pour connecter le circuit imprimé du capteur aux connexions PISTON
                sur le Pinscape AIO ou Pinscape Lite.
            </div>
         </div>

      </div>

      <div id="plungerAutoZero">
         <b>Mise à zéro automatique du piston: </b> Si cette option est activée, le firmware
         remet la position du piston à zéro après qu'il n'a pas bougé pendant le temps minimum sélectionné.
         <a href="#" class="shower">Détails</a>
         <div class="hider">
            Les capteurs en quadrature utilisent un positionnement purement relatif, ils ont donc besoin d'un
            point de départ. Nous utilisons la "position de stationnement" du piston (où il reste lorsque
	    vous ne le déplacez pas manuellement) comme point zéro naturel. Si le capteur manque jamais un
	    mouvement du piston, ou si le piston n'est pas au repos quand le système est sous tension, le
	    compteur de position relative peut se désynchroniser avec la réalité, rendant le piston à l'écran
	    un peu éloigné de la position réelle. Le micrologiciel peut corriger cela en mettant automatiquement
	    à zéro l'écran position (en le réglant exactement sur la position de stationnement) chaque fois que
	    le piston reste au repos pendant une durée minimale. Il est généralement prudent de supposer que le
	    piston est en position de stationnement alors qu'il n'a pas bougé depuis longtemps, maintenez-le
	    encore n'importe où ailleurs pendant de longues périodes. Il vous suffit d'activez cette option si le
	    piston ne reste pas toujours parfaitement synchronisé par lui-même.
            Choisissez une période suffisamment longue afin detenir jamais le piston loin de la position zero
	    pendant aussi longtemps en jeu normal.
         </div>
         
         <div>
            <label><input type="checkbox" id="plungerAutoZeroEnabled"> Activer la mise à zéro automatique</label>
            <div style="margin: 1ex 0px 1em 2em;">
               Auto-zéro après <input type="text" size="4" id="plungerAutoZeroTime"> secondes
            </div>
         </div>
      </div>

   </div>

   <script>
var prvPlungerType = -1;
var plungerTypeValid = false;
$("#plungerType").change(function(ev)
{
    // deactivate all pin groups until we know which ones we're activating
    $("#plungerPinsTSL .pinselect, #plungerPinsPot .pinselect,"
      + "#plungerPinsQuad .pinselect, #plungerPinsVL6180X .pinselect,"
      + "#plungerPinsAEAT .pinselect, #plungerPinsTCD1103 .pinselect").data(
        {"active": false, "save": false});

    // show or hide the ZB Launch Ball and calibration button sections
    var newvis = ($(this).val() != 0);
    slideToggle($("#zbGroup, #calBtnGroup"), newvis, 250, false);
    slideToggle($("#zbHidden, #calBtnHidden"), !newvis, 250, false);

    // hide the auto-zero section - it only applies to certain sensor types
    $("#plungerAutoZero").hide();

    // show or hide the sensor viewer button
    $("#plungerSensorButton").css("display", newvis ? "" : "none");

    // presume we have a valid plunger type
    plungerTypeValid = true;

    // show the appropriate section
    var all = $("#plungerPinsTSL, #plungerPinsPot, #plungerPinsQuad, #plungerPinsVL6180X, #plungerPinsAEAT, #plungerPinsTCD1103");
    var typ = +$(this).val();
    switch (typ)
    {
    case 0:
    default:
        // no sensor - hide all
        slideClosed(all, 250);
        plungerTypeValid = false;
        break;
    
    case 1:
    case 3:
    case 8:
        // TSL1410R, TSL1412S, and TSL1401CL linear image sensors
        $("#TSLName").text({1: "TSL1410R", 3: "TSL1412S", 8: "TSL1401CL"}[typ] || "TSLxx");
        $("#tsl1410-1412-details, #tsl1401-details").hide();
        $(typ == 8 ? "#tsl1401-details" : "#tsl1410-1412-details").show();
        slideRadio($("#plungerPinsTSL"), all, 250, false);
        $("#plungerPinsTSL .pinselect").data("active", true).data("save", true);
        break;

    case 5:
        // Potentiometer
        slideRadio($("#plungerPinsPot"), all, 250, false);
        $("#plungerPinsPot .pinselect").data("active", true).data("save", true);
        break;

    case 6:
        // Quadrature sensor - AEDR-8300
        slideRadio($("#plungerPinsQuad"), all, 250, false);
        $("#plungerPinsQuad .pinselect").data("active", true).data("save", true);
        $("#plungerAutoZero").show();
        break;

    case 9:
        // VL6180X time-of-flight distance sensor
        slideRadio($("#plungerPinsVL6180X"), all, 250, false);
        $("#plungerPinsVL6180X .pinselect").data("active", true).data("save", true);
        break;

    case 10:
        // AEAT-6012-A06 rotary absolute encoder
        slideRadio($("#plungerPinsAEAT"), all, 250, false);
        $("#plungerPinsAEAT .pinselect").data("active", true).data("save", true);
        break;

    case 11:
        // TCD1103GFG linear image sensor
        slideRadio($("#plungerPinsTCD1103"), all, 250, false);
        $("#plungerPinsTCD1103 .pinselect").data("active", true).data("save", true);
        break;
    }

    // if this was a UI event, reset the factory defaults for the pin configuration
    if (!!ev.originalEvent)
        setPlungerPinFactoryDefaults(prvPlungerType);

    // update the calibration button pin active/inactive status
    updateCalButtonStatus();

    // update pin warning indicators for any active status change
    updatePinWarnings();

    // remember the new type
    prvPlungerType = typ;
});

// set the factory defaults for the plunger pins
function setPlungerPinFactoryDefaults(prvPlungerType)
{
    switch (+$("#plungerType").val())
    {
    case 1:
    case 3:
    case 8:
        // TSL1410R / TSL1412R.  Reset pins only if we're not switching between
        // these two subtypes.  The 1410R and 1412R use identical pin wiring, so
        // switching from one type to the other doesn't require any pin changes.
        if (prvPlungerType != 1 && prvPlungerType != 3) {
            $("#tsl_si .pinval").val("PTE20");
            $("#tsl_clk .pinval").val("PTE21");
            $("#tsl_ao .pinval").val("PTB0");
        }
        break;

    case 5:
        // Potentiometer
        $("#pot_ao .pinval").val("PTB0");
        break;

    case 6:
        // AEDR-8300 quadrature sensor
        $("#quadrature_CHA .pinval").val("PTD0");
        $("#quadrature_CHB .pinval").val("PTD5");
        break;

    case 9:
        // VL6180X time-of-flight sensor
        $("#VL6180X_SDA .pinval").val("PTE20");
        $("#VL6180X_SCL .pinval").val("PTE21");
        $("#VL6180X_GPIO0CE .pinval").val("PTB0");
        break;

    case 10:
        // AEAT-6012-A06 rotary absolute encoder
        $("#AEAT6012_CS .pinval").val("PTE21");
        $("#AEAT6012_CLK .pinval").val("PTE22");
        $("#AEAT6012_DO .pinval").val("PTE20");
        break;

    case 11:
        // TCD1103GFG linear image sensor
        $("#TCD1103_FM .pinval").val("PTE20");
        $("#TCD1103_OS .pinval").val("PTB0");
        $("#TCD1103_ICG .pinval").val("PTE21");
        $("#TCD1103_SH .pinval").val("PTE22");
        break;
    }
}

$("#btnPlungerCal").click(function(ev) {
    // don't actually open the link
    ev.preventDefault();
    
    // check for pin changes
    function pinChanges()
    {
        switch (+$("#plungerType").val())
        {
        case 1:
        case 3:
        case 8:
            return $("#tsl_si .pinval").val() != config.plungerPins.a
                || $("#tsl_clk .pinval").val() != config.plungerPins.b
                || $("#tsl_ao .pinval").val() != config.plungerPins.c;

        case 5:
            return $("#pot_ao .pinval").val() != config.plungerPins.a;

        case 6:
            return $("#quadrature_CHA .pinval").val() != config.plungerPins.a
                || $("#quadrature_CHB .pinval").val() != config.plungerPins.b;

        case 9:
            return $("#VL6180X_SDA .pinval").val() != config.plungerPins.a
                || $("#VL6180X_SCL .pinval").val() != config.plungerPins.b
                || $("#VL6180X_GPIO0CE .pinval").val() != config.plungerPins.c;

        default:
            return false;
        }
    }
    
    // make sure the config values haven't changed
    if ($("#plungerType").val() != config.plungerType || pinChanges())
    {
        if (!window.external.YesNoDialog(
            "Vous avez apporté des modifications à la configuration du capteur que vous n'avez pas "
            + "déjà programmé dans le KL25Z. Le visionneur en direct reflétera"
            + "les paramètres actuels de l'appareil, pas vos nouvelles modifications non enregistrées."
            + "Si vous souhaitez afficher le capteur en utilisant les nouveaux paramètres, cliquez sur"
            + "\ Programmer KL25Z \ avant de passer à la visionneuse de capteurs."
            + "\ r \ n \ r \ n"
            + "Voulez-vous quand même ouvrir la visionneuse de capteurs?"))
            return;
    }
        
    // show the sensor dialog
    window.external.ShowPlungerWindow(CPUID);
});
   </script>

   <!-- Plunger calibration button ----------------------------------------->
   <hr>
   <div class="section" data-name="Calibration Button">
      <img src="calbtn.png" class="sectionIcon">
      <b>Bouton d'étalonnage du piston. </b> Si vous le souhaitez, vous pouvez installer un
      bouton poussoir dans votre pincab pour activer le mode d'étalonnage du piston.
      Ceci est facultatif, car vous pouvez également exécuter l'étalonnage à partir de ce
      programme d'installation. Consultez le Guide de construction pour les instructions de câblage.

      <div id="calBtnGroup">
         <table class="inputs">
            <tr>
               <td class="pinlabel">Entrée de bouton:</td>
               <td>
                  <span class="pinselect expBoardPin" id="calBtn"
                    data-cfg="calButtonPins.button" data-gpiotype="dig-in extern"
                    data-desc="Plunger Calibration Button" data-default="PTE29">
                  </span>
                  <label><input type="checkbox" id="calBtnEna">Activer/label>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">Témoin lumineux de sortie:</td>
               <td>
                  <span class="pinselect expBoardPin" id="calLED"
                    data-cfg="calButtonPins.led" data-gpiotype="dig-out extern"
                    data-desc="Plunger Calibration Lamp" data-default="PTE23">
                  </span>
                  <label><input type="checkbox" id="calLEDEna">Activer</label>
               </td>
            </tr>
         </table>
      </div>
      <div id="calBtnHidden" style="height: 0px; overflow: hidden;">
         (Le bouton d'étalonnage n'est applicable que si vous avez un piston
         capteur installé.)
      </div>
      <div class = "expBoardText">
         Connectez le bouton d'étalonnage au connecteur CAL BTN
         (JP3) sur la carte d'interface principale.
      </div>
      <div class = "aioBoardText">
         Connectez le bouton d'étalonnage aux connexions d'étalonnage
         sur le Pinscape AIO ou Pinscape Lite.
      </div>
   </div>

   <script>

$("#calBtnEna, #calLEDEna").change(function(ev) {
    updateCalButtonStatus();
    updatePinWarnings();
});
function updateCalButtonStatus()
{
    // the calibration buttons pins are active if there's a valid plunger
    // type and the corresponding feature is enabled
    $("#calBtn").data("active", plungerTypeValid && $("#calBtnEna").prop("checked"));
    $("#calLED").data("active", plungerTypeValid && $("#calLEDEna").prop("checked"));
}


   </script>


   <!-- ZB Launch Ball ----------------------------------------------------->
   <hr>
   <div class="section" data-name="ZB Launch Ball">
      <a name="zblaunch"></a>
      <img src="ZBLaunch.png" class="sectionIcon">
      <b>Configuration de la balle de lancement ZB. </b> Vous pouvez configurer votre piston mécanique
      pour agir comme un bouton de lancement "virtuel" pour les tables qui utilisent un bouton
      au lieu d'un piston.
      <a href="#" class="shower">Détails</a>

      <div class="hider">
         Cette fonctionnalité vous permet d'utiliser un piston mécanique au lieu d'un bouton de lancement de balle,
         pour les tables qui en ont besoin, au cas où vous ne voudriez pas installer un autre Bouton physique 
	 de lancement. Lorsque cette option est activée, vous traitez le bouton du piston comme un bouton:
         poussez-le un peu en avant pour "cliquer" sur le bouton. Vous pouvez également vous retirer et
         relâchez le piston pour simuler une brève pression sur un bouton.

         <ul>
            <li>La fonction n'est activée que lorsqu'une table sans piston est en cours d'exécution
            sur le PC. Nous pouvons le dire car Visual Pinball active le <b> port de sortie </b>
            sélectionné ci-dessous lorsqu'un tel tableau est chargé.

            <li>Le port que vous désignez peut être de n'importe quel type, y compris un port «virtuel» qui
            n'est connecté à aucun câblage de sortie physique.

            <li><b>Dans la <a class="dofconfigtool">Configuration utilitaire DOF</a></b>, assurez-vous de
            définir le numéro de port que vous désignez ici comme port <b> ZB Launch Ball </b>.
            Cela connecte tout sur le PC au bon port.

            <li>Sélectionnez la touche du clavier ou le bouton du joystick à envoyer au PC lorsque
            le piston déclenche un lancement. Il s'agit généralement de la touche Entrée, car
            c'est ce qu'utilise presque tous les logiciels de flipper sur PC.

            <li>La <b> distance de poussée </b> règle la sensibilité. Lorsque vous poussez le
            piston vers l'avant de ce montant ou plus (et la fonction a été activée par
            le port de sortie), le contrôleur simule une pression sur le bouton Launch Ball.
            Réglez la distance suffisamment loin pour qu'elle ne se déclenche pas au hasard, mais suffisamment courte
            que vous n'ayez pas à pousser trop fort. Nous recommandons environ 0,06 à 0,08 pouces.
         </ul>
      </div>

      <div id="zbHidden" style="overflow: hidden; height: 0px;">
         (La fonction "ZB Launch Ball" s'applique uniquement lorsque vous avez un
         capteur plongeur installé.)
      </div>

      <div id="zbGroup">
         <div>
            <label><input type="checkbox" id="zbEnabled">Activer</label>
         </div>
         
         <div class="indented" id="zbFields">
            <table class="inputs">
               <tr>
                  <td>Numéro de port de sortie:</td>
                  <td><input id="zbPort" size=5></td>
                  <td><b>Important! </b> Réglez ce port sur "ZB Launch Ball" dans le
                     <a class="dofconfigtool">Configuration utilitaire DOF</td>
               </tr>
               <tr class="buttonRow">
                  <td class="keylabel">Clavier/Boutons:</td>
                  <td>
                     <span class="keymapping" id="keymapZB">
                        <span class="keyname"></span>
                        <span class="keycode"></span>
                        <span class="keytype"></span>
                     </span>
                  </td>
                  <td>La plupart des logiciels de flipper PC utilisent la touche Entrée pour lancer la balle</td>
               </tr>
               <tr>
                  <td>Distance de poussée (pouces):</td>
                  <td><input id="zbDistance" size=5></td>
                  <td>La valeur recommandée est 0,063 (environ 1/16 ")
               </tr>
            </table>
         </div>
      </div>
         
   </div>

   <script>

// show/hide the section on changing the Enable checkbox
$("#zbEnabled").change(function() {
    var ena = $(this).prop("checked");
    slideToggle($("#zbFields"), ena, 250, false);
    if (!ena)
        $("#zbPort").val("0").change();
    else if (+$("#zbPort").val() == 0)
        $("#zbPort").val("1").change();
});

$("#zbPort").change(function(ev) {
    $("#outputTab .zbRemark").remove();
    var row = +$(this).val();
    if ($("#zbEnabled").prop("checked") && row != 0) {
        var oprow = $("#outputTab .outPortRow").eq(row-1);
        if (oprow.find(".pintype").val() == 0 && !loadingConfig) {
            if (window.external.YesNoDialog(
                "Le port que vous avez sélectionné n'est pas actuellement configuré. Ameriez "
                + "vous l'ajouter en tant que port \" virtuel \ ? Il faudra"
                + "s'assurer que le PC pourra l'adresser correctement."))
                appendOutputs(row);
            else
                window.external.ShowAdviceDialog(
                    "InvalidZBPortWarning",
                    "D'accord, aucun port n'a été ajouté. Notez que le PC ne pourra pas "
                    + "activer la fonction ZB Launch sauf si vous l'assignez à un"
                    + "port valide qui existe dans la liste de sortie. Veuillez être sûr"
                    + "pour ajouter le port ou changer le numéro ici avant de finaliser"
                    + "vos paramètres.");
        }
        oprow.find(".outPortRemarks").append(
            "<span class=\"zbRemark\" title=\"Ceci est le port de sortie ZB Launch Ball\">"
            + "<a href=\"#zblaunch\">"
            + "<img src=\"zbLaunchSmall.png\">"
            + "</a>"
            + "</span>");
    }
});

   </script>


   <!-- Button input setup ---------------------------------------------->
   <hr>
   <div class="section" data-name="Buttons">
      <a name="buttonSection"></a>
      <img src="buttonSection.png" class="sectionIcon">
      <b>Entrées de bouton. </b> Vous pouvez utiliser la KL25Z comme encodeur de clavier pour
      connectez les boutons de style flipper de votre pincab au PC. Installer les connexions
      de câblage et les affectations des touches ci-dessous. Chaque entrée peut être mappé
      comme un bouton du joystick ou une touche du clavier. Cliquez sur une entrée
      d'affectation des broches ou des touches pour modifier un paramètre.
      <div>
         <a href="#" id="btnButtonTest" class="button">boutons de tests</a>
      </div>
      
      <div id="shiftButtonSetup">
         <div>
            <span style="padding-right: 2em;">
               <img src="ShiftButton.png" style="vertical-align: middle;">
               <b>Numéro du bouton Shift:</b>
            </span>
            <input type="text" id="shiftButton" size="4">
            <span style="padding-left: 2em;">
               <a href="#" id="helpShiftButton">Aide</a>
            </span>
            <div style="margin: 1ex 0px 2em 2em;">
               <label><input type="radio" name="shiftButtonMode" value="0">
                  Shift OU Mode Clavier</label><br>
               <label><input type="radio" name="shiftButtonMode" value="1">
                  Shift ET Mode Clavier</label>
            </div>
         </div>
      </div>
      
      <div>
         <a href="#" id="setAllJoystick">Définir les boutons du joystick standard</a>
         | <a href="#" id="setAllKB">Définir les touches du clavier standard</a>
         | <a href="#" class="btnHelp">Afficher les attributions de touches standard</a>
      </div>
      
      <div>
         <table id="buttonTab">
         </table>
      </div>
      <div id="buttonTabStretchNote">
         <i><b>Note:</b> la version actuelle de votre micrologiciel prend en charge jusqu'à
            <span id="buttonTabMaxNote">0</span> boutons physiques. 
            La liste ci-dessus s'étendra automatiquement au fur et à mesure que vous remplissez de nouveaux
            articles, jusqu'à la limite. </i>
      </div>
   </div>

   <script>

$("#helpShiftButton").click(function(ev) {
    ev.preventDefault();
    window.external.ShowHelp("HelpShiftButton.htm");
});
// show the button tester
$("#btnButtonTest").click(function(ev)
{
    ev.preventDefault();
    var cfgMem = normalizeConfig(configFromUI());
    var cfgDev = normalizeConfig(config);
    if (!valEq(cfgMem.buttons, cfgDev.buttons)
        || !valEq(cfgMem.xbuttons, cfgDev.xbuttons)
        || !valEq(cfgMem.shiftButton, cfgDev.shiftButton))
    {
        if (!window.external.YesNoDialog(
            "Vous avez apporté des modifications aux paramètres du bouton que vous n'avez pas "
            + "déjà programmé dans la KL25Z. La fenêtre du testeur reflètera "
            + "les paramètres actuels de l'appareil, pas vos nouvelles modifications non enregistrées."
            + "Si vous souhaitez tester vos nouveaux paramètres, cliquez sur \"Programmer KL25Z \" "
            + "avant de passer à la fenêtre du testeur."
            + "\ r \ n \ r \ n"
            + "Voulez-vous quand même ouvrir le testeur?"))
            return;
    }

    // show the dialog
    window.external.ShowButtonTester(CPUID);
});


// Button row updater.  We group updates to avoid updating
// the same row repeatedly when performing a task that affects
// multiple rows (config loading, changing the night mode
// button, changing the shift button).
var ButtonTabUpdate = {
    touch: function(item) {  // item can be a button row element (TR) or any element within a row
        if (!item)
        {
            $("#buttonTab tr.buttonRow").each(function() { ButtonTabUpdate.touch($(this)); });
            return;
        }
        if (!item.is("tr"))
            item = item.parents("tr.buttonRow");
        this.pending[item.find(".keymapping").data("idx")] = item;
        if (!this.queued) {
            var self = this;
            setTimeout(function() { self.go(); }, 1);
            this.queued = true;
        }
    },
    pending: { },
    queued: false,
    go: function() {
        $.each(this.pending, function(key, val) {
            updateButtonRow(val);
        });
        stretchButtonTable();
        this.queued = false;
        this.pending = { };
    }
};

$("#shiftButton").change(function(ev)
{
    var n = $(this).val()
    $("#buttonTab tr").removeClass("shiftRow")
         .find("td.shiftCol span").attr("title", "Cliquez ici pour en faire le bouton de décalage local");
    $("#buttonRow" + n).addClass("shiftRow")
        .find("td.shiftCol span").attr("title", "Cette entrée est le bouton de décalage local. Autre "
                           + "boutons enfoncés alors que le bouton Shift est maintenu enfoncé utilisez "
                           + "leurs codes clés décalés.");

    $("#buttonTab .buttonCol.shifted, #buttonTab th.shifted").toggle(n != 0);

    ButtonTabUpdate.touch();
    showHideNightModeButtonShift();
    updateNightModeButton();
});

$("#setAllJoystick").click(function(ev)
{
    if (window.external.YesNoDialog(
        "Cela remplacera vos attributions de clés actuelles dans "
        + "emplacements 1-24 avec les boutons du joystick 1-24, respectivement."
        + "Voulez-vous vraiment remplacer tous ces paramètres?"))
    {
        $("#buttonTab tr").each(function()
        {
            var tr = $(this);
            var keymapping = tr.find(".primary .keymapping");
            var idx = keymapping.data("idx");
            if (idx >= 1 && idx <= 24)
            {
                keymapping.children(".keytype").val(1).change();
                keymapping.children(".keycode").val(idx).change();
            }
        });
    }
    ev.preventDefault();
    ev.stopPropagation();
});
$("#setAllKB").click(function(ev)
{
    if (window.external.YesNoDialog(
        "Cela remplacera vos attributions de clés actuelles "
        + "avec les mappages de clavier standard pour Visual"
        + "Pinball. Êtes-vous sûr de vouloir continuer?"))
    {
        $("#buttonTab tr").each(function()
        {
            var tr = $(this);
            var keymapping = tr.find(".primary .keymapping");
            var idx = keymapping.data("idx");
            var defs = expansionBoardFactoryConfig.buttons;
            if (defs[idx])
            {
                keymapping.children(".keytype").val(defs[idx].keytype).change();
                keymapping.children(".keycode").val(defs[idx].keycode).change();
            }
        });
    }
    ev.preventDefault();
    ev.stopPropagation();
});

// Map from the modifier key codes to keycaps entries.  The modifier
// keys are encoded with a bit mask, per the usual USB keyboard
// conventions.  Each modifier is represented by one bit in the mask.
// This maps from the individual bits to the corresponding keycaps
// indices.
var shiftKeyMap = {
    0x01: 0xE0,         // left control
    0x02: 0xE1,         // left shift
    0x04: 0xE2,         // left alt
    0x08: 0xE3,         // left GUI
    0x10: 0xE4,         // right control
    0x20: 0xE5,         // right shift
    0x40: 0xE6,         // right alt
    0x80: 0xE7          // right GUI
};

// Standard VP key usage, indexed by "type.keyCodeInHex" (e.g., 2.1E = keyboard "1").
// We rebuild this during initialization to index in decimal (2.30 = "1").  Hex is
// more convenient for typing in the entries, while decimal is more convenient for
// looking them up.  We could probably just as well dispense with the "2." and 
// assume that only keyboard keys have standard VP usages, which is currently the
// case.  But we include the type code anyway for the sake of future-proofing, just
// in case VP ever adopts standard usages for other input methods (e.g., joystick
// buttons).
var vpUsage = {
    "2.1E": "Start Game",
    "2.1F": "Extra Ball (Buy-In)",
    "2.22": "Coin In (main/left slot)",
    "2.21": "Coin In (second coin slot)",
    "2.23": "Coin In (fourth coin slot)",
    "2.28": "Plunger/Launch Ball",
    "2.29": "Exit to menu (PinballX/HyperPin front ends)",
    "2.14": "Quit to editor (within VP)",
    "2.E1": "Left Flipper",
    "2.E5": "Right Flipper",
    "2.E0": "Left MagnaSave",
    "2.E4": "Right MagnaSave",
    "2.17": "Mechanical Tilt Bob",
    "2.4A": "Slam Tilt",
    "2.2C": "Forward Nudge",
    "2.1D": "Left Nudge",
    "2.38": "Right Nudge",
    "2.4D": "Open/Close Coin Door",
    "2.24": "Service Button \"Cancel/Exit\"",
    "2.25": "Service Button \"Down/-\"",
    "2.26": "Service Button \"Up/+\"",
    "2.27": "Service Button \"Enter\"",
    "2.2E": "VP Volume Down",
    "2.2D": "VP Volume Up"
};

function updateButtonRow(tr)
{
    // update the key caps
    var km = tr.find(".keymapping");
    if (km.length)
    {
        // update the displayed key caps
        km.each(function() { updateKeyCap($(this)); });

        // update the displayed usage 
        var usage = [];
        tr.find(".keymapping").each(function() {
            var m = $(this);
            usage.push(vpUsage[m.find(".keytype").val() + "." + (+m.find(".keycode").val())] || "-");
        });
        if ($("#shiftButton").val() == 0) usage.pop();  // remove the shifted key display if the shift button is disabled
        tr.find(".keyusage").text(usage.join("/"));

        // update the displayed flag icons
        var flags = +tr.find("input.keyflags").val();
        tr.find("td.keyflags img").each(function() {
            var img = $(this);
            var f = !!(flags & img.data("mask"));
            img.attr("src", img.attr("src").replace(/On|Off/, f ? "On" : "Off"));
        });
    }
}

function updateKeyCap(km)
{
    km.removeClass("asNone asKey asShiftKey asMediaKey asJoystickButton");
    km.css("background-position", "");
    var typ = +km.children(".keytype").val();
    var code = +km.children(".keycode").val();
    var typemap = { 0: "asNone", 1: "asJoystickButton", 2: "asKey", 3: "asMediaKey" };
    km.addClass(typemap[typ] || "asNone");
    var wid = "auto", ht = "32px", lht = "32px";
    var txt = "", title = "";
    switch (typ)
    {
    case 0:
    default:
        title = "Appuyer sur ce bouton n'enverra aucune pression de touche au PC";
        wid = ht = "32px";
        break;

    case 1:
        txt = code;
        title = "Bouton du joystick " + code;
        wid = ht = "32px";
        lht = "28px";
        break;

    case 2:
    case 3:
        // get the key name
        var k = (typ == 2 ? keycaps[code] : mediaKeycaps[code]);
        title = k.name;

        // show the "alternate" image if defined, otherwise just use the name
        if (k.cx)
        {
            wid = (k.cwid || 30) + "px";
            ht = (k.cht || 31) + "px";
            km.css("background-position", (-k.cx) + "px " + (-k.cy) + "px");
        }
        else if (k.x)
        {
            wid = (k.wid || 30) + "px";
            ht = (k.ht || 31) + "px";
            km.css("background-position", (-k.x) + "px " + (-k.y) + "px");
        }
        else
        {
            txt = k.name;
            km.removeClass("asKey asMediaKey").addClass("asKeyName");
        }
        break;
    }
    km.attr("title", title).css({ width: wid, height: ht, lineHeight: lht }); // set lineHeight for vertical centering of .keyname label
    km.children(".keyname").text(txt);
}

// size the button table to display the number of buttons the firmware
// supports
var buttonTabMax = 0;
function sizeButtonTable(config)
{
    // we only have to do this once per load
    if (buttonTabMax)
        return;

    var count = 0;
    $.each(config.buttons, function(key) { if (/\d+/.test(key)) ++count; });
    $("#shiftButton, #nightModeButtonNo").spinner("option", "max", count);
    $("#buttonTabMaxNote").text(count);
    buttonTabMax = count;
    $("#buttonTab tr.buttonRow").each(function() {
        var tr = $(this);
        var keymapping = tr.find(".keymapping");
        var idx = keymapping.data("idx");
        var active = (idx <= count);
        tr.toggle(active);
        keymapping.data("outOfService", !active);
        tr.find(".pinselect").data("save", active);
    });
}

// Adjust the visibility of button table rows at the bottom.  We hide
// rows after the last completely unused row.
function stretchButtonTable()
{
    var last = 0;
    $("#buttonTab tr.buttonRow").each(function() {
        var tr = $(this);
        var km = tr.find(".keymapping");
        var idx = +km.data("idx");
        if (idx > buttonTabMax) return false;
        if (idx >= last)
        {
            if (tr.find(".pinval").val() != "Not Connected")
                last = idx;
            else if ($("#nightModeButtonNo").val() == idx)
                last = idx;
            else
            {
                km.each(function() {
                    if ($(this).find(".keytype").val() != 0) {
                        last = idx;
                        return false;
                    }
                });
            }
        }
    });

    var sb = +$("#shiftButton").val();
    if (sb > last)
        last = sb;

    // show one blank row if we haven't maxed out the table
    if (last < buttonTabMax) ++last;

    $("#buttonTab tr.buttonRow").each(function() {
        $(this).toggle(+$(this).find(".keymapping").data("idx") <= last);
    });

    $("#buttonTabStretchNote").toggle(last < buttonTabMax);
}

// .keymapping click handler
var keymappingClick;

// build the button table rows
$(function() {

    // reindex the vpUsage table by decimal key code
    var u = vpUsage;
    vpUsage = { };
    $.each(u, function(key, val) {
        if (/(\d+)\.(.+)/.test(key)) {
            vpUsage[RegExp.$1 + "." + parseInt(RegExp.$2, 16)] = val;
        }
    });

    // Set the modifier key mapping for each modifier key in the key caps
    $.each(shiftKeyMap, function(k, v) { keycaps[v].modkey = k; });

    // Build the button table header
    var rows = [];
    rows.push("<tr>"
              + "<th>No.</th>"
              + "<th>Port</th>"
              + "<th class=\"shiftCol\"><img src=\"ShiftButton.png\"></th>"
              + "<th style=\"text-align: left;\">Entrée PC</th>"
              + "<th style=\"text-align: left;\" class=\"shifted\">Décalé</th>"
              + "<th style=\"padding: 0px; white-space: nowrap;\">Options [<a href=\"#\" id=\"pulseKeyHelp\">?</a>]</th>"
              + "<th class=\"keyusage\" title=\"La signification standard de la clé attribuée dans Visual Pinball \">VP Usage</th>"
              + "</tr>");

    // Build a <TR> for each button table row.  Start with more than we
    // need in the firmware - we'll hide extra rows after loading the
    // configuration, at which point we'll know how many rows we really
    // need.  It would be better if we populated the table dynamically
    // upon loading the config, but that would require a bunch of rework
    // thanks to early assumptions that we had a fixed number of rows
    // (versions of the firmware up until 11/2016 had a fixed size of
    // 32 keys in the firmware).  That rework is a bit tricky because
    // initialization is scattered, mostly thanks to to entanglements
    // with the pin selector dialogs.  Right now it's easier to just
    // create "more than enough" rows and hide the ones we don't need.
    // This is never a good strategy in the long run; it's the classic
    // "who'd ever need more than 640K?" all over again.  But I guess
    // I'd be pretty happy to be only as visionary as billg, plus, as
    // long as we're on the KL25Z, we really can't add infinite
    // buttons anyway, since memory is already tight.)
    for (var i = 1 ; i <= MaxButtons ; ++i)
    {
        rows.push("<tr class=\"buttonRow\" id=\"buttonRow" + i + "\" data-idx=\"" + i + "\">"
                  + "<td class=\"pinlabel keylabel\">" + i + "</td>"               // button number                     
                  + "<td>"
                  +   "<span class=\"pinselect withExpBoardAlias\" id=\"button" + i + "\" "    // input pin
                  +      "data-gpiotype=\"dig-in extern\" "
                  +      "data-cfg=\"buttons." + i + ".pin\" "
                  +      "data-desc=\"Button " + i + "\">"
                  +   "</span>"
                  + "</td>"
                  + "<td class=\"shiftCol\">"
                  +    "<span>"
                  +    "</span>"
                  + "</td>"
                  + "<td class=\"buttonCol primary\">"
                  +   "<span class=\"keymappingContainer\">"
                  +     "<span class=\"keymapping\" id=\"keymap" + i + "\" data-idx=\"" + i + "\">" // key mapping
                  +       "<span class=\"keyname\"></span>"
                  +       "<input class=\"keycode\" type=\"hidden\">"
                  +       "<input class=\"keytype\" type=\"hidden\">"
                  +       "<input class=\"keyflags\" type=\"hidden\">"
                  +     "</span>"
                  +   "</span>"
                  +   "<span class=\"keyIR\" title=\"Commande IR à envoyer lorsque vous appuyez sur ce bouton\">"
                  +     "<span class=\"label\"></span>"
                  +     "<input class=\"IRCommand\" type=\"hidden\">"
                  +   "</span>"
                  +   "<span class=\"keyNightMode\" title=\"Faites-en le bouton du mode nuit\"></span>"
                  + "</td>"
                  + "<td class=\"buttonCol shifted\">"
                  +   "<span class=\"keymapping\" id=\"xkeymap" + i + "\" data-xidx=\"" + i + "\">" // shift key mapping
                  +     "<span class=\"keyname\"></span>"
                  +     "<input class=\"keycode\" type=\"hidden\">"
                  +     "<input class=\"keytype\" type=\"hidden\">"
                  +   "</span>"
                  +   "<span class=\"keyIR\" title=\"Commande IR à envoyer lorsque vous appuyez sur ce bouton décalé\">"
                  +     "<span class=\"label\"></span>"
                  +     "<input class=\"IRCommand\" type=\"hidden\">"
                  +   "</span>"
                  +   "<span class=\"keyNightMode\" title=\"Faites-en le bouton du mode nuit\"></span>"
                  + "</td>"
                  + "<td class=\"keyflags\">"
                  +   "<img src=\"PulseOff.png\" id=\"keyPulse" + i + "\" data-mask=\"1\" "   // pulse mode flag
                  +      "title=\"Mode impulsion: le bouton envoie une pression sur une touche lorsqu'il est enfoncé, une seconde lorsqu'il est relâché\">"
                  + "</td>"
                  + "<td class=\"keyusage\" id=\"keyusage" + i + "\" title=\"La signification standard de cette clé dans Visual Pinball\">"
                  + "</td>"
                  + "</tr>");
    }

    // inject the HTML
    $("#buttonTab").html(rows);

    // pulse key help
    $("#pulseKeyHelp").click(function(ev) {
        window.external.ShowHelp("HelpPulseKey.htm");
        ev.preventDefault();
    });

    // set the shift key to a given row
    $("#buttonTab td.shiftCol span").click(function(ev) {
        var idx = $(this).parents("tr.buttonRow").data("idx");
        var oldIdx = $("#shiftButton").val();
            $("#shiftButton").val(oldIdx == idx ? 0 : idx).change();
    });
    
    // on changing the pin selection, update the expansion board alias, if applicable
    $("#buttonTab .pinselect").change(function()
    {
        var port = $(this).children(".pinval").val();
        var alias = (gpioPortAlias[port] || "").split("|");
        $(this).find("input.expBoardAlt").val("$1 ($2)".formatOrUndef(alias[0], alias[1]) || port);
        ButtonTabUpdate.touch($(this));
    });

    // pulse mode
    $("#buttonTab td.keyflags img").click(function(ev)
    {
        var keyflags = $(this).parents("tr.buttonRow").find("input.keyflags");
        keyflags.val(keyflags.val() ^ $(this).data("mask")).change();
    });

    // on changing any of the key sub-fields, update the displayed value
    $(".keymapping .keycode, .keymapping .keytype, .keymapping input.keyflags").change(function(ev) {
        ButtonTabUpdate.touch($(this));
    });

    // get the key selector dialog element so we can set it up
    var dlg = $("#keySelector");

    // build the clickable buttons on the key cap image for the dialog, and a
    // table mapping javascript key codes to keycaps and mediaKeyCaps entries
    var btns = [];
    var jsKeyCaps = { };
    var makeKey = function(k, v, typ) {
        // if this key has a clickable image, add it
        if (v.x)
        {
            var usage = vpUsage[typ + "." + (+k)];
            usage = usage ? "\nTypical VP use: " + usage : "";
            btns.push("<span id=\"keycapBtn" + typ + "_" + k + "\" "
                      + "data-keytype=\"" + typ + "\" "
                      + "class=\"keycapBtn\" data-scancode=\"" + k + "\" "
                      + "title=\"" + (v.name + usage).replace(/"/, "&#34;") + "\" "
                      + "style=\""
                      +   "left: " + (v.x+4) + "px;"
                      +   "top: " + (v.y+4) + "px;"
                      +   "width: " + (v.wid || 30) + "px;"
                      +   "height: " + (v.ht || 31) + "px;"
                      + "\"></span>");
        }

        // if it has a javascript key code, add it to the js key map
        if (v.jskey)
            (jsKeyCaps[v.jskey] = jsKeyCaps[v.jskey] || []).push({keytype: typ, keycode: k, jsloc: v.jsloc});
    };
    $.each(keycaps, function(k, v) { makeKey(k, v, 2); });
    $.each(mediaKeycaps, function(k, v) { makeKey(k, v, 3); });
    $("#oskeyboard").html(btns.join(""));

    // build the clickable buttons for the joystick button selector dialog page
    btns = [];
    for (var i = 1, row = [] ; i <= 32 ; ++i)
    {
        row.push("<span id=\"jsBtn" + i + "\" "
                 +   "class=\"jsBtn\" "
                 +   "data-button=\"" + i + "\">"
                 +  i
                 + "</span>");
        if (row.length == 8)
        {
            btns.push("<div class=\"jsBtnRow\">" + row.join("") + "</div>");
            row = [];
        }
    }
    $("#osjoystick .jsBtnBox").html(btns.join(""));

    // set up the page selection buttons
    $("#keytype").children().click(function() {
        var page;
        $("#keytype > img").removeClass("selected");
        $("#osunused, #oskeyboard, #osjoystick, #osspecial").css("display", "none");
        (page = $($(this).data("page"))).css("display", "");
        $("#keySelector > div").css("width", page.outerWidth() + "px");
        $(this).addClass("selected");
    });

    // row that opened the dialog, and its label item
    var dlgkey, dlgkeylbl;

    // handle events on the on-screen keyboard buttons
    $(".keycapBtn").click(function(ev) {
        // click a key - select the key (keyboard is type 2) and close the dialog
        selectButton($(this).data("keytype"), +$(this).data("scancode"), true);
        ev.preventDefault();
    }).hover(redisp, redisp);

    function redisp() {
        // Hack to work around a WebBrowser (IE) bug.  This workaround is a pretty
        // egregious hack, but the bug is annoying.  The bug comes from using CSS
        // :hover to alter a transparent overlay (the button div).  This causes a
        // weird little shift in the background rendering below the div.  It makes
        // it look blurry.  The root of the bug seems to be a rounding error when IE
        // calculates the repainting region; the rounding error comes from the
        // "margin: auto" centering, which presumably comes up with a fractional
        // pixel position that gets rounded one way when the background is rendered
        // and the other way when the overlay is rendered.  The fix here forces a
        // redraw of the underlying background by changing its width.  That full
        // background refresh has the effect of painting over our bug-damaged region,
        // and IE's double buffering of the graphics rendering ensures that the
        // correction happens before the damaged pixels ever hit the screen, so the
        // damage is never visible.  To force the redraw, we simply add a pixel to
        // the underlying div width, then set a timeout to take the pixel back out
        // a millisecond later.  We have to break the two steps across a timeout so
        // that IE can't combine the two changes into one event cycle, which would
        // skip the resize and thus skip the refresh.  Neither width change has any
        // visible effect on the actual layout, so even if the timeout happens to
        // cross a physical video refresh cycle boundary, there's no change in
        // what's displayed and therefore the redraw is invisible.  This whole
        // process is horribly inefficient, but it's the only thing I've found
        // that fixes the glitch.  It's obviously tied to the peculiarities of 
        // the IE rendering engine, but I don't think it'll do any harm if this
        // particular bug is fixed in a future version, apart from the little bit
        // of added overhead.
        $("#oskeyboard").css("width", ($("#oskeyboard").outerWidth() + 1) + "px");
        setTimeout(function() {
            $("#oskeyboard").css("width", ($("#oskeyboard").outerWidth() - 1) + "px");
        }, 1);
    }

    // click a joystick button
    $(".jsBtn").click(function(ev) {
        // select the joystick button (joystick = type 1)
        selectButton("1", $(this).data("button"), true);
        ev.preventDefault();
    });

    // click the "unused" button
    $("#unusedBtn").click(function(ev) {
        // make the button unused (type 0)
        selectButton("0", 0, false);
        ev.preventDefault();

        // done with the key dialog
        dismissKeyDlg();
    });

    // Turn night mode on, off, or toggle for the given button.
    //
    // button = the keyNightMode button
    //
    // newState = "on"     - set this as the night mode button unconditionally
    //            "off"    - turn off night mode if it's set to this button
    //            "toggle" - set this as the night mode button if it's not already;
    //                       turn night mode off if it's currently the night mode button
    function nightModeClick(button, newState)
    {
        // get the button we're clicking on, and note if it's a shifted button
        var km = button.parents("td").find(".keymapping");
        var idx = km.data("idx"), xidx = km.data("xidx");
        var btn = idx || xidx;
        var shift = !!xidx;

        // get the current night mode button setting
        var fld = $("#nightModeButtonNo");
        var ck = $("#nightModeButtonShift input");

        // note if this button is currently the night mode button
        var oldState = (fld.val() == btn && ck.prop("checked") == shift);

        // figure the new state
        if (newState == "off")
        {
            // turn off night mode only if this is the night mode button currently
            if (!oldState)
                newState = "nop";
        }
        else if (newState == "toggle")
        {
            // reverse the current state
            newState = oldState ? "off" : "on";
        }

        // don't allow a shifted night mode button if in switch mode
        var toggleMode = ($("#nightModeOptions input:radio[name=nightModeButtonType]:checked").val() == 1);
        if (newState == "on" && shift && !toggleMode)
        {
            alert("Le mode nuit ne peut pas être attribué à un bouton décalé lorsque "
                  + "le mode interrupteur marche / arrêt est utilisé.");
            return;
        }

        // Apply the new state.  Note that 'newState' could be "nop",
        // meaning that we're not making any changes.
        if (newState == "off") {
            ck.prop("checked", false);
            fld.val(0).change();
            $(this).removeClass("selected");
        }
        else if (newState == "on") {
            ck.prop("checked", shift);
            fld.val(btn).change();
            $(this).addClass("selected");
        }
    }
    
    // night mode button
    $(".keyNightMode").click(function(ev) {
        nightModeClick($(this), "toggle");
        ev.preventDefault();
    });

    // on clicking any key mapping, display the key selector popup
    keymappingClick = function(ev) {

        // remember who opened the dialog
        dlgkey = $(this);

        // mark the label as active
        dlgkeylbl = dlgkey.parents("tr.buttonRow");
        dlgkeylbl.addClass("openDlgRow");

        // we'll fully handle the event here - skip any default action
        ev.preventDefault();

        // reset the dialog
        $(".keycapBtn, .jsBtn, #unusedBtn, #nightModeBtn").removeClass("hover selected");
        $("#keytype > img").removeClass("selected");

        // show the dialog
        dlg.parent().css("display", "block");

        // position it below the field
        var ofs = dlgkeylbl.offset();
        var dlght = dlg.outerHeight() + 24;
        var winht = window.innerHeight - $("#nav").outerHeight();
        var scrolly = $("html,body").scrollTop();
        var y = ofs.top + dlgkeylbl.height();
        dlg.css("top", y + "px");

        // make sure the bottom of the dialog is in view
        if (y + dlght > scrolly + winht)
            scrolly = y + dlght - winht;

        // but limit this so that the top stays in view
        if (scrolly > y)
            scrolly = y;

        // scroll here
        $("html,body").animate({ scrollTop: scrolly });

        // presume the key has no special meaning
        var isSpecial = false;

        // show the appropriate panel
        $("#osunused, #oskeyboard, #osjoystick, #osspecial").css("display", "none");
        var typ = +dlgkey.children(".keytype").val();
        var code = +dlgkey.children(".keycode").val();
        var page;
        switch (typ)
        {
        default:
            // No PC input (or an unknown type).  If the key has a special
            // function (e.g., Night Mode), show the "special" page, otherwise
            // show the "unused" page.
            if (isSpecial) {
                page = $("#osspecial").css("display", "");
                $("#keytypeSpecial").addClass("selected");
            }
            else {
                page = $("#osunused").css("display", "");
                $("#keytypeUnused").addClass("selected");
            }

            // in any case, mark the "unused" button as selected - even if we
            // don't start out in this page, it's still the selected input type
            $("#unusedBtn").addClass("selected");
            break;
            
        case 1:  // joystick
            (page = $("#osjoystick")).css("display", "");
            $("#jsBtn" + code).addClass("selected");
            $("#keytypeJS").addClass("selected");
            break;

        case 2: // keyboard
        case 3: // media key
            (page = $("#oskeyboard")).css("display", "");
            $("#keycapBtn" + typ + "_" + code).addClass("selected");
            $("#keytypeKB").addClass("selected");
            break;
        }
        $("#keySelector > div").css("width", page.outerWidth() + "px");
    };
    $(".keymapping").click(keymappingClick);

    // select a joystick button
    function selectButton(type, code, dismiss)
    {
        // set the key type and code
        dlgkey.children(".keytype").val(type);
        dlgkey.children(".keycode").val("" + code).change();

        // dismiss the dialog if desired
        if (dismiss)
            dismissKeyDlg();
    }

    // handle keystrokes while the key dialog is showing
    $("html").on("keydown keyup", function(ev) {
        if (dlgkey && $("#keytypeKB").hasClass("selected"))
        {
            // If the key maps to one of our keycaps entries, select the key.
            // In order to match, the keycap entry has to have the same javascript
            // key code, and must either have no "jsloc" (key location) property,
            // or has a jsloc that matches the event location.  The location 
            // distinguishes among keys where the javascript code is shared by
            // multiple physical keys, such as keys on the numeric keypad and the
            // modifier keys that are mirrored on the left and right sides.
            var k = $.grep(jsKeyCaps[ev.which] || [], function(ele) {
                var eleloc = ele.jsloc;
                return typeof eleloc == "undefined" || eleloc == ev.originalEvent.location;
            });

            // if we found a key, select it
            if (k.length == 1)
            {
                // we found exactly one matching key - select it
                selectButton(k[0].keytype, k[0].keycode, true);
                ev.preventDefault();
                ev.stopPropagation();
            }
        }
        else
        {
            switch (ev.which)
            {
            case 32:
            case 13:
            case 27:
                // close the dialog on escape, space, or enter
                dismissKeyDlg();
                break;
            }
        }
    });

    // close the key dialog
    function dismissKeyDlg()
    {
        dlg.parent().css("display", "none");
        if (dlgkeylbl) dlgkeylbl.removeClass("openDlgRow");
        dlgkey = dlgkeylbl = null;
    }

    // dismiss the dialog on clicking outside it, but not on clicking within
    $("#keySelector > div").click(function() { event.stopPropagation(); });
    dlg.parent().click(function() { dismissKeyDlg(); });

    // on changing an IR command, update the display
    $("#buttonTab .keyIR .IRCommand").change(function(ev) {
        var idx = +$(this).val();
        $(this).parents(".keyIR").find(".label").text(idx == 0 ? "" : idx);
    });

    // set up the IR command selectors
    var irdlg = $("#IRCommandSelector");
    $("#buttonTab .keyIR").click(function(ev)
    {
        // remember who opened the dialog
        dlgkey = $(this);

        // get the hidden field with the IR command index
        var fld = dlgkey.find(".IRCommand");

        // prepare the list - if it's empty, show a message instead of the popup
        if (!prepIRCommandSelector(+fld.val(), function(ev) {
            ev.preventDefault();
            var idx = +$(this).data("idx");
            fld.val(idx).change();
        }))
        {
            alert("Aucune commande IR n'a encore été configurée. Pour associer une "
                  + "commande IR avec un bouton, configurez d'abord la commande IR dans la"
                  + "Section Télécommande IR de la configuration.");
            return;
        }

        // mark the label as active
        dlgkeylbl = dlgkey.parents("tr.buttonRow");
        dlgkeylbl.addClass("openDlgRow");

        // show the dialog
        irdlg.parent().css("display", "block");

        // position it below the field
        var ofs = dlgkeylbl.offset();
        var dlght = irdlg.outerHeight() + 24;
        var winht = window.innerHeight - $("#nav").outerHeight();
        var scrolly = $("html,body").scrollTop();
        var y = ofs.top + dlgkeylbl.height();
        irdlg.css("top", y + "px");

        // position it horizontally under the button
        ofs = dlgkey.offset();
        irdlg.css("left", ofs.left + "px");

        // make sure the bottom of the dialog is in view
        if (y + dlght > scrolly + winht)
            scrolly = y + dlght - winht;

        // but limit this so that the top stays in view
        if (scrolly > y)
            scrolly = y;

        // scroll here
        $("html,body").animate({ scrollTop: scrolly });
    });
    irdlg.parent().click(function() { dismissIRDlg(); });

    function dismissIRDlg()
    {
        irdlg.parent().css("display", "none");
        if (dlgkeylbl) dlgkeylbl.removeClass("openDlgRow");
        dlgkey = dlgkeylbl = null;
    }
});
    
   </script>
      
   <!-- TLC5940 setup --------------------------------------------------->
   <hr>
   <div class="section" data-name="TLC5940">
      <img src="tlc5940.png" class="sectionIcon">
      <b>TLC5940 (configuration de la puce de contrôleur PWM externe)</b>
      <a class="shower" href="#">Qu'est-ce que c'est?</a>
      <div class="hider">
            Le TLC5940 est une puce de circuit intégré que vous pouvez connecter
            à la KL25Z pour ajouter des sorties supplémentaires pour plus de dispositifs de rétroaction (lumières,
            solénoïdes, moteurs, etc.). Les sorties du TLC5940 ont un PWM complet (Pulse
            Modulation de la largeur), permettant au logiciel de contrôler
            la luminosité d'une lumière attachée ou la vitesse d'un moteur. le
            La version DIP de cette puce n'est plus en cours de fabrication, il est
            impossible de les commander auprès de la plupart des distributeurs, mais ils sont toujours faciles
            à trouver sur eBay et ailleurs.
         <p>
            Ces puces vous permettent d'aller au-delà des capacités PWM limitées de la KL25Z.
            La KL25Z ne dispose que de 10 canaux PWM, ce qui n'est pas suffisant
            pour la plupart des flippers virtuels. Chaque puce TLC5940 fournit 16 PWM en
            sorties, et vous pouvez connecter deux puces ou plus en guirlande
            pour ajouter des sorties presque illimitées. Seules cinq broches GPIO sont nécessaires pour
            contrôler toute la chaîne.
         </p>
         <p>
            Les cartes d'extension Pinscape utilisent ces puces pour fournir un PWM supplémentaire
            aux sorties. Vous pouvez également les installer avec votre propre câblage personnalisé. 
            Les circuits nécessaires sont décrits dans le Guide de construction. Les paramètres ci-dessous
            configurent les connexions de signaux de données entre le KL25Z et le TLC5940.
         </p>
      </div>

      <div class="expBoardText">
         La configuration TLC5940 est automatiquement configurée pour vos cartes d'extension.
      </div>
      <div class="aioBoardText">
         La configuration TLC5940 est automatiquement configurée pour votre Pinscape AIO ou Pinscape Lite.
      </div>
      <div class="expBoardPin">
         <table class="inputs">
            <tr>
               <!-- the fixed width is a hack to get the two table column sets to line up -->
               <td style="width: 32ex;">Nombre de puces TLC5940:</td>
               <td>
                  <input type="text" size=4 id="tlc_nchips">
               </td>
            </tr>
         </table>
         <table id="tlcPins" class="inputs" style="display: block;">
            <tr>
               <!-- the fixed width is a hack to get the two table column sets to line up -->
               <td td style="width: 32ex;" class="pinlabel">SI (données série) en sortie:</td>
               <td>
                  <span class="pinselect" id="tlc_si"
                    data-cfg="TLC5940.SIN" data-gpiotype="spi-mosi extern"
                    data-desc="TLC5940 SI" data-default="PTC6">
                  </span>
               </td>
               <td>Nécessite un <a href="#" class="spiHelp">SPI MOSI</a> broche de sortie</td>
            </tr>
            <tr>
               <td class="pinlabel">SCLK (horloge série) en sortie:</td>
               <td>
                  <span class="pinselect" id="tlc_si"
                    data-cfg="TLC5940.SCLK" data-gpiotype="spi-sclk extern"
                    data-desc="TLC5940 SCLK" data-default="PTC5">
                  </span>
               </td>
               <td>Nécessite un <a href="#" class="spiHelp">SPI SCLK</a> broche de sortie</td>
            </tr>
            <tr>
               <td class="pinlabel">Sortie XLAT:</td>
               <td>
                  <span class="pinselect" id="tlc_xlat"
                    data-cfg="TLC5940.XLAT" data-gpiotype="dig-out extern"
                    data-desc="TLC5940 XLAT" data-default="PTC10">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">Sortie BLANK:</td>
               <td>
                  <span class="pinselect" id="tlc_blank"
                    data-cfg="TLC5940.BLANK" data-gpiotype="dig-out extern"
                    data-desc="TLC5940 BLANK" data-default="PTC7">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">Sortie GSCLK:</td>
               <td>
                  <span class="pinselect" id="tlc_gsclk"
                    data-cfg="TLC5940.GSCLK" data-gpiotype="pwm tpm extern"
                    data-desc="TLC5940 GSCLK" data-default="PTA1">
                  </span>
               </td>
               <td>Necessite un <a href="#" class="pwmHelp">Broche de sortie compatible PWM</a></td>
            </tr>
         </table>
      </div>
   </div>

   <script>
$("#tlc_nchips").change(function(ev)
{
    // show or hide the section as needed
    var active = +$(this).val() != 0;
    slideToggle($("#tlcPins"), active, loadingConfig ? 0 : 250, false);

    // Adjust the output ports, unless we're loading a config.  Don't
    // make any changes when loading, since we simply want to restore
    // the exact output port list in the config in this case.
    if (!loadingConfig)
        adjustOutputPorts(3);
});
   </script>

   <!-- TLC59116 setup --------------------------------------------------->
   <hr>
   <div class="section" data-name="TLC59116">
      <img src="tlc59116.png" class="sectionIcon">
      <b>TLC59116 (configuration de la puce de contrôleur PWM externe)</b>
      <a class="shower" href="#">Quest-ce que c'est?</a>
      <div class="hider">
            Le TLC59116 est une puce de circuit intégré que vous pouvez connecter
            à la KL25Z pour ajouter des sorties supplémentaires pour plus de dispositifs de rétroaction (lumières,
            solénoïdes, moteurs, etc.). Les sorties TLC59116 ont un PWM complet (Pulse
            Modulation de la largeur), permettant au logiciel de contrôler
            la luminosité d'une lumière attachée ou la vitesse d'un moteur.
         <p>
            Ces puces vous permettent d'aller au-delà des capacités PWM limitées du KL25Z.
            Le KL25Z ne dispose que de 10 canaux PWM, ce qui n'est pas suffisant
            pour la plupart des flippers virtuels. Chaque puce TLC59114 fournit 16 PWM
            sorties, et vous pouvez connecter jusqu'à 14 des puces. Seulement trois GPIO
            des broches sont nécessaires quel que soit le nombre de puces attachées.
         </p>
         <p>
            Le TLC59116 est un successeur du TLC5940 (voir ci-dessus) avec un plus
            Design moderne. Il est uniquement disponible dans un boîtier à montage en surface (SMD),
            ce qui rend le travail un peu plus difficile que le DIP traditionnel
            facteur de forme du TLC5940NT. Cette puce n'est <b> pas </b> interchangeable
            avec le TLC5940, même s'il a une fonction similaire, car il
            a une disposition de broches physique différente et une interface logicielle différente.
         </p>
      </div>

      <div>
         <div id="tlc59116Disabled" style="margin-left: 4em;">
            Désactivé - <a href="#">Afficher les paramètres</a>
         </div>
         <div id="tlc59116Settings">
            <div>
               <b>Puces attachées par adresse:</b> <a class="shower" href="#">Explication</a>
               <div class="hider">
                  Chaque TLC59116 a sa propre adresse unique, définie via les broches A3 A2 A1 A0
                  sur la puce: une broche câblée à + voltage est un "1" et une broche câblée à GND
                  est un "0". Sélectionnez les adresses des puces attachées à votre système
                  selon la façon dont vous avez câblé les broches d'adresse. Adresses 8 et 11
                  ne sont pas affichés car ils sont réservés à des fins spéciales.
                  Pour désactiver complètement la prise en charge de ce type de puce, décochez tous les
                  adresses pour indiquer qu'aucune puce n'est présente.
               </div>
            </div>
            <div id="tlc59116_chipsEnabled">
               <div>
                  <label><input type="checkbox" data-address="0"> 0 (0000)</label>
                  <label><input type="checkbox" data-address="1"> 1 (0001)</label>
                  <label><input type="checkbox" data-address="2"> 2 (0010)</label>
                  <label><input type="checkbox" data-address="3"> 3 (0011)</label>
                  <label><input type="checkbox" data-address="4"> 4 (0100)</label>
               </div>
               <div>
                  <label><input type="checkbox" data-address="5"> 5 (0101)</label>
                  <label><input type="checkbox" data-address="6"> 6 (0110)</label>
                  <label><input type="checkbox" data-address="7"> 7 (0111)</label>
                  <label><input type="checkbox" data-address="9"> 9 (1001)</label>
                  <label><input type="checkbox" data-address="10"> 10 (1010)</label>
               </div>
               <div>
                  <label><input type="checkbox" data-address="12"> 12 (1100)</label>
                  <label><input type="checkbox" data-address="13"> 13 (1101)</label>
                  <label><input type="checkbox" data-address="14"> 14 (1110)</label>
                  <label><input type="checkbox" data-address="15"> 15 (1111)</label>
               </div>
            </div>

            <div>
               <b>Attributions des broches GPIO:</b>
            </div>
            <table id="tlc59116Pins" class="inputs" style="display: block;">
               <tr>
                  <td class="pinlabel" style="width: 12ex;">SDA:</td>
                  <td>
                     <span class="pinselect" id="tlc59116_sda"
                        data-cfg="TLC59116.SDA" data-gpiotype="dig-out extern"
                       data-desc="TLC59116 SDA" data-default="PTC6">
                     </span>
                  </td>
               </tr>
               <tr>
                  <td class="pinlabel">SCL:</td>
                  <td>
                     <span class="pinselect" id="tlc59116_scl"
                        data-cfg="TLC59116.SCL" data-gpiotype="dig-out extern"
                       data-desc="TLC59116 SCL" data-default="PTC5">
                     </span>
                  </td>
               </tr>
               <tr>
                  <td class="pinlabel">REINITIALISER:</td>
                  <td>
                     <span class="pinselect" id="tlc59116_reset"
                        data-cfg="TLC59116.RESET" data-gpiotype="dig-out extern"
                       data-desc="TLC59116 RESET" data-default="PTC10">
                     </span>
                  </td>
               </tr>
            </table>
         </div>
      </div>
   </div>

   <script>
var tlc59116ChangeCheck, tlc59116Hider;
$("#tlc59116Disabled a").click(function(ev) {
    $("#tlc59116Disabled").hide();
    slideToggle("#tlc59116Settings", true, 250, false);
    ev.preventDefault();
});
$("#tlc59116_chipsEnabled input").change(function(ev)
{
    // queue a count change check
    if (!tlc59116ChangeCheck)
    {
        var lc = loadingConfig;
        tlc59116ChangeCheck = setTimeout(function()
        {
            // the timeout has fired
            tlc59116ChangeCheck = undefined;

            // count up the enabled chips
            var n = $("#tlc59116_chipsEnabled input:checked").length;

            // hide the settings if nothing's selected
            if (n == 0)
            {
                // remove any previous pending timeout
                if (tlc59116Hider)
                    clearTimeout(tlc59116Hider);

                // If we're loading the config, do this immediately; otherwise
                // wait a few seconds in case they're going to check another
                // item immediately to replace the un-checked item
                tlc59116Hider = setTimeout(function()
                {
                    // if everything's still un-checked, hide the settings
                    tlc59116Hider = undefined;
                    if ($("#tlc59116_chipsEnabled input:checked").length == 0)
                    {
                        // enabled - show settings, hide the "disabled" button
                        slideToggle($("#tlc59116Settings"), false, lc ? 0 : 250, false);
                        $("#tlc59116Disabled").show();
                    }
                }, lc ? 0 : 7500);
            }
            else
            {
                // If loading the config, hide the "disabled" section.  This isn't
                // necessary at other times, as we hide it when necessary in the UI
                // event handlers instead.
                if (lc)
                    setTimeout(function() { $("#tlc59116Disabled").hide(); }, 0);
            }

            // Adjust the output ports, unless we're loading a config.  Don't
            // make any changes when loading, since we simply want to restore
            // the exact output port list in the config in this case.
            if (!lc)
                adjustOutputPorts(6);
        }, 1);
    }
});
   </script>

   <!-- 74HC595 setup --------------------------------------------------->
   <hr>
   <div class="section" data-name="74HC595">
      <img src="74hc595.png" class="sectionIcon">
      <b>74HC595 (configuration de la puce de sortie numérique externe)</b>
      <a class="shower" href="#">What's this?</a>
      <div class="hider">
         Le 74HC595 est une puce de circuit intégré qui peut être connectée
         à la KL25Z pour ajouter plus de sorties numériques pour les dispositifs de retour comme
         solénoïdes et heurtoirs de lecture. «Numérique» signifie que les sorties
         sont strictement on / off: le logiciel ne peut pas moduler l'intensité ou la luminosité.
         Les sorties numériques sont idéales pour les dispositifs de rétroaction qui n'ont intrinsèquement besoin
	 que commande marche / arrêt, comme les solénoïdes.

         <p>
            Le "Chime Board" Pinscape utilise des puces pour ajouter des sorties pour les heurtoirs de relecture
	    et les unités de carillon. Vous pouvez aussi ajoutez ces puces avec votre propre câblage personnalisé,
	    le circuit est décrit dans le Guide de construction. Les paramètres ci-dessous vous permettent de
	    configurer les données de connexions entre la KL25Z et le 74HC595.
         </p>
      </div>

      <div class="expBoardText">
         La configuration 74HC595 est automatiquement configurée pour vos cartes carillon.
      </div>
      <div class="aioBoardText">
         La configuration 74HC595 est automatiquement configurée pour votre Pinscape AIO ou Pinscape Lite.
      </div>
      <div class="expBoardPin">
         <table class="inputs">
            <tr>
               <!-- the fixed width is a hack to get the two table column sets to line up -->
               <td style="width: 32ex;">Nombre de puces 74HC595:</td>
               <td>
                  <input type="text" size=4 id="hc595_nchips">
               </td>
            </tr>
         </table>
         <table id="hcPins" class="inputs" style="display: block;">
            <tr>
               <!-- the fixed width is a hack to get the two table column sets to line up -->
               <td td style="width: 32ex;" class="pinlabel">SI (données série) sortie:</td>
               <td>
                  <span class="pinselect" id="hc595_si"
                    data-cfg="HC595.SIN" data-gpiotype="dig-out extern"
                    data-desc="74HC595 SI" data-default="PTA5">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">SCLK (horloge série) sortie:</td>
               <td>
                  <span class="pinselect" id="hc595_si"
                    data-cfg="HC595.SCLK" data-gpiotype="dig-out extern"
                    data-desc="74HC595 SCLK" data-default="PTA4">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">Sortie Loquet:</td>
               <td>
                  <span class="pinselect" id="hc595_latch"
                    data-cfg="HC595.LATCH" data-gpiotype="dig-out extern"
                    data-desc="74HC595 LATCH" data-default="PTA12">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">Sortie ENA:</td>
               <td>
                  <span class="pinselect" id="hc595_ena"
                    data-cfg="HC595.ENA" data-gpiotype="dig-out extern"
                    data-desc="74HC595 ENA" data-default="PTD4">
                  </span>
               </td>
            </tr>
         </table>
      </div>
   </div>

   <script>
$("#hc595_nchips").change(function(ev)
{
    // show or hide our pin setup section as appropriate
    var active = +$(this).val() != 0;
    slideToggle($("#hcPins"), active, loadingConfig ? 0 : 250, false);

    // Add or remove output ports for the 74HC595 chips (type 4).  Skip
    // this when loading a config, since we want to simply restore the
    // exact output list from the saved config in this case.
    if (!loadingConfig)
        adjustOutputPorts(4);
});
   </script>

   <!-- Night Mode ------------------------------------------------------>
   <hr>
   <div class="section" data-name="Night Mode">
      <a name="nightmode"></a>
      <img src="nightModeSection.png" class="sectionIcon">
      <b>Pinscape après la tombée de la nuit.</b>  Vous pouvez configurer un bouton ou 
      activer le <b> Mode Nuit </b>, qui désactive les sorties du dispositif de retour
      que vous désignez comme faiseurs de bruit. Cela vous permet de jouer tard dans la nuit
      sans déranger vos colocataires, voisins fêtardset famille (surtout vôtre femme :)).
      <a href="#" class="shower">Détails</a>

      <div class="hider">
         <ul>
            <li>Sélectionnez un <a href="#buttonSection">bouton d'entrée</a> pour
             activé et désactivé le "Mode nuit". Câblez-le comme n'importe quel autre bouton.
			
            <li>Vous voudrez probablement configurer le bouton que vous sélectionnez
            pour "Aucune entrée PC" dans la <a href="#buttonSection"> configuration du bouton </a>,
            mais vous pouvez lui faire envoyer une frappe si cela vous est utile pour
            quelque raison.
            
            <li>Si vous ne souhaitez pas câbler un bouton physique pour cela,
            réglez le numéro du bouton sur 0 (zéro). Vous pouvez toujours contrôler le "mode nuit"
            avec le programme NightMode.exe sur le PC (il est dans votre Dossier "Pinscape Setup Tool").

            <li>Vous pouvez également sélectionner en option un port de sortie pour servir 
            d'indicateur lumineux, afin que vous puissiez savoir quand le mode nuit est activé.
            Si vous n'avez pas besoin d'un indicateur, réglez-le simplement sur 0. Si vous attribuez
            un port, vous devez le laisser non affecté dans votre disposition de port DOF.
         </ul>
      </div>

      <div id="nightModeOptions" style="margin: 1em 4em;">
         <table class="inputs">
            <tr>
               <td>
                  Numéro d'entrée du bouton:
               </td>
               <td>
                  <input id="nightModeButtonNo" size="4" style="margin: 0px 1em;">
                  <span style="padding-left: 2em; font-style: italic;">0 = aucun bouton d'entrée affecté</span>
               </td>
            </tr>
            <tr id="nightModeButtonShift">
               <td></td>
               <td>
                  <label><input type="checkbox"> Utiliser le bouton décalé</label> (Voir <a href="#buttonSection">Configuration des boutons</a>)
               </td>
            </tr>
            <tr>
               <td>
                  Type de bouton:
               </td>
               <td>
                  <table class="radio" style="display: inline-block; vertical-align: middle; margin: 1em 0px;">
                     <tr id="nightModeButtonTypeRow">
                        <td>
                           <label>
                              <img src="pushButton.png"><br>
                              <input type="radio" name="nightModeButtonType" value="1">
                              Bouton momentané
                              <br> (Active / désactive le mode lorsqu'il est enfoncé)
                           </label>
                        </td>
                        <td>
                           <label>
                              <img src="toggleSwitch.png"><br>
                              <input type="radio" name="nightModeButtonType" value="2">
                              Interrupteur marche / arrêt
                              <br>&nbsp;
                           </label>
                        </td>
                     </tr>
                  </table>
               </td>
            </tr>
            <tr>
               <td>
                  Port de sortie du témoin lumineux:
               </td>
               <td>
                  <input id="nightModeOutputNo" size="4" style="margin: 0px 1em;">
                  <span style="padding-left: 2em; font-style: italic;">0 = pas de sortie d'indicateur</span>
               </td>
            </tr>
         </table>
      </div>
      
   </div>

   <script>

// on changing the button number, update the icon display in the button setup section
$("#nightModeButtonShift input").change(function() { updateNightModeButton(); });
$("#nightModeButtonNo").change(function() { updateNightModeButton(); });
function updateNightModeButton()
{
    var n = +$("#nightModeButtonNo").val();
    $("#buttonTab .buttonCol").removeClass("nightMode");
    if (n)
    {
        var shifted = $("#shiftButton").val() != 0 && $("#nightModeButtonShift input").prop("checked");
        $("#buttonRow" + n + " .buttonCol." + (shifted ? "shifted" : "primary")).addClass("nightMode");
        ButtonTabUpdate.touch($("#buttonRow" + n));
    }
}

$("#nightModeButtonTypeRow input").change(function() {
    showHideNightModeButtonShift();
    updateNightModeButton();
});
$("#nightModeOutputNo").change(function()
{
    var n = +$(this).val();
    $("#outputTab .nightModeRemark").remove();
    if (n != 0) {
        $("#outputTab tr .outPortRemarks").eq(n-1).append(
            "<span class=\"nightModeRemark\" title=\"Ceci est le port du voyant du mode nuit\">"
            + "<a href=\"#nightmode\">"
            + "<img src=\"nightModeSmall.png\">"
            + "</a>"
            + "</span>");
    }
});

function showHideNightModeButtonShift()
{
    // the night mode button can only be on a shifted button if the shift
    // button is enabled AND the night mode button is in toggle mode
    var toggleMode = ($("#nightModeOptions input:radio[name=nightModeButtonType]:checked").val() == 1);
    $("#nightModeButtonShift").toggle($("#shiftButton").val() != 0 && toggleMode);

    // un-check the shift button if it's no longer valid
    if (!toggleMode)
        $("#nightModeButtonShift input").prop("checked", false).change();
}
      
   </script>


   <!-- Output controller setup ----------------------------------------->
   <hr>
   <div class="section" data-name="Output Ports">
      <a name="outputSection"></a>
      <img src="outputSection.png" class="sectionIcon">
      <b>Sorties du dispositif de retour. </b> Le logiciel de flipper sur le PC peut contrôler les
      périphériques de sortie connectés à la KL25Z pour créer des effets spéciaux pendant la lecture,
      tels que la rétroaction tactile et les écrans d'éclairage. Le logiciel PC utilise le
      <b> numéros de port </b> dans la liste ci-dessous pour adresser les sorties. Utilisez les
      numéros de port lorsque vous configurez votre <a class="dofconfigtool"> configuration DOF </a>.
      Pour chaque port, vous pouvez sélectionner la broche de sortie physique à laquelle le port est câblé.

      <div>
         <a href="#" id="btnOutputTest" class="button">Sorties de test</a>
      </div>

      <div>
         <table id="outputTab">
            <tr>
               <th></th>
               <th>Port No.</th>
               <th>Type</th>
               <th>Localisation</th>
               <th>Broche</th>
               <th>Port</th>
               <td></th>  <!-- pin warnings -->
               <th></th>  <!-- pin remarks -->
               <th>Options [<a href="#" class="outPortOptionsHelp">?</a>]</th>
               <th>Description</th>
         </table>
      </div>

   </div>

   <script>

// show the button tester
$("#btnOutputTest").click(function(ev)
{
    ev.preventDefault();
    var cfgMem = normalizeConfig(configFromUI());
    var cfgDev = normalizeConfig(config);
    if (!valEq(cfgMem.outputs, cfgDev.outputs))
    {
        if (!window.external.YesNoDialog(
            "Vous avez apporté des modifications aux paramètres du port de sortie que vous n'avez pas "
            + "déjà programmé dans la KL25Z. La fenêtre du testeur reflétera "
            + "les paramètres actuels de l'appareil, pas vos nouvelles modifications non enregistrées."
            + "Si vous souhaitez tester vos nouveaux paramètres, cliquez sur \"Programmer KL25Z \" "
            + "avant de passer à la fenêtre du testeur."
            + "\ r \ n \ r \ n"
            + "Voulez-vous quand même ouvrir le testeur?"))
            return;
    }

    // show the dialog
    window.external.ShowOutputTester(CPUID);
});


// Set up the output port table
$(function() {
    var rows = [];
    for (var i = 1 ; i <= MaxOutputs ; ++i)
    {
        // In each row:
        //   - dispPinType is a derived display name describing the pin type
        //   - dispPinName is a derived display name describing the pin name
        //   - pinval is the internal pin value.  For GPIO pins, this uses the
        //     standard PTxn notation.  For external chip pins, it's simply
        //     the port number, numbering from 0 for the first chip's first
        //     output.
        //   - pintype is the internal pin type, per the USB config messages
        //     (0=disabled, 1=PWM, etc)
        rows.push("<tr id=\"outPortRow" + i + "\" class=\"outPortRow\" data-idx=\"" + i + "\" "
                  +  "data-desc=\"Output Port " + i + "\">"
                  +   "<td class=\"rowControls\">"
                  +      "<span class=\"addRow\" title=\"Insérez un nouveau port de sortie ici\"></span>"
                  +      "<span class=\"delRow\" title=\"Supprimer ce port de sortie\"></span>"
                  +      "<span class=\"moveRow\" title=\"Déplacer ce port de sortie\"></span>"

// sélectionner - désactiver pour le moment: travaille toujours sur les détails, mais pourrait ajouter plus tard
//                +      "<span class=\"selectRow\" title=\"Sélectionnez ce port de sortie (utilisez SHIFT ou CTRL "
// 		  + 		"pour sélectionner plusieurs ports à déplacer ou supprimer)\"></span>"

                  +   "</td>"
                  +   "<td class=\"pinlabel\">" + i + "</td>"
                  +   "<td><span class=\"dispPinType\"></span></td>"
                  +   "<td class=\"dispPinLoc\"></td>"
                  +   "<td class=\"dispPinHeader\"></td>"
                  +   "<td class=\"outPortPin\">"
                  +      "<input class=\"dispPinName\" type=\"text\" size=\"15\" readonly>"
                  +      "<input class=\"pintype\" type=\"hidden\">"
                  +      "<input class=\"pinval\" type=\"hidden\">"
                  +   "</td>"
                  +   "<td>"
                  +      "<span class=\"pinwarn\"><img src=\"pinwarn.png\"></span>"
                  +   "</td>"
                  +   "<td class=\"outPortRemarks\"></td>"
                  +   "<td class=\"outPortOptions\">"
                  +      "<input class=\"pinflags\" type=\"hidden\">"
                  +      "<input class=\"flipperLogic\" type=\"hidden\">"
                  +      "<img src=\"NoisyOff.png\" class=\"outPortNoisy\" data-mask=\"2\" "
                  +         "title=\"Appareil bruyant: désactivez ce port lorsque le mode nuit est activé\">"
                  +      "<img src=\"GammaOff.png\" class=\"outPortGamma\" data-mask=\"4\" "
                  +         "title=\"Utilisez la correction gamma sur ce port (convient aux lampes et aux LED)\">"
                  +      "<img src=\"ActiveLowOff.png\" class=\"outPortLow\" data-mask=\"1\" "
                  +         "title=\"Port bas actif: le port se connecte à la terre (0 V) lorsqu'il est allumé\">"
                  +      "<img src=\"FlipperLogicOff.png\" class=\"outPortFlipperLogic\" data-mask=\"8\" "
                  +         "title=\"Flipper Logic: réduire la puissance du port lorsqu'il est maintenu\">"
                  +      "<img src=\"ChimeLogicOff.png\" class=\"outPortChimeLogic\" data-mask=\"16\" "
                  +         "title=\"Chime Logic: définir les temps de marche minimum et maximum\">"
                  +   "</td>"
                  +   "<td>"
                  +      "<input class=\"outPortDesc\" type=\"text\" size=\"20\">"
                  +   "</td>"
                  + "</tr>");
    }

    // add a last row with just a "+" control to add a row at the end
    rows.push("<tr class=\"outPortRow\" data-idx=\"end\" id=\"lastOutPortRow\">"
              +   "<td class=\"rowControls\">"
              +      "<span class=\"addRow\" title=\"Ajouter un nouveau port de sortie\"></span>"
              +   "</td>"
              +   "<td></td>"
              +   "<td></td>"
              +   "<td></td>"
              + "</tr>");

    // insert the rows
    $("#outputTab").append(rows);

    // add change handlers for the pin type and value
    var typeNames = ["Disabled", "PWM", "Digital", "PWM", "Digital", "Virtual", "PWM"];
    $(".outPortRow .pintype, .outPortRow .pinval").change(function()
    {
        // get the row (the .outPortRow parent)
        var row = $(this).parents(".outPortRow");

        // get the internal pin type value and corresponding display name
        var typ = row.find(".pintype");
        var typval = boundsCheck(+typ.val(), typeNames);
        var typeDisp = typeNames[typval];
        
        // get the internal pin value
        var pin = row.find(".pinval").val();

        // presume the row pin type will empty
        row.data("pintype", "");

        // update the displayed pin name
        var pinDisp = "";
        var locDisp = "";
        var hdrDisp = "";
        var opts = 0xff;
        var isPWM = false;
        switch(typval)
        {
        case 1: // PWM Out (GPIO)
            locDisp = "KL25Z";
            hdrDisp =  pinToJumper(pin);
            pinDisp = pin;
            row.data("pintype", "pwm");
            isPWM = true;
            break;
    
        case 2: // Digital Out (GPIO)
            locDisp = "KL25Z";
            hdrDisp = pinToJumper(pin);
            pinDisp = pin;
            row.data("gpiotype", "dig-out");
            opts &= ~(4);  // gamma isn't applicable to digital outs
            break;

        case 3: // TLC5940
            locDisp = "TLC5940 #" + (Math.floor(pin/16)+1);
            hdrDisp = [28, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15][pin % 16];
            pinDisp = "Out " + (pin % 16);
            opts &= ~1;        // active low isn't applicable to TLC5940 outputs
            isPWM = true;
            break;

        case 4: // 7HC595
            locDisp = "74HC595 #" + (Math.floor(pin/8)+1);
            hdrDisp = [15, 1, 2, 3, 4, 5, 6, 7][pin % 8];
            pinDisp = "Out " + (pin % 8);
            opts &= ~(1 | 4);  // active low and gamma aren't applicable to 74HC595 outputs
                               // (gamma is disabled because these aren't PWM-able)
            break;

        case 5: // Virtual
            locDisp = "None";
            hdrDisp = "";
            pinDisp = "";
            opts &= ~(1 | 2 | 4 | 8); // gamma, active low, noisy, and Flipper Logic aren't applicable to virtual outputs
            break;

        case 6: // TLC59116
            locDisp = "TLC59116 @" + ((pin >> 4) & 0x0F);
            hdrDisp = [6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23][pin & 0x0F];
            pinDisp = "Out " + (pin & 0x0F);
            opts &= ~1;        // active low isn't applicable to TLC59116 outputs
            isPWM = true;
            break;
        }

        // hide Chime Logic if the device doesn't support it
        if (deviceInfo && !deviceInfo.ChimeLogicFeatures)
            opts &= ~16;

        // if there's an expansion board alias, apply it
        var alias = outPortAlias[typval + "." + pin];
        if (alias)
        {
            // set the alias name
            alias = alias.split("|");
            pinDisp = alias[0];
            typeDisp = alias[1];
            locDisp = alias[2];
            hdrDisp = alias[3];
        }

        // set the name and type strings
        row.find(".dispPinLoc").text(locDisp);
        row.find(".dispPinName").val(pinDisp);
        row.find(".dispPinHeader").text(hdrDisp);
        row.find(".dispPinType").text(typeDisp);

        // enable/disable option checkboxes
        row.find(".outPortOptions img").each(function() {
            var img = $(this);
            var mask = img.data("mask");
            var vis = !!(mask & opts);
            img.toggle(vis);
            if (!vis)
                img.attr("src", img.attr("src").replace(/On|Off/, "Off"));
        });
    });

    // change handler for the port options internal data field
    $("#outputTab .outPortRow .pinflags").change(function() {
        var self = $(this);
        var flags = +self.val();
        self.parent().find("img").each(function() {
            var img = $(this);
            var state = (flags & img.data("mask")) != 0 ? "On" : "Off";
            img.attr("src", img.attr("src").replace(/(On|Off)/, state));
        });
    });

    // click handlers for the port options icons
    $("#outputTab .outPortRow .outPortOptions img").click(function(ev)
    {
        // get the options bit for this icon
        var img = $(this);
        var mask = +img.data("mask");

        // toggle the bit in the hidden options field
        var flagfield = img.parents(".outPortOptions").children(".pinflags");
        var newval = +flagfield.val() ^ mask;

        // flipper logic and chime logic are mutually exclusive
        if (mask == 8)
            newval &= ~16;
        else if (mask == 16)
            newval &= ~8;

        // update the flags field
        flagfield.val(newval).change();

        // if we just turned on Flipper Logic or Chime Logic, show options popup
        if ((newval & mask) != 0)
        {
            if (mask == 8)
                showFlipperLogicPopup(img, true);
            else if (mask == 16)
                showChimeLogicPopup(img, true);
        }
    });

    // position one of the output port popups (flipper logic, chime logic)
    function showOutPortPopup(dlg, img)
    {
        // show the dialog element
        dlg.parent().show();

        // position it next to the image
        var ofs = img.offset();
        var dlght = dlg.outerHeight() + 24;
        var winht = window.innerHeight - $("#nav").outerHeight();
        var btnht = img.outerHeight();
        var scrolly = $("html,body").scrollTop();
        var y = ofs.top + (btnht - dlght)/2;

        // make sure it's in view
        if (y + dlght > scrolly + winht)
            y = scrolly + winht - dlght;
        if (y < scrolly)
            y = scrolly;

        // set the position
        dlg.css({"top": y + "px", "left": ofs.left + img.innerWidth() + "px"});
    }

    // set up mouse handlers on an output row popup
    function initOutPortPopupMouseHandlers(dlg, iconHolder, doClose)
    {
        dlg.parent().mousemove(function(ev)
        {
            var x = ev.pageX, y = ev.pageY;
            var icon = iconHolder.icon;
            var imgofs = icon.offset();
            if (x < imgofs.left || x > imgofs.left + icon.outerWidth()
                || y < imgofs.top || y > imgofs.top + icon.outerHeight())
            {
                // it's not over the icon - check if it's over the dialog
                var dlgofs = dlg.offset();
                if (x < dlgofs.left || x > dlgofs.left + dlg.outerWidth()
                    || y < dlgofs.top || y > dlgofs.top + dlg.outerHeight())
                {
                    // it's not over the dialog either - close the dialog
                    doClose();
                }
            }
        }).click(function(ev)
        {
            // if we're in the opening icon, close the dialog and pass the
            // click to the icon
            var x = ev.pageX, y = ev.pageY;
            var icon = iconHolder.icon;
            var imgofs = icon.offset();
            if (x >= imgofs.left && x <= imgofs.left + icon.outerWidth()
                || y >= imgofs.top && y <= imgofs.top + icon.outerHeight())
            {
                icon.click();
                doClose();
            }
        });
    }

    // --------- Flipper Logic popup ----------------------------------------

    // Given the flipper logic parameter value, get the 4-bit parameter value
    // 50ms units, starting at 0=50ms
    function flipperLogicTime(param) { return (param + 1) * 50; }

    // Given the flipper logic parameter value, get the hold power as a percentage value
    // 17-point units on 0..255 scale
    function flipperLogicPower(param) { return Math.round((param & 0x0F)*17/2.55); }

    // Show the flipper logic popup
    var flDialog = $("#flipperLogicPopup");
    var flIcon = { };
    function showFlipperLogicPopup(img, clicked)
    {
        // figure out if it's a digital or PWM-capable output
        var pintype = +img.parents(".outPortRow").find(".pintype").val();
        var isPWM = false;
        switch (pintype)
        {
        case 1:   // PWM GPIO
        case 3:   // TLC5940
        case 6:   // TLC59116
            isPWM = true;
            break;
        }
    
        // show the dialog
        showOutPortPopup(flDialog, flIcon.icon = img);

        // decode the parameter into time and power components
        var val = +img.parents(".outPortRow").find(".flipperLogic").val();
        var timeIndex = (val >> 4) & 0x0F;
        var powerIndex = val & 0x0F;

        // set the current field values
        flDialog.find(".flTimeTxt").val(flipperLogicTime(timeIndex) + "ms");
        flDialog.find(".flPowerTxt").val(flipperLogicPower(powerIndex) + "%");

        // set the sliders to reflect the current values
        flDialog.find(".flTimeSlider").slider("value", timeIndex);
        flDialog.find(".flPowerSlider").slider("value", isPWM ? powerIndex : 0);

        // show the hold power slider only if this is a PWM-capable port
        flDialog.find(".flPowerSlider").css("visibility", isPWM ? "visible" : "hidden");
    }
    function hideFlipperLogicPopup()
    {
        // hide the dialog
        flDialog.parent().hide();

        // store the new settings - encode the two components into the
        // parameter byte as (time index << 4) | (power index)
        flIcon.icon.parents(".outPortRow").find(".flipperLogic").val(
            (flDialog.find(".flTimeSlider").slider("value") << 4)
            | flDialog.find(".flPowerSlider").slider("value"));
    }

    // When hovering over a flipper logic icon, bring up the FL settings
    // popup if the icon is ON.
    $("#outputTab .outPortFlipperLogic").mouseover(function(ev) {
        var img = $(this);
        var flags = +img.parents(".outPortOptions").children(".pinflags").val();
        if (flags & 8)
            showFlipperLogicPopup(img, false);
    });

    // set up mouse handlers
    initOutPortPopupMouseHandlers(flDialog, flIcon, hideFlipperLogicPopup);

    // don't bubble clicks from within the FL options popup
    flDialog.click(function(ev) { ev.stopPropagation(); });

    // set up the sliders
    $(".flTimeSlider, .flPowerSlider").slider({
        orientation: "vertical",
        min: 0,
        max: 15,
    });
    $("#flipperLogicPopup .flTimeSlider").on("slide", function(ev, ui) {
        $("#flipperLogicPopup .flTimeTxt").val(flipperLogicTime(ui.value) + "ms");
    });
    $("#flipperLogicPopup .flPowerSlider").on("slide", function(ev, ui) {
        $("#flipperLogicPopup .flPowerTxt").val(flipperLogicPower(ui.value) + "%");
    });

    // --------- Chime Logic popup ----------------------------------------

    // Decode the chime logic time parameters
    function chimeLogicTime(param)
    {
        var ms = [0, 1, 2, 5, 10, 20, 40, 80, 100, 200, 300, 400, 500, 600, 700, 800];
        return ms[param];
    }
    function chimeLogicMinTime(param) { return chimeLogicTime(param) + "ms"; }
    function chimeLogicMaxTime(param) { return param == 0 ? "Infinite" : chimeLogicTime(param) + "ms"; }

    // Show the chime logic popup
    var clDialog = $("#chimeLogicPopup");
    var clIcon = { };
    function showChimeLogicPopup(img, clicked)
    {
        // show the dialog
        showOutPortPopup(clDialog, clIcon.icon = img);

        // decode the parameter into the time components
        var val = +img.parents(".outPortRow").find(".flipperLogic").val();
        var maxTimeIndex = (val >> 4) & 0x0F;
        var minTimeIndex = val & 0x0F;

        // set the current field values
        clDialog.find(".minTimeTxt").val(chimeLogicMinTime(minTimeIndex));
        clDialog.find(".maxTimeTxt").val(chimeLogicMaxTime(maxTimeIndex));

        // Set the sliders to reflect the current values.  Set the max time
        // so that 0 == infinite shows as the maximum value, and everything
        // else is shifted down one slot.
        clDialog.find(".minTimeSlider").slider("value", minTimeIndex);
        clDialog.find(".maxTimeSlider").slider("value", maxTimeIndex == 0 ? 15 : maxTimeIndex - 1);
    }
    function hideChimeLogicPopup()
    {
        // hide the dialog
        clDialog.parent().hide();

        // store the new settings - encode the two components into the
        // parameter byte as (max time index << 4) | (min time index)
        clIcon.icon.parents(".outPortRow").find(".flipperLogic").val(
            (((clDialog.find(".maxTimeSlider").slider("value") + 1) & 0x0f) << 4)
            | clDialog.find(".minTimeSlider").slider("value"));
    }

    // When hovering over a chime logic icon, bring up the CL settings
    // popup if the icon is ON.
    $("#outputTab .outPortChimeLogic").mouseover(function(ev) {
        var img = $(this);
        var flags = +img.parents(".outPortOptions").children(".pinflags").val();
        if (flags & 16)
            showChimeLogicPopup(img, false);
    });

    // set up mouse handlers
    initOutPortPopupMouseHandlers(clDialog, clIcon, hideChimeLogicPopup);

    // don't bubble clicks from within the options popup
    clDialog.click(function(ev) { ev.stopPropagation(); });

    // set up the sliders
    $(".minTimeSlider, .maxTimeSlider").slider({
        orientation: "vertical",
        min: 0,
        max: 15,
    });
    $("#chimeLogicPopup .minTimeSlider").on("slide", function(ev, ui) {
        $("#chimeLogicPopup .minTimeTxt").val(chimeLogicMinTime(ui.value));
    });
    $("#chimeLogicPopup .maxTimeSlider").on("slide", function(ev, ui) {
        $("#chimeLogicPopup .maxTimeTxt").val(chimeLogicMaxTime((ui.value + 1) & 0xf));
    });

    // ----------------------------------------------------------------------

    // insert a row
    $("#outputTab .addRow").click(function(ev) {
        ev.stopPropagation();
        insertOutputs($(this).parents(".outPortRow"), 1);
    });

    // delete a row
    $("#outputTab .delRow").click(function(ev)
    {
        // ask for confirmation, and delete the row if confirmed
        ev.stopPropagation();
        if (window.external.YesNoDialog(
            "Êtes-vous sûr de vouloir supprimer ce port de sortie?"))
            deleteOutputs($(this).parents(".outPortRow"), 1);
    });

    // select a row
    $("#outputTab .selectRow").click(function(ev)
    {
        var self = $(this);
        var row = self.parents(".outPortRow");
        if (ev.shiftKey)
        {
            // shift key - extend selection to include all rows from here to
            // first and last selected rows
            var allsel = row.parent().children(".selected");
            var first = allsel.first(), firstidx = first.data("idx");
            var last = allsel.last(), lastidx = last.data("idx");
            var idx = +row.data("idx");

            // if the first selected row is before us, extend from first to here
            if (firstidx && +firstidx < idx)
                row.parent().children().slice(+firstidx, idx).addClass("selected");

            // if the last selected row is after us, extend from here to last
            if (lastidx && +lastidx > idx)
                row.parent().children().slice(idx, +lastidx).addClass("selected");

            // in any case, definitely select this row
            row.addClass("selected");
        }
        else if (ev.ctrlKey)
        {
            // toggle this row only
            row.toggleClass("selected");
        }
        else
        {
            // toggle this row and deselect all other rows
            var sel = row.hasClass("selected");
            $("#outputTab .outPortRow").removeClass("selected");
            row.toggleClass("selected", !sel);
        }
        return false;
    }).mousedown(function(ev) {
        // prevent text selection when clicking in this control
        ev.preventDefault();
    });

    // move a row
    $("#outputTab .moveRow").mousedown(function(ev)
    {
        // get the row and table
        var row = $(this).parents(".outPortRow");
        var tab = $("#outputTab");

        // set up a copy of the row to show during the move, wrapped in a
        // position:absolute div so that we can have it track the mouse
        var mover = $("<div class=\"rowMover\"></div>");
        $("body").append(mover);
        mover.append("<td><span class=\"moveIcon\"></span></td>");
        mover.append(row.children().slice(1).clone());
        var left = tab.offset().left;

        // copy widths and text alignments
        for (var dst = mover.children().first(), src = row.children().first(), i = 0 ;
             src.length ;
             src = src.next(), dst = dst.next(), ++i)
        {
            // copy the width, padding, and alignment
            dst.css("width", src.outerWidth() + "px");
            dst.css(src.css(["padding-left", "padding-right", "text-align"]));

            // ... except for the first column, where we force right alignment, since
            // we substitute our own "moving" icon in place of the normal row controls
            if (i == 0)
                dst.css("text-align", "right"); // add if "select row" icon is present: .css("padding-right", "22px");
        }

        var td = $(row).children("td").eq(1);
        var ofs = row.offset();
        mover.css({
            "left": left + "px",
            "top": td.offset().top + "px"
        });

        var strut = $(
            "<tr data-idx=\"strut\">"
            +   "<td style=\"height:" + mover.outerHeight() + "px;\">"
            +   "</td>"
            + "</tr>");
        strut.insertBefore(row);

        // hide the original row while dragging it
        row.css("display", "none");

        // monitor entering and leaving rows as the mouse moves to show
        // where the drop will go
        var target = $();
        $("#outputTab .outPortRow").on("mousemove.outputRowMover", function(ev)
        {
            // ignore any events in the row being dragged
            if (this == row[0]) return;

            // Figure which side of the row we're on.  If we're in the top half,
            // move the dragged row before the target row; otherwise move it after
            // the target row.  Exception: we can't go past the last row.
            var self = $(this);
            var ofs = self.offset();
            var newTarget = (ev.pageY < ofs.top + self.outerHeight()/2)
                            || self.data("idx") == "end" ? self : self.next();

            // skip the fake "strut" row and the original row
            while (newTarget[0] == row[0] || newTarget.data("idx") == "strut")
                newTarget = newTarget.next();

            if (newTarget[0] != target[0])
            {
                // remove any previous target highlighting and highlight the new target row
                target = newTarget;
                strut.insertBefore(target);
                var top = strut.offset().top;

                // move the on-screen drag row to track the mouse
                mover.css({"left": left + "px", "top": top + "px"});
            }
        });

        // trigger an immediate enter on the next row if it's visible
        if (row.next().css("display") != "none")
            row.next().mouseover();
        else
            $("#outputTab .outPortRow").last().mouseover();

        var mousex, mousey;
        $(":root").on("mousemove.outputRowMover", function(ev) {
            mousex = ev.pageX;
            mousey = ev.pageY;
        });
        var scrollTimer = setInterval(function() {
            var doc = $("html,body");
            var sy = doc.scrollTop();
            var ht = window.innerHeight - $("#nav").outerHeight();
            var adj = 16;
            if (mousey < sy + adj) {
                doc.scrollTop(sy - 16);
                mousey = 0;
            }
            else if (mousey > sy + ht - adj) {
                mousey = 100000;
                doc.scrollTop(sy + 16);
            }
        }, 100);

        // monitor mouse-button-up anywhere on the document to end the drag
        $(":root").on("mouseup.outputRowMover", function(ev)
        {
            // remove all target highlighting
            strut.remove();

            // remove the on-screen drag row
            mover.remove();

            // restore visibility to the original row
            row.css("display", "");

            // move the row
            if (target.length)
                moveOutputs(row, target, 1);

            // remove the drag monitor events
            $(":root, #outputTab .outPortRow").off(".outputRowMover");

            // remove the scroll timer
            clearInterval(scrollTimer);
        });

        ev.preventDefault();
        ev.stopPropagation();
        return false;
    });
});



// Adjust the output ports for a change in peripheral chips.  This is
// for peripheral chips that provide output ports (TLC5940, TLC59116,
// 74HC595).  We'll adjust the output array by adding new ports if chips
// have been added, or removing existing ports for chips that are no
// longer present.
//
// If 'pintype' is provided, we'll only apply changes for that type.
// The type is the USB port setup message type: 3=TLC5940, 4=74HC595,
// 6=TLC59116.  If 'pintype' is omitted, we'll update all types.
var adjustOutputPorts = (function()
{
    // Set up an internal table of the factory ports, so that we can
    // find the flags for a given factory port
    var factoryOutputs = { };
    $.each(expansionBoardFactoryConfig.output, function(k, v) {
        factoryOutputs[v.port.type + "." + v.port.pin] = v;
    });

    // list of pending updates
    var pending;

    // main handler - queue a deferred update
    return function(pintype)
    {
        // If we don't already have a pending operation, queue one up.
        // Set it to run in a couple of seconds, to allow for grouping
        // multiple UI changes.
        if (!pending) {
            pending = { };
            setTimeout(go, 1000);
        }

        // Add this pintype to the pending list.  If no pintype was
        // provided, add them all.
        if (pintype)
            pending[pintype] = true;
        else
            pending[3] = pending[4] = true;
    };

    // perform pending updates
    function go()
    {
        // mark for deletion ports for a given chip that are no longer accessible 
        function markDelPorts(pintype, keep)
        {
            // mark for deletion each row that refers to a non-existent port on this chip
            var ports = { };
            for (var row = $("#outputTab .outPortRow").first() ; row.data("idx") != "end" ; row = row.next())
            {
                // if this row is for a non-existent port, delete it
                var del = false;
                if (row.find(".pintype").val() == pintype)
                {
                    // note the existing port
                    var portno = +row.find(".pinval").val();
                    ports[portno] = true;
                    
                    // delete it if it's no longer present
                    if (!keep(portno))
                        row.data("delete", true);
                }
            }
        
            // return the port list
            return ports;
        }
        
        // insert new ports as needed
        function insPorts(ports, pintype, nports, flags, indexToPortNo)
        {
            // if no port number mapping function was provided, the port number
            // simply maps 1:1 to the index
            if (!indexToPortNo) 
                indexToPortNo = function(n) { return n; };

            // Insert ports that aren't already present
            for (var i = 0 ; i < nports ; ++i)
            {
                // get the port number at this index
                var portno = indexToPortNo(i);

                // insert an output row in the UI if it's not already there
                if (!ports[portno])
                    newPortList.push({pintype: pintype, pinval: portno, pinflags: flags});
            }
        }

        // get the number of each chip
        var ntlc = +$("#tlc_nchips").val();
        var nhc = +$("#hc595_nchips").val();

        // The TLC59116 chips are enabled individually by address.  Get
        // a list of the checked boxes for enabled chips.
        var ck59116 = $("#tlc59116_chipsEnabled input:checked");

        // Build a list of the enabled chips by address, and all of the
        // ports on the enabled chips by encoded address:pin value.
        var chips59116 = [], ports59116 = { };
        ck59116.each(function()
        {
            // get the chip address from the checkbox
            var addr = +$(this).data("address");

            // add the chip address to the list of enabled chips
            chips59116.push(addr);

            // Add all of the pins to the list of enabled pins.  The
            // pins are encoded with the chip address in the high four
            // bits and the pin number in the low four bits.
            for (var i = 0, addrMask = addr << 4 ; i < 16 ; ++i)
                ports59116[addrMask | i] = true; 
        });
        var n59116 = ck59116.length;
        
        // delete outputs for each chip that are no longer needed
        var tlcPorts = pending[3] ? markDelPorts(3, function(n) { return n < ntlc*16; }) : null;
        var hcPorts = pending[4] ? markDelPorts(4, function(n) { return n < nhc*8; }) : null;
        var tlc59116Ports = pending[6] ? markDelPorts(6, function(n) { return ports59116[n]; }) : null;
        
        // apply deletions
        deleteOutputs();
        
        // HACK: If an expansion board configuration is selected, mark
        // any new 74HC595 ports as "noisy".  The expansion boards use
        // these ports only on the chime boards, and these boards are
        // specialized for driving solenoids, and solenoids are pretty
        // much only used in virtual pinball machines for tactile feedback
        // devices that make noise... therefore it's safe to assume that
        // these outputs will be noisy.  It would be nicer to have an
        // abstract and extensible way of handling default flags for new
        // ports, but so far this is the only situation where we need any
        // flags at all, and as long as that's true it's simpler to just
        // treat it as the special case it is.  The user can still remove
        // the "noisy" flag if it turns out to be wrong for their setup.
        var hcFlags = 0;
        var hwType = $("input:radio[name=hardwareType]:checked").val();
        if (hwType == 1 /* Expansion Boards */
            || hwType == 2 /* AIO Board */
            || hwType == 3 /* Lite Board */)
            hcFlags = 0x02;  // noisy

        // generate the list of new ports we need
        var newPortList = [];
        if (pending[3]) insPorts(tlcPorts, 3, ntlc*16, 0);
        if (pending[4]) insPorts(hcPorts, 4, nhc*8, hcFlags);
        if (pending[6]) insPorts(tlc59116Ports, 6, n59116*16, 0, function(n)
        {
            // construct the pin address: the high four bits are the chip
            // address for the n/16th chip, and the low four bits are the
            // port number n%16
            return (chips59116[n >> 4] << 4) | (n & 0x0F);
        });

        // insert the batch of new outputs into the table
        if (!insertOutputs($("#lastOutPortRow"), newPortList))
            alert("Vous avez atteint le nombre maximum de ports de sortie. Il n'y a pas "
                  + "assez d'emplacements pour ajouter tous les ports pour le ou les nouveaux appareils que vous"
                  + "venez d'ajouter, donc aucun n'a été ajouté. Vous pourrez peut-être encore"
                  + "en ajouter manuellement certains et vous pouvez également les réaffecter"
                  + "tous les ports inutilisés sur d'autres périphériques vers le ou les nouveaux périphériques.");

        // adjust the active/inactive status for the peripheral chip connections
        adjustPeripheralPins(pending[3], pending[4], pending[6]);

        // update pin warnings
        updatePinWarnings();

        // we no longer have work pending
        pending = undefined;
    }
})();

function adjustPeripheralPins(tlc5940, hc595, tlc59116)
{
    // activate or deactivate the TLC5940 pins, if desired
    if (tlc5940)
        $("#tlcPins .pinselect").data("active", $("#tlc_nchips").val() != 0);

    // likewise the 74HC595 pins
    if (hc595)
        $("#hcPins .pinselect").data("active", $("#hc595_nchips").val() != 0);

    // and the TLC59116 pins
    if (tlc59116)
        $("#tlc59116Pins .pinselect").data("active", $("#tlc59116_chipsEnabled input:checked").length != 0);
}

// Insert/delete output ports
var insertOutputs, deleteOutputs, moveOutputs, appendOutputs;
(function() {

    // Insert one or more output port rows before the given row.  Returns
    // true on success, false if there's not room for the added rows.  We
    // check for room before adding any rows, so no changes are made if
    // the insertion fails.
    insertOutputs = function(before, numOrVals)
    {
        // Determine if the caller provided a number of rows or an array of values
        // to insert.  If no value array was provided, the default is
        // type 5 (virtual).
        var num = 1, val = [];
        var virtual = { pintype: 5 };
        if (typeof numOrVals == "number") {
            num = numOrVals;
        }
        else if ($.isArray(numOrVals)) {
            val = numOrVals;
            num = val.length;
        }
        else if (typeof numOrVals == "object") {
            val = [numOrVals];
        }

        // make sure the last 'num' rows are free
        var rows = $("#outputTab .outPortRow");
        for (var i = 0, cur = rows.last().prev() ; i < num ; ++i, cur = cur.prev())
        {
            // if this row is in use, we don't have room for the insertion
            if (cur.find(".pintype").val() != 0)
                return false;
        }

        // note the insertion point
        var idx = before.data("idx");

        // if we're inserting after the last row, the true insertion point
        // is the first unused row
        if (idx == "end")
        {
            // find the first free row
            before = findFreeRow();
        }
        else
        {
            // Set up pointers for moving rows.  We've already backed up
            // 'cur' by 'num' rows from the end, so it's our source pointer;
            // our destination pointer is the last row (actually the second
            // to last, since the last is the fake row for the "add a row at
            // the end" control).
            var src = cur;
            var dst = rows.last().prev();

            // Move rows until we reach the 'before' row
            for ( ; ; src = src.prev(), dst = dst.prev())
            {
                // if this row is in use, move it
                copyRow(src, dst);
                
                // if we just copied the 'before' row, we're done
                if (src.data("idx") == idx)
                    break;
            }
        }
        
        // populate the new rows
        for (var i = 0 ; i < num ; ++i, before = before.next())
            setRow(before, i < val.length ? val[i] : virtual);
        
        // fix up the table for the insertion
        fixUpTable();

        // success
        return true;
    };

    // Append outputs to the end of the table, up to and including
    // the given row number.  Sets each new output to a virtual port.
    appendOutputs = function(row)
    {
        // go through rows starting at row 1, and set each
        // unused output through the given row to "virtual"
        var rows = $("#outputTab .outPortRow");
        for (var i = 0 ; i < row ; ++i)
        {
            // get the row
            var cur = rows.eq(i);

            // if it's the special last row, we're done
            if (cur.data("idx") == "end")
                break;

            // if the pin type is zero, change this to a virtual row
            if (cur.find(".pintype").val() == 0)
            {
                cur.find(".pintype").val(5).change();
                cur.find(".pinval").val(0);
                cur.find(".pinflags").val(0);
            }
        }

        // fix up for the deletion
        fixUpTable();
    };

    // Delete one or more output rows starting with the given row.
    //
    // If called with no arguments, we'll instead delete all rows
    // with data("delete") in the TR element.  This is much more
    // efficient for deleting a batch of rows, since we only have
    // make one pass through the table.
    deleteOutputs = function(row, num)
    {
        var rows = $("#outputTab .outPortRow");
        var src, dst;

        // check if we're deleting a given block of rows or rows
        // marked with data("delete")
        if (row)
        {
            // deleting a block - note the starting row index
            var delidx = row.data("idx");
            
            // set up pointers to move items down by 'num' rows
            src = rows.eq(delidx - 1 + num);
            dst = rows.eq(delidx - 1);
            
            // move items down
            for ( ; src.data("idx") != "end" && src.find(".pintype").val() != 0 ;
                  src = src.next(), dst = dst.next())
                copyRow(src, dst);
            
            // set the newly unused rows at the end to 'disabled'
            for (var i = 0 ; i < num ; ++i, dst = dst.next())
                setRow(dst, {pintype: 0});

        }
        else
        {
            // Delete all rows marked with data("delete").
            // Scan the rows, stopping when we reach the end or the first unused row.
            src = dst = rows.first();
            for (src = dst = rows.first() ; src.data("idx") != "end" ; src = src.next())
            {
                // if this row isn't marked for deletion, copy it
                if (src.data("delete"))
                {
                    // marked for deletion - don't copy, just remove the marker
                    src.removeData("delete");
                }
                else
                {
                    // this row is to be kept - copy it
                    copyRow(src, dst);
                    dst = dst.next();
                }
            }

            // clear remaining rows
            for ( ; dst.data("idx") != "end" ; dst = dst.next())
                setRow(dst, {pintype: 0});
        }
        
        // fix up for the deletion
        fixUpTable();
    }

    // Move one or more output rows
    moveOutputs = function(fromRow, toRow, num)
    {
        // figure the 'from' index
        var fromIdx = fromRow.data("idx") - 1;

        // figure the 'to' index - if moving to the end, use the first free row
        var toIdx = toRow.data("idx");
        if (toIdx == "end")
            toIdx = findFreeRow().data("idx");
        toIdx -= 1;

        // If we're inserting at the same point, or the insertion point
        // overlaps the deleted area, there's nothing to do
        if (toIdx >= fromIdx && toIdx < fromIdx + num)
            return;

        // make an internal copy of the rows we're moving
        var vals = [];
        var rows = $("#outputTab .outPortRow");
        var cur = rows.eq(fromIdx);
        for (var i = 0 ; i < num ; ++i, cur = cur.next())
        {
            vals.push({
                pintype:  cur.find(".pintype").val(),
                pinval:   cur.find(".pinval").val(),
                pinflags: cur.find(".pinflags").val()
            });
        }

        // delete the rows being moved
        deleteOutputs(fromRow, num);

        // Figure the insertion point.  If this is higher than the
        // 'from' point, adjust it for the deletion we just did.
        if (toIdx > fromIdx)
            toIdx -= num;

        // insert the rows
        insertOutputs(rows.eq(toIdx), vals);
    }
        
    function copyRow(src, dst)
    {
        // copy the row only if the src and dst rows are distinct
        if (src.data("idx") != dst.data("idx"))
        {
            // copy the pin type, pin value, and flags
            dst.find(".pintype").val(src.find(".pintype").val());
            dst.find(".pinval").val(src.find(".pinval").val()).change();
            dst.find(".pinflags").val(src.find(".pinflags").val()).change();

            // fix up any special fields that reference the affected rows
            function update(fld, disable)
            {
                // if we just overwrite the referenced row, disable the reference
                var i = fld.val();
                if (i == dst.data("idx"))
                    disable();
                else if (i == src.data("idx"))
                    fld.val(dst.data("idx")).change();
            }
            update($("#zbPort"), function() {
                $("#zbPort").val(0);
                $("#zbEnabled").prop("checked", false).change();
            });
        }
    }

    function setRow(dst, val)
    {
        dst.find(".pintype").val(val.pintype || 0);
        dst.find(".pinval").val(val.pinval || 0).change();
        dst.find(".pinflags").val(val.pinflags || 0).change();
    }

    // Find the first free row.  This is the first row of type 'disabled'.
    function findFreeRow()
    {
        // filter for disabled rows, then return the first one
        return $("#outputTab .outPortRow").filter(function() {
            return $(this).find(".pintype").val() == 0;
        }).first();
    }

    // fix up the table for an insertion (+1) or deletion (-1)
    function fixUpTable()
    {
        // reset pin warnings
        updatePinWarnings();

        // adjust the table size
        sizeOutputsTable();
    }
})();

// Adjust the display size of the table so that we only show the active
// outputs.  This hides outputs from the first disabled one onward.
function sizeOutputsTable()
{
    // start with items visible
    var disp = "";

    // visit each row
    $("#outputTab .outPortRow").each(function() {
        // If this is the special last row with the "add row at end" control,
        // show it only if the previous row was hidden - once all real rows
        // are shown, we can't add more rows.
        //
        // For all normal rows, if this one is disabled, hide items from here
        // to the end.
        var self = $(this);
        if (self.data("idx") == "end")
            disp = (disp == "none" ? "" : "none");
        else if (self.find(".pintype").val() == 0)
            disp = "none";

        // show or hide this item according to the current status
        self.css("display", disp);
        
        // make sure all hidden rows have pin type 0
        if (disp == "none")
            self.find(".pintype").val(0);
    });

    // show or hide the "+" buttons throughout the table according to whether
    // the last "+" button in the last fake row was available
    $("#outputTab .addRow").css("display", disp);
}

   </script>

<!-- end of main config options section --------------------------------->
</div>

<!-- display raw configuration data for testing purposes -->
<!-- 
<hr>
<div id="rawconfig">
</div>
-->


<!-- navigation footer -------------------------------------------------->
<div id="navproxy"></div>
<div id="nav">
   <div>
      <div class="left">
         <a class="iconButton" href="top.htm" id="mainMenuButton" title="Retourner au menu principal"><img src="homeIcon.png"></a>
         <select id="goToSection">
            <option value="X">on y va...</option>
         </select>
      </div>
      <a class="button" href="#" id="programButton" title="Programmez ces nouveaux paramètres dans le KL25Z">Program KL25Z</a>
      <a class="button" href="#" id="revertButton" title="Annuler les modifications et revenir aux paramètres actuels de l'appareil">Revert</a>
      <div class="right">
         <a class="iconButton" href="#" id="fileOpsButton" title="Enregistrer / restaurer les paramètres vers / depuis un fichier disque"><img src="saveIcon.png"></a>
         <div id="fileOpsMenu" class="popupMenu" style="bottom: 1em; right: 1ex;">
            <div title="Enregistrez ces paramètres en mémoire dans un fichier" id="fileSaveButton">Save to file</div>
            <div title="Charger de nouveaux paramètres en mémoire à partir d'un fichier" id="fileLoadButton">Load file</div>
            <hr>
            <div title="Imprimer cette page" id="printButton">Print...</div>
         </div>
      </div>
   </div>
</div>


<script>

$(function() {
    var lst = [], i = 0;
    $("div.section").each(function() {
        ++i;
        var anchor = "TopSection" + i;
        $(this).prev().before("<a name=\"" + anchor + "\"></a>");
        lst.push("<option value=\"#" + anchor + "\">" + $(this).data("name") + "</option>");
    });
    $("#goToSection").append(lst.join()).change(function(ev) {
        var val = $(this).val();
        if (val != "X") {
            window.navigate(val);
            $(this).val("X");
        }
    });
});

$("#fileOpsButton").click(function(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    var menu = $("#fileOpsMenu");
    menu.css({"display": "inline-block", "bottom": ($(this).outerHeight()/2)  + "px"});
    $("html,body").on("click.fileOpsButton", function() { hide(); });
    function hide() {
        $("html,body").off(".fileOpsButton");
        menu.css("display", "none");
    }
});

$("#mainMenuButton").click(function(ev) {
    if (uiDirty() && !window.external.DiscardCancelDialog(
        "Vous avez apporté des modifications à la configuration qui n’ont pas été "
        + "programmé dans l'appareil ou enregistré dans un fichier de sauvegarde. Si vous"
        + "partez maintenant, vous abandonnerez le travail. Etes-vous sûr de vouloir"
        + "annuler vos modifications?"))
    {
        ev.preventDefault();
        return false;
    }
});
$("#revertButton").click(function(ev) {
    ev.preventDefault();
    if (window.external.DiscardCancelDialog(
        "Ceci supprimera toutes les modifications non enregistrées et reviendra aux paramètres. "
        + "actuellement stocké sur le KL25Z. Voulez-vous vraiment continuer?",
        "&Revert|Cancel"))
        configToUI(config, xconfig, ConfigSource.Board);
});
$("#programButton").click(function(ev) {
    ev.preventDefault();
    programKL25Z();
});

$("#fileSaveButton").click(function(ev) {
    ev.preventDefault();

    // save the configuration and show the result message
    var uic = configFromUI();
    var uicx = xconfigFromUI();
    var result = showCallResult(window.external.WriteConfigFile(
        CPUID, "Note: this is an in-memory working configuration", "browse",
        configToUSB(uic).join(";"), JSON.stringify(uicx)));

    // if we were successful, remember this as the last saved configuration,
    // so that we don't bug the user about saving again if they leave without
    // making any further changes
    if (result.status == "ok") {
        fileConfig = uic;
        fileXConfig = uicx;
    }
});

$("#fileLoadButton").click(function(ev) {
    ev.preventDefault();

    // read a config file
    showCallResult(window.external.ReadConfigFile(CPUID, "browse"), {
        "ok": function(result) {
            // got it - make it active
            configToUI(result.config, result.xconfig, ConfigSource.File);
            window.external.ShowAdviceDialog(
                "RestoreSettings",
                "Les paramètres du fichier ont été chargés. Notez que les nouveaux paramètres "
                + "sont seulement en mémoire - rien n'a encore été changé sur la KL25Z."
                + "Si vous souhaitez activer ces paramètres sur l'appareil, cliquez sur "
                + "le bouton \"Programmer KL25Z \"." );

            // Remember this as the last saved configuration.  If the user
            // quits without making any changes, there's no need to bug them
            // about saving, since they can just load this same file again.
            fileConfig = result.config;
            fileXConfig = result.xconfig;
        }
    });
});

$("#printButton").click(function(ev) {
    ev.preventDefault();
    window.external.PrintPage();
});

</script>


<!-- Flipper Logic options popup ---------------------------------------->
<div class="windowCover">
   <div id="flipperLogicPopup">
      <div>
         Flipper Logic Options
      </div>
      <div>
         <div class="flTime">
            <div>Initial Time<br>(millseconds)</div>
            <div class="flTimeSlider"></div>
            <input type="text" class="flTimeTxt" size="3" readonly>
         </div>
         <div class="flPower">
            <div>Hold Power<br>(percentage)</div>
            <div class="flPowerSlider"></div>
            <input type="text" class="flPowerTxt" size="3" readonly>
         </div>
      </div>
   </div>
</div>


<!-- Chime Logic options popup ------------------------------------------>
<div class="windowCover">
   <div id="chimeLogicPopup">
      <div>
         ChimeLogic Options
      </div>
      <div>
         <div class="minTime">
            <div>Min ON Time<br>(milliseconds)</div>
            <div class="minTimeSlider"></div>
            <input type="text" class="minTimeTxt" size="3" readonly>
         </div>
         <div class="maxTime">
            <div>Max ON Time<br>(milliseconds)</div>
            <div class="maxTimeSlider"></div>
            <input type="text" class="maxTimeTxt" size="3" readonly>
         </div>
      </div>
   </div>
</div>


<!-- Pin and output selector popup -------------------------------------->
<div class="windowCover">
   <div id="pinSelector">
      <div id="gpioSelector" class="pinSelectorPage kl25zPinSelector">
         <div id="lstKL25ZPins" class="pinlist"></div>
         <div id="kl25zPinImg" class="pinimage">
            <div>
               <img src="kl25zPins.png">
               <div id="kl25zOnBoardLED"></div>
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="tlc5940Selector" class="pinSelectorPage tlc5940PinSelector" data-pagetype="chip">
         <div class="chipNo header" data-chip="0">Chip 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <div class="chipIndexer background"></div>
               <div class="chipIndexer foreground"></div>
               <img src="tlc5940Pins.png">
               <div class="pinoverlay"></div>
            </div>
         </div>
      </div>
      <div id="tlc59116Selector" class="pinSelectorPage tlc59116PinSelector" data-pagetype="chip">
         <div class="chipNo header" data-chip="0">Chip 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <div class="chipIndexer background"></div>
               <div class="chipIndexer foreground"></div>
               <img src="tlc59116Pins.png">
               <div class="pinoverlay"></div>
            </div>
         </div>
      </div>
      <div id="hc595Selector" class="pinSelectorPage hc595PinSelector" data-pagetype="chip">
         <div class="chipNo header" data-chip="0">Chip 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <div class="chipIndexer background"></div>
               <div class="chipIndexer foreground"></div>
               <img src="74hc595Pins.png">
               <div class="pinoverlay"></div>
            </div>
         </div>
      </div>

      <div id="mainBoardDigitalOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">JP9</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <img src="mainBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="mainBoardPWMOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pwm="true" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Flashers</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <img src="mainBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="aioBoardDigitalOutputSelector" class="pinSelectorPage aioBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Sorties numériques</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <img src="aioBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="aioBoardPWMOutputSelector" class="pinSelectorPage aioBoardPinSelector" data-pwm="true" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Sorties PWM</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <img src="aioBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="liteBoardDigitalOutputSelector" class="pinSelectorPage liteBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Sorties numériques</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <img src="liteBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="liteBoardPWMOutputSelector" class="pinSelectorPage liteBoardPinSelector" data-pwm="true" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Sorties PWM</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <img src="liteBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="mainBoardInputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">N/C</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <img src="mainBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="aioBoardInputSelector" class="pinSelectorPage aioBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">N/C</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <img src="aioBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="liteBoardInputSelector" class="pinSelectorPage liteBoardPinSelector" data-pagetype="board">
          <div class="chipNo header" data-chip="0">N/C</div>
          <div class="pinlist"></div>
          <div class="pinimage">
             <div>
                 <img src="liteBoardPins.png">
                 <div class="pinoverlay"></div>
             </div>
          <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
          </div>
      </div>
      <div id="powerBoardOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Carte 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <div class="chipIndexer background"></div>
               <div class="chipIndexer foreground"></div>
               <img src="powerBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="chimeBoardOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">CArte 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div>
               <div class="chipIndexer background"></div>
               <div class="chipIndexer foreground"></div>
               <img src="chimeBoardPins.png">
               <div class="pinoverlay"></div>
            </div>
            <div class="pinLegend"><img src="KL25Z-pin-legend.png"></div>
         </div>
      </div>
      <div id="virtualOutputSelector" class="pinSelectorPage">
         <div>
            Une sortie "virtuelle" est un port logiciel qui n'est pas connecté à
            une sortie physique. Cela peut être utilisé comme espace réservé dans votre
            Configuration DOF, ou pour une fonction spéciale, telle que le ZB Launch Ball
            port de contrôle.
         </div>
         <div>
            <div class="iconWithTitle button available" data-pin="NC "id="btnMakeVirtualPort">
               <img src="virtualOutSmall.png">
               <br>Virtual
            </div>
            <div class="iconWithTitle button available" data-pin="NC" id="btnMakeZBPort">
               <img src="zbLaunch32.png">
               <br>Port ZB Launch
            </div>
         </div>
      </div>
      <div id="pinTypeSelector">
         <div id="pinTypePwmOut" data-page="gpioSelector" data-filter="pwm" data-pintype="1">
            <img src="pwmout.png"><br>
            GPIO<br>
            Sortie PWM
         </div>
         <div id="pinTypeDigOut" data-page="gpioSelector" data-filter="dig-out" data-pintype="2">
            <img src="digitalout.png"><br>
            GPIO<br>
            Sortie Numérique
         </div>
         <div id="pinTypeSpiMosi" data-page="gpioSelector" data-filter="spi-mosi">
            <img src="spiout.png"><br>
            SPI (MOSI)
         </div>
         <div id="pinTypeSpiSclk" data-page="gpioSelector" data-filter="spi-sclk">
            <img src="spiout.png"><br>
            SPI (SCLK)
         </div>
         <div id="pinTypeAnalogIn" data-page="gpioSelector" data-filter="adc">
            <img src="analogin.png"><br>
            Entrée analogique
         </div>
         <div id="pinTypeDigIn" data-page="gpioSelector" data-filter="dig-in">
            <img src="digitalin.png"><br>
            Entrée numérique
         </div>
         <div id="pinTypeInterruptIn" data-page="gpioSelector" data-filter="interrupt-in">
            <img src="interruptin.png"><br>
            Interrompre
         </div>
         <div id="pinType5940Out" data-page="tlc5940Selector" data-pintype="3">
            <img src="tlc5940out.png"><br>
            Sortie TLC5940
         </div>
         <div id="pinType59116Out" data-page="tlc59116Selector" data-pintype="6">
            <img src="tlc59116out.png"><br>
            Sortie TLC59116
         </div>
         <div id="pinType595Out" data-page="hc595Selector" data-pintype="4">
            <img src="74hc595out.png"><br>
            Sortie 74HC595
         </div>
         <div id="pinTypeMainBoardPWMOut" data-page="mainBoardPWMOutputSelector" data-pintype="1">
            <img src="mainBoardOut.png"><br>
            Carte principale <br> sortie PWM
         </div>
         <div id="pinTypeMainBoardDigitalOut" data-page="mainBoardDigitalOutputSelector" data-pintype="2">
            <img src="mainBoardOut.png"><br>
            Carte principale <br> Sortie numérique
         </div>
         <div id="pinTypeAIOBoardPWMOut" data-page="aioBoardPWMOutputSelector" data-pintype="1">
            <img src="aioBoardOut.png"><br>
            Pinscape AIO <br> Sortie PWM
         </div>
         <div id="pinTypeAIOBoardDigitalOut" data-page="aioBoardDigitalOutputSelector" data-pintype="2">
            <img src="aioBoardOut.png"><br>
            Pinscape AIO <br> Sortie numérique
         </div>
            <div id="pinTypeLiteBoardPWMOut" data-page="liteBoardPWMOutputSelector" data-pintype="1">
                <img src="liteBoardOut.png"><br>
                Pinscape Lite <br> Sortie PWM
            </div>
            <div id="pinTypeLiteBoardDigitalOut" data-page="liteBoardDigitalOutputSelector" data-pintype="2">
                <img src="liteBoardOut.png"><br>
                Pinscape Lite <br> Sortie numérique
            </div>
         <div id="pinTypeMainBoardIn" data-page="mainBoardInputSelector">
            	<img src="mainBoardIn.png"><br>
            	CArte Principale
         </div>
         <div id="pinTypeAIOBoardIn" data-page="aioBoardInputSelector">
            	<img src="aioBoardIn.png"><br>
            	Pinscape AIO
         </div>
            <div id="pinTypeLiteBoardIn" data-page="liteBoardInputSelector">
                <img src="liteBoardIn.png"><br>
                Pinscape Lite
            </div>
         <div id="pinTypePowerBoardOut" data-page="powerBoardOutputSelector">
            	<img src="powerBoardOut.png"><br>
            	Carte d'alimentation
         </div>
         <div id="pinTypeChimeBoardOut" data-page="chimeBoardOutputSelector">
            	<img src="chimeBoardOut.png"><br>
            	Carte carillon
         </div>
         <div id="pinTypeVirtOut" data-page="virtualOutputSelector" data-pintype="5">
            	<img src="virtualout.png"><br>
            	Sortie Virtuelle
         </div>
      </div>
   </div>
</div>



<!-- IR command selector popup ------------------------------------------>
<div class="windowCover">
   <div id="IRCommandSelector">
      <div>
         <div>
            <div id="IRCommandList">
            </div>
         </div>
      </div>
   </div>
</div>


<!-- key selector popup ------------------------------------------------->
<div class="windowCover">
   <div id="keySelector">
      <div>
         <div>
            <div id="oskeyboard">
            </div>
            <div id="osunused">
               <div>
                  Sélectionnez cette option si vous ne souhaitez pas que le bouton envoie
                  n'importe quelle entrée du PC lorsque vous appuyez sur.
               </div>
               <div id="unusedBtn" class="iconWithTitle">
                  <img src="noKey.png">
                  <br>Pas d'entrée PC
               </div>
            </div>
            <!-- 
            <div id="osspecial">
               <div>
                  Sélectionnez des fonctions spéciales pour la touche, distinctes de
                  toute entrée PC.
               </div>
               <div id="nightModeBtn" class="iconWithTitle"
                 title="Utilisez ce bouton pour activer et désactiver le mode nuit">
                  <img src="nightModeSmall.png">
                  <br>Mode nuit
               </div>
            </div>
            -->
            <div id="osjoystick">
               <div class="topfill">
                  Boutons Joystick
               </div>
               <div class="jsBtnBox">
               </div>
            </div>
         </div>
         <div id="keytype">
            <img id="keytypeJS" data-page="#osjoystick" title="Boutons Joystick" src="joystickicon.png">
            <img id="keytypeKB" data-page="#oskeyboard" title="Touches du clavier" src="keyboardicon.png">
            <img id="keytypeUnused" data-page="#osunused" title="Pas d'entrée PC" src="noKey.png">
            <!-- <img id="keytypeSpecial" data-page="#osspecial" title="Fonction spéciale" src="specialicon.png"> -->
         </div>
      </div>
   </div>
</div>


<!-- main scripts ------------------------------------------------------->

<script>

// CPUID for the device - obtained from the URL parameters
var CPUID;

// DeviceInfo object for the current device
var deviceInfo;

// Current device source configuration.  This is the last configuration
// we loaded from the device.
var config = { };

// Current external configuration.  This is the last xconfig loaded.
// The xconfig is stored in the local PC file system, not on the device.
// It contains settings that aren't needed at run-time on the device
// and would take up too much memory to justify storing in the device
// flash, such as description strings for the stored IR commands and
// the output ports.
var xconfig = { };

// Current saved file configuration.  This is the last configuration
// we saved to a file or loaded from a file.
var fileConfig = { };
var fileXConfig = { };

// Program the current UI settings into the KL25Z
function programKL25Z()
{
    // check for pin assignment conflicts
    var w = getPinWarnings();
    if (w.length && !window.external.YesNoDialog(
        "Les éléments suivants ont des affectations de broches conflictuelles: \r\n\r\n"
        + $.map(w, function(ele) { return ele.data("desc"); }).join("; ")
        + "\r\n\r\n"
        + "Le contrôleur peut ne pas fonctionner correctement si vous le programmez avec "
        + "ces conflits non résolus. Êtes-vous sûr de vouloir continuer?"))
        return;

    // now warn about overwriting the settings
    if (!window.external.YesNoDialog(
        "Cela programmera la KL25Z avec les nouveaux paramètres que vous avez sélectionnés. "
        + "Les paramètres précédents seront définitivement écrasés. Êtes-vous"
        + "bien sûr que vous souhaitez continuer?"))
        return;

    // get the current UI configuration, and convert it to USB format
    var usb = configToUSB(configFromUI()).join(";");

    // get the current UI external config, and convert to JSON format
    var cx = JSON.stringify(xconfigFromUI());

    // save a backup copy first
    showCallResult(window.external.WriteConfigFile(
        CPUID, "Remarque: il s'agit d'une configuration de travail en mémoire",
        "backup", usb, cx),
        { "ok": function() { } }
    );

    // send the configuration to the KL25Z and display the result
    var res = showCallResult(window.external.PutDeviceXConfig(CPUID, cx), {
        "ok": function() {
            var res = showCallResult(window.external.PutDeviceConfig(CPUID, usb));
            if (res.status == "ok")
                waitForReboot(CPUID);
        }
    });
}

// On closing the window, the C# container calls this custom method.
// We can return the string "cancel" to stop the event.
function OnCloseWindow()
{
    if (uiDirty() && !window.external.DiscardCancelDialog(
        "Vous avez apporté des modifications à la configuration qui n'ont pas été "
        + "programmé dans l'appareil ou enregistré dans un fichier de sauvegarde."
        + "Arrêter maintenant abandonnera le travail. Voulez-vous vraiment"
        + "annuler ces modifications?"))
        return "cancel";
}

// Check for changes between the UI and device configuration
function uiDirty()
{
    // get the current UI configuration, normalized for comparison purposes
    var uic = normalizeConfig(configFromUI());
    var uixc = normalizeXConfig(xconfigFromUI());

    // if it matches the device configuration or the last configuration
    // saved or loaded from a file, it's not dirty
    return !(valEq(uic, normalizeConfig(config)) || valEq(uic, normalizeConfig(fileConfig)))
        || !(valEq(uixc, normalizeXConfig(xconfig)) || valEq(uic, normalizeXConfig(fileXConfig)));
}

// Compare two values, doing a deep comparison of properties of objects
function valEq(a, b)
{
    // NaN == NaN requires a special test
    if (isNaN(a) && isNaN(b) && typeof a == "number" && typeof b == "number")
        return true;
    
    // if they're identical primitives, they're equal
    if (a === b)
        return true;
    
    // compare certain non-primitive object types by string value
    if ((typeof a == "function" && typeof b == "function")
        || (a instanceof Date && b instanceof Date)
        || (a instanceof RegExp && b instanceof RegExp)
        || (a instanceof String && b instanceof String)
        || (a instanceof Number && b instanceof Number))
    {
        return a.toString() === b.toString();
    }

    // if they're arrays, check them recursively
    if ($.isArray(a) && $.isArray(b))
    {
        // if the arrays aren't of equal length, they differ
        var l = a.length;
        if (b.length != l) {
            // alert("a.length != b.length"); // [debug]
            return false;
        }

        // the lengths match; compare each element
        for (var i = 0 ; i < l ; ++i)
        {
            if (!valEq(a[i], b[i])) {
                // alert("a[" + i + "] != b[" + i + "]"); // [debug]
                return false;
            }
        }
    }
    
    // if they're objects, check them recursively
    if (typeof a == "object" && typeof b == "object")
    {
        // check that all properties of a are in b
        for (var p in a) {
            if (!(p in b)) {
                // alert("p not in b: " + p); // [debug]
                return false;
            }
        }

        // all a.p are in b; now check that all b.p equal a.p
        for (var p in b) {
            if (!(p in a) || !valEq(a[p], b[p])) {
                // alert((p in a) ? "vals differ: " + p : "p not in a: " + p); // [debug]
                return false;
            }
        }

        // no differences found
        return true;
    }
    
    // consider anything else unequal
    return false;
}

// page initialization
$(function() {

    // note the browser scrollbar width
    var sbwid = getScrollBarWidth();

    // set up DOF Config Tool links
    $("a.dofconfigtool")
        .attr("href", "http://configtool.vpuniverse.com/")
        .attr("target", "_blank");

    // Initialize the pin selector dialog
    pinSelectorSetup();

    // initialize the config functions
    configFunctionSetup();

    // set up number input "spinner" controls
    $("#numMainBoards,#numPowerBoards,#numChimeBoards").spinner({min: 0, max: 8});
    $("#txtRebootTime").spinner({min: 1, max: 255});
    $("#zbPort").spinner({min: 1, max: 128});
    $("#tlc_nchips").spinner({min: 0, max: 8});
    $("#hc595_nchips").spinner({min: 0, max: 8});
    $("#nightModeOutputNo").spinner({min: 0, max: 128});
    $("#shiftButton, #nightModeButtonNo").spinner({min: 0, max: 128});
    $("#accelAutoCenterTime").spinner({min: 1, max: 60});
    $("#tvDelay").spinner({min: 1, max: 60});

    // set spinner change listeners
    $("#numMainBoards, #numPowerBoards, #numChimeBoards, #zbPort, #tlc_nchips, "
      + "#hc595_nchips, #nightModeButtonNo, #nightModeOutputNo, #shiftButton").on(
        "spinstop", function() { $(this).change(); });

    // Retrieve the device ID from the URL.  The ID= parameter encodes
    // the KL25Z CPU ID, which we use as the primary key to identify
    // the device through the C# callback API.  This is effectively a
    // GUID for the device - it's permanently fixed in the device (in
    // ROM set at the factory), and it's guaranteed to be unique among
    // all Freescale devices.
    if (/[?&]ID=([\da-f\-]+)/i.test(window.location.href))
    {
        // set the CPU ID
        CPUID = RegExp.$1;
        $("#CPUID").text(CPUID);

        // get the device info
        function formatCommas(s) { return s.toString().replace(/(\d)(\d\d\d)$/, "$1,$2"); }
        function formatByteSize(s)
        {
            if (s < 1024) return formatCommas(s);
            if (s < 10*1024) return (s/1024).toFixed(1).toString() + "K bytes";
            return Math.round(s/1024) + "K bytes";
        }
        deviceInfo = eval(window.external.GetDeviceInfo(CPUID)) || { FreeHeapBytes: 0 };
        if (deviceInfo.FreeHeapBytes) {
            $("#usedHeapBytes").text(formatByteSize(16*1024 - deviceInfo.FreeHeapBytes));
            $("#freeHeapBytes").text(formatCommas(deviceInfo.FreeHeapBytes));
            $("#heapInfo").show();
        }

        // show the appropriate sections for the new accelerometer features
        $("#newAccelFeatures").toggle(!!deviceInfo.AccelFeatures);
        $("#noNewAccelFeatures").toggle(!deviceInfo.AccelFeatures);

        // show the appropriate sections for the joystick report timing features
        $("#jsReportTiming, #accelStutter").toggle(!!deviceInfo.ReportTimingFeatures);

        // loop until we get the configuration or the user cancels
        for (;;)
        {
            // retrieve the current device configuration
            var c = window.external.GetDeviceConfig(CPUID);
            var xc = window.external.GetDeviceXConfig(CPUID);

            // check if we got a result
            var errmsg = null;
            if (c)
            {
                // parse the config data
                config = eval(c);

                // if there's no error code, we have valid config data
                if (!(errmsg = config.error))
                    break;

                // wrap the error in parens for display
                errmsg = " (" + errmsg + ")";
            }

            // failed - ask if they want to try again
            if (!window.external.RetryCancelDialog(
                "An error occurred loading the device settings" + errmsg
                + ". Do you want to try again?"))
            {
                // cancel - set a timeout to navigate back to the main menu
                setTimeout(function() { window.navigate("top.htm"); }, 1);

                // no need to do any more page initialization, as we're not staying
                return;
            }
        }
        
        // parse the xconfig data
        xconfig = JSON.parse(xc);

        // display the raw configuration in the debugging section, if present
        $("#rawconfig").text(c);

        // load the config into the UI
        configToUI(config, xconfig, ConfigSource.Board);

        // show the appropriate sections for the IR features
        $("#irRemotePins, #irCommands").toggle(!!config.IRRemote);
        $("#noIrRemotePins").toggle(!config.IRRemote);

        // if the shift button isn't supported, hide the shift button sections
        if (!("shiftButton" in config)) {
            $("#shiftButton").val(0).change();
            $("#shiftButtonSetup, #buttonTab .shiftCol").hide();
        }

        // remove the UI blocker for loading
        $("#loadingOverlay").parent().hide();
    }

    function pinSelectorSetup()
    {
        // get the dialog
        var pindlg = $("#pinSelector");

        // Set up button objects on top of the KL25Z popup image.  This
        // allows selecting pins by pointing to them on the picture.
        var btndiv = $("#kl25zPinImg .pinoverlay");
        $.each(kl25z_headers, function(k, v) {
            forEachPin(v, function(pin, n, x, y) {
                // find the gpioPin entry for the pin
                var g = (gpioPinsByName[pin] || { });
                var jumper = g.internalShortName || k + "-" + n;
                var hover = pin + " (" + jumper + ")";
                
                // Build the pin button overlays
                var posname = k + "-" + n;
                btndiv.append(
                    "<div class=\"pinButton\" "
                    + "data-pin=\"" + pin + "\" "
                    + "data-hovername=\"" + hover + "\" "
                    + "title=\"" + pin + (posname != "N/A" ? " (" + posname + ")\" " : "")
                    + "style=\"left: " + x + "px; top: " + y + "px;\">"
                    + "</div>");

                // set the header reference in the GPIO pin entry
                if (g)
                    g.pin = { name: posname, x: x, y: y };
            })
        });

        // Build the KL25Z pin selection list
        var pinlst = $("#lstKL25ZPins");
        var options = [];
        options.push("<div data-pin=\"Not Connected\">Not Connected</div>");
        for (var i = 0 ; i < gpioPins.length ; ++i)
        {
            var g = gpioPins[i];
            var hovername = g && (g.internalShortName || g.pin && g.pin.name);
            hovername = hovername && "data-hovername=\"" + hovername + "\"";

            options.push(
                "<div data-pin=\"" + g.name + "\" " + hovername + "\">"
                + g.name + "</div>");
        }
        pinlst.html(options);

        // add event handlers the KL25Z GPIO pin list elements and image buttons
        addPinEvents(pinlst, $("#kl25zPinImg"), $("#kl25zPinImg .pinButton, #lstKL25ZPins > div"));

        // Add hover and click handlers to pin list items or gpio pins.
        // 'list' is a jquery set with the container for the pin listbox list
        // 'picdiv' is a jquery set with the graphical pin container.
        // 'items' is a jquery set with the list items and/or pins to
        //    set up with event handlers.
        function addPinEvents(list, picdiv, items)
        {
            // add hover handlers to the list items
            items.off("mouseenter mouseleave click").hover(
                function() {
                    // remove 'hover' status from all pins and list items
                    list.children().removeClass("hover");
                    picdiv.find(".pinButton").removeClass("hover");

                    // sync the list and pin pad image if the pin is available
                    var self = $(this);
                    if (self.hasClass("available"))
                    {
                        // get this pin name
                        var pin = self.data("pin");
                        var finder = function() { return $(this).data("pin") == pin; }
                        
                        // set hover state on the matching list item and pin button
                        picdiv.find(".pinButton").filter(finder).addClass("hover");
                        var listele = list.children().filter(finder);
                        listele.addClass("hover");

                        // if this is one of the on-board LED pins, turn on the LED
                        // display to the appropriate color while hovering
                        var g = gpioPinsByName[pin];
                        if (g && g.onBoardLED) {
                            $("#kl25zOnBoardLED").css(
                                "background-position", "0px " + (-g.onBoardLED*40) + "px");
                        }
                        
                        // If the event is from an image button, scroll the list item
                        // into view after a brief delay.  The delay is to avoid making
                        // the list jump around when the mouse sweeps over the pin image
                        // on its way somewhere else - we only scroll the list when the
                        // mouse is at least briefly stationary over a pin.
                        if (self.hasClass("pinButton") && self.hasClass("available"))
                        {
                            // set a sequence number to compare when the timeout expires
                            var seqno = 1 + (self.data("hoverseq") || 0);
                            self.data("hoverseq", seqno);
                            
                            // Set a timeout for the delay.  When it expires, it we're
                            // still hovering over the same item and the sequence number
                            // is the same, do the scrolling.  If we're not still hovering,
                            // it means that the mouse has left since we started the timer,
                            // so don't do the scrolling after all.  If the sequence number
                            // has changed, it means that the mouse has left and come back,
                            // in which case the mouse hasn't been stationary for the whole
                            // interval and hence we don't want to do the scrolling.
                            setTimeout(function() {
                                if (self.hasClass("hover") && self.data("hoverseq") == seqno)
                                    scrollIntoView(listele, 100, { top: list.prev(".header").outerHeight() });
                            }, 250);
                        }
                    }
                },
                function() {
                    // get the pin name
                    var pin = $(this).data("pin");
                    var finder = function() { return $(this).data("pin") == pin; };

                    // turn off the on-board LED if it was on
                    var g = gpioPinsByName[pin];
                    if (g && g.onBoardLED)
                        $("#kl25zOnBoardLED").css("background-position", "0px 0px");

                    // remove hover state from the list item and image button
                    picdiv.find(".pinButton").filter(finder).removeClass("hover");
                    list.children().filter(finder).removeClass("hover");
                }

            ).click(function() {
                // on click, select the item and dismiss the dialog
                pinselect($(this), false, true);
            });
        }

        // click the "Mark Virtual" button on the virtual output type page
        $("#btnMakeVirtualPort").click(function(ev) {
            ev.preventDefault();
            pinselect($(this), false, true);
        });

        // click the "Make ZB port" button on the virtual output type page
        $("#btnMakeZBPort").click(function(ev) {
            ev.preventDefault();
            $("#zbEnabled").prop("checked", true).change();
            $("#zbPort").val(curpin.parents(".outPortRow").data("idx")).change();
            pinselect($(this), false, true);
        });

        // table of pin adjustor functions for the various pages
        var chipPinPageAdjustor = { };

        // generate a list a..b (for chip indexers)
        function ordinals(a, b)
        {
            for (var l = [], i = a ; i <= b ; l.push(i++)) ;
            return l;
        }

        // set up the TLC5940 selection list and image buttons
        initChipPinPageAdjustor(
            "tlc5940Selector", "3",
            function() { return ordinals(0, $("#tlc_nchips").val() - 1); },
            16, "Chip 1", 1);
        buildChipPinButtons($("#tlc5940Selector"), tlc5940_pins, "3", 10, 16);
        
        // Build the 74HC595 selection list and image buttons
        initChipPinPageAdjustor(
            "hc595Selector", "4",
            function() { return ordinals(0, $("#hc595_nchips").val() - 1); },
            8, "Chip 1", 1);
        buildChipPinButtons($("#hc595Selector"), hc595_pins, "4", 20, 20);

        // build the TLC59116 selection list and image buttons
        initChipPinPageAdjustor(
            "tlc59116Selector", "6",
            function() {
                return $("#tlc59116_chipsEnabled input:checked")
                    .map(function() { return $(this).data("address"); })
                    .get();
            }, 16, "Chip 0 ($4b)", 0);
        buildChipPinButtons($("#tlc59116Selector"), tlc59116_pins, "6", 10, 16);

        // Get an adjustor function for a chip pin list.  Call the function
        // on opening the dialog page to populate the list with new pins
        // as needed.
        function initChipPinPageAdjustor(pageName, pintype, chipListFunc, pinsPerChip, groupHeader, labelBase)
        {
            // set up the adjustor function, and store it in the table so
            // that showChipPinPage() can automatically call it
            chipPinPageAdjustor[pageName] = function()
            {
                // get the new chip list
                var chipList = chipListFunc();

                // populate new chip pages
                var page = $("#" + pageName);
                buildChipPinList(page, pintype, chipList, pinsPerChip, groupHeader, labelBase);
                
                // hide chips and pins that aren't currently available
                page.find(".chipNo:not(.header), .chipPin").each(function() {
                    var self = $(this);
                    self.toggle(chipList.indexOf(+self.data("chip")) >= 0);
                });
            };
        }

        // Build the pin image buttons for a chip layout
        function buildChipPinButtons(page, pins, pintype, wid, ht)
        {
            // get the image padding
            var picdiv = page.find(".pinimage");
            var btndiv = picdiv.find(".pinoverlay");
            var img = picdiv.find("img");

            // add each pin
            forEachPin(pins, function(pin, n, x, y)
            {
                // only the OUTn pins are available as outputs
                var available = /^OUT(\d+)$/i.test(pin);
                var pinno = (available ? RegExp.$1 : "");
                
                // add the button
                btndiv.append(
                    "<div class=\"pinButton " + (available ? "available" : "") + "\" "
                    + (available ?
                       "data-pin=\"" + pinno + "\" data-basepin=\"" + pinno + "\" "
                       + "data-pintype=\"" + pintype + "\" data-hovername=\"" + pin + "\" "  :
                       "")
                    + "title=\"" + pin + "\" "
                    + "style=\"left: " + x + "px; top: " + y + "px;\">"
                    + "</div>");
            });

            // add hover and click handlers to the image buttons
            addPinEvents(page.find(".pinlist"), picdiv, picdiv.find(".pinButton"));
        }

        // Build one of the chip pin lists (TLC5940, 74HC595, TLC59116)
        function buildChipPinList(page, pintype, chipList, pinsPerChip, groupHeader, labelBase)
        {
            // Build a section for each copy of the chip.  Internally, the
            // pins are numbered consecutively across chips starting at 0 for
            // the first pin on the first chip.
            buildGroupedPinList(
                page,
                [{ groups: chipList, pins: pinsPerChip,
                   header: groupHeader, pinname: "OUT0", pintype: pintype }
                ]);

            // build the chip indexer
            buildChipIndexer(page, chipList, pinsPerChip, labelBase);
        }

        // Build a chip/board indexer for an output selector page that can have
        // multiple copies of the chip/board.  
        function buildChipIndexer(page, chipList, pinsPerChip, labelBase)
        {
            // build the list of chip index buttons
            var idxlst = [];
            for (var i = 0 ; i < chipList.length ; ++i)
            {
                idxlst.push(
                    "<div data-idx=\"" + chipList[i] + "\">"
                    + (chipList[i] + labelBase)
                    + "</div>");
            }
                                       
            // Build the chip index buttons.  This allows selecting among
            // multiple copies of the chip in the graphical pin layout view.
            var picdiv = page.find(".pinimage");
            picdiv.find(".chipIndexer.foreground").html(idxlst);
            
            // Add click handlers for the indexer buttons
            picdiv.find(".chipIndexer.foreground div").click(function(ev) {
                switchChip(page, $(this).data("idx"), pinsPerChip);
            });
        }
                
        // Build a grouped pin list.
        //
        // 'page' is the selector page element.
        //
        // 'sections' is a list of pin sections descriptor objects:
        //
        //     .groups = list of index values for chip/board groups
        //     .pins = number of pins in each copy of the section
        //     .header = function(copyIndex) returning header name string
        //     .pinname = function(pinIndex, copyIndex) returning pin name string
        //     .pinid = function(pinIndex, copyIndex) returning the data-pin value
        //     .pintype = default pin type code for the pins in this group, used if
        //         the .pinid value doesn't have a type prefix
        //     .hovername = function(pinName, pinIndex, copyIndex) returning the hover
        //         name for the list item; pinName is the name returned by .pinname
        //
        // groups is a list of index values for chips and boards that can have
        // multiple copies.  For example, we can have several TLC5940 chips in the
        // system, in which case 'groups' is a list of the chip index values.  For
        // daisy-chained chips or boards, this is simply the ordinal list starting
        // at 0, as in [0, 1, 2, 3] for a four-chip system.  For addressable chips
        // (e.g., TLC59116), this is a list of the address values.
        //
        // header, pinname, and pinid can be simple strings instead of functions.
        // In this case, '0' and '1' are replaced with the 0-based or 1-based index
        // for (respectively) the item (copy number in the case of the header, pin
        // number in the case of the pin name or ID).  The special syntax '$b' is
        // replaced by a binary version of the 0-based index value; '$4b' means
        // that the result should be left-padded with zeroes to four characters
        // (e.g., '$4b' with input value 3 produces '0011').
        //
        // If pinid isn't specified, the default is the current *overall* pin
        // number, starting at 0 for the first pin on the first chip/board, and
        // incrementing once per pin, continuously across chips/boards.  E.g.,
        // if there are 8 pins per chip, the first chip's pins are numbered 0-7,
        // the second 8-15, etc.
        //
        // The pinid value can be specified with or without an output type prefix.
        // If provided, the type prefix follows our normal convention: USB type code
        // + "." + pin name.  E.g., GPIO Digital Out PTC8 is "2.PTC8".  If the type
        // isn't provided, we simply use the type code from the page for all pins.
        function buildGroupedPinList(page, sections)
        {
            // get the container
            var list = page.find(".pinlist");

            // run through the sections to add
            $.each(sections, function(sectionIdx, section)
            {
                // Get the header function.  If it's specified as a string, set up
                // a function that replaces 0 or 1 in the string with the copy index.
                var header = section.header;
                if (typeof header == "string") {
                    header = function(itemIndex) {
                        return section.header.replace(/[01]|\$\d+b/gi, function(m) {
                            if (/\$(\d+)b/i.test(m)) {
                                m = itemIndex.toString(2);
                                return "00000000000000000000000000000000".substr(0, +RegExp.$1 - m.length) + m;
                            }
                            else
                                return (+m) + itemIndex;
                        });
                    };
                }

                // Get the pin name function, providing a string substitution function
                // if needed.
                var pinname = section.pinname;
                if (typeof pinname == "string") {
                    pinname = function(pinIndex, itemIndex) {
                        return section.pinname.replace(/[01]/, function(m) { return (+m) + pinIndex; });
                    };
                }

                // Get the pin ID function, providing a substitution function
                var pin = 0;
                var pinid = section.pinid;
                if (typeof pinid == "undefined") {
                    pinid = function(pinIndex, itemIndex) { return pin; };
                }
                else if (typeof pinid == "string") {
                    pinid = function(pinIndex, itemIndex) {
                        return section.pinid.replace(/[01]/, function(m) { return (+m) + pinIndex; });
                    };
                }

                // make a list of the sections already populated
                var existing =
                    list.find(".chipNo")
                    .filter(function() { return $(this).data("sectionindex") == sectionIdx; });
                var existingIdx =
                    existing.map(function() { return $(this).data("chip"); })
                    .get();

                // run through the chips/boards in this section
                for (var i = 0, pin = 0, groups = section.groups ; i < groups.length ; ++i)
                {
                    // start with an empty insertion list for this chip/board
                    var html = [];

                    // get this item's chip index/address
                    var addr = groups[i];

                    // figure the starting pin number on this chip, assuming that
                    // pins are numbered sequentially across chips
                    pin = addr * section.pins;

                    // if this chip/board is already populated, skip it
                    if (existingIdx.indexOf(addr) >= 0)
                        continue;
                
                    // add the section header
                    html.push("<div class=\"chipNo\" "
                              + "data-sectionindex=\"" + sectionIdx + "\" "
                              + "data-chip=\"" + addr + "\">"
                              + header(addr)
                              + "</div>");

                    // add each pin in the section
                    for (var j = 0 ; j < section.pins ; ++j, ++pin)
                    {
                        // Get the pin ID
                        var curPinId = pinid(j, addr);

                        // get the hover name, if any
                        var hover = section.hovername && section.hovername(curPinId, j, addr);

                        // If the pin ID has a type prefix ("number."), pull it out
                        // for a data-pintype attribute
                        var curPinType = section.pintype;
                        if (/^(\d+)\.(.*)$/.test(curPinId)) {
                            curPinType = RegExp.$1;
                            curPinId = RegExp.$2;
                        }

                        // generate the list entry
                         html.push("<div class=\"chipPin available\" "
                                  +   "data-pin=\"" + curPinId + "\" "
                                  +   "data-pintype=\"$1\" ".formatOrEmpty(curPinType)
                                  +   "data-hovername=\"$1 \" ".formatOrEmpty(hover)
                                  +   "data-chip=\"" + addr + "\">"
                                  +   pinname(j, addr)
                                  + "</div>");
                    }

                    // find the lowest existing section after this section
                    var nxt = existing.filter(function() { return +$(this).data("chip") > addr; }).last();
                    if (nxt.length)
                        nxt.before(html);
                    else
                        list.append(html);
                }
            });
                
            // initialize scrolling headers
            initScrollHeader(list, list.find(".chipNo"));
            
            // Attach hover and click handlers to the pin list items
            var picdiv = page.find(".pinimage");
            addPinEvents(list, picdiv, list.find(".chipPin"));
        }

        // figure the hover name for a main board pin list item
        function mainBoardHoverName(pin)
        {
            // if there's an out port alias, return the jumper entry
            var alias = outPortAlias[pin];
            return alias ? alias.split("|")[3] : undefined;
        }

        // figure the hover name for a main board pin list item
        function aioBoardHoverName(pin)
        {
            // if there's an out port alias, return the jumper entry
            var alias = outPortAlias[pin];
            return alias ? alias.split("|")[3] : undefined;
        }

        // figure the hover name for a main board pin list item
        function liteBoardHoverName(pin)
        {
            // if there's an out port alias, return the jumper entry
            var alias = outPortAlias[pin];
            return alias ? alias.split("|")[3] : undefined;
        }

        // Build the main board digital output list
        buildGroupedPinList($("#mainBoardDigitalOutputSelector"), [
            { groups: [0], pins: 1, header: "Knocker",
              pinname: function(pin) { return ["Knocker"][pin]; },
              pinid: function(pin) { return ["2.PTC8"][pin] },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 4, header: "Extender", pinname: "Extender 1",
              pinid: function (pin) { return ["2.PTC4", "2.PTC3", "2.PTC0", "2.PTA2"][pin]; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 6, header: "Plunger",
              pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button", "Cal LED"][pin]; },
              pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29", "PTE23"][pin]; },
              hovername: mainBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#mainBoardDigitalOutputSelector"), mainBoard_headers, true, expGpioPortAlias, expOutPortAlias);


        // Build the Pinscape AIO board digital output list
        buildGroupedPinList($("#aioBoardDigitalOutputSelector"), [
            { groups: [0], pins: 1, header: "Knocker",
              pinname: function(pin) { return ["Knocker"][pin]; },
              pinid: function(pin) { return ["2.PTC8"][pin] },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 8, header: "Chime Outputs",
              pinname: function(pin) { return "Output " + (pin + 1); },
              pinid: function(pin) { return "4." + pin; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 4, header: "Expansion Port", pinname: "Expansion Port",
              pinname: function(pin) { return ["Expansion C4", "Expansion C3", "Expansion C0", "Expansion A2"][pin]; },
              pinid: function (pin) { return ["2.PTC4", "2.PTC3", "2.PTC0", "2.PTA2"][pin]; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 4, header: "Plunger",
              pinname: function(pin) { return ["Plunger SDA", "Plunger CHA/SCL", "Plunger CHB", "Plunger Wiper/INT"][pin]; },
              pinid: function(pin) { return ["PTE20", "PTE21", "PTE22", "PTB0"][pin]; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 2, header: "Calibration",
              pinname: function(pin) { return ["Calibration A", "Calibration LED-"][pin]; },
              pinid: function(pin) { return ["PTE29", "PTE23"][pin]; },
              hovername: aioBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#aioBoardDigitalOutputSelector"), aioBoard_headers, true, aioGpioPortAlias, aioOutPortAlias);

        // Build the Pinscape Lite board digital output list
        buildGroupedPinList($("#liteBoardDigitalOutputSelector"), [
            { groups: [0], pins: 10, header: "Digital Outputs",
              pinname: function(pin) { return ["Power 3", "Power 4", "Power 5", "Power 6", "Power 7", "Power 8", "Power 9", "Power 10", "Power 11", "Power 12"][pin]; },
              pinid: function(pin) { return ["2.PTD2", "2.PTD3", "2.PTC8", "2.PTC9", "2.PTC0", "2.PTC3", "2.PTC4", "2.PTE23", "2.PTE29", "2.PTE0"][pin] },
              hovername: liteBoardHoverName
            },
            { groups: [0], pins: 4, header: "Plunger",
              pinname: function(pin) { return ["Plunger SDA", "Plunger CHA/SCL", "Plunger CHB", "Plunger Wiper/INT"][pin]; },
              pinid: function(pin) { return ["PTE20", "PTE21", "PTE22", "PTB0"][pin]; },
              hovername: liteBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#liteBoardDigitalOutputSelector"), liteBoard_headers, true, liteGpioPortAlias, liteOutPortAlias);
            
        // Build the main board PWM output list
        buildGroupedPinList($("#mainBoardPWMOutputSelector"), [
            { groups: [0], pins: 15, header: "Flashers",
              pinname: function(pin) { return (Math.floor(pin/3)+1) + "RGB".substr(pin % 3, 1) },
              pinid: function(pin) { return "3." + pin; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 1, header: "Strobe",
              pinname: function(pin) { return ["Strobe"][pin]; },
              pinid: function(pin) { return ["3.15"][pin] },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 16, header: "RGB Flippers",
              pinname: function(pin) { return (pin < 15 ? (Math.floor(pin/3)+1) + "RGB".substr(pin %3, 1) : "6"); },
              pinid: function(pin) { return "3." + (16 + pin); },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 3, header: "Extender",  // extender port JP12 - only pins 1, 2, and 4 are PWM capable
              pinname: function(pin) { return "Extender " + [1, 2, 4][pin]; },
              pinid: function (pin) { return ["1.PTC4", "1.PTC3", "1.PTA2"][pin]; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 6, header: "Plunger",
              pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button", "Cal LED"][pin]; },
              pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29", "PTE23"][pin]; },
              hovername: mainBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#mainBoardPWMOutputSelector"), mainBoard_headers, true, expGpioPortAlias, expOutPortAlias);


        // Build the Pinscape AIO board PWM output list
        buildGroupedPinList($("#aioBoardPWMOutputSelector"), [
            { groups: [0], pins: 15, header: "RGB Flashers",
              pinname: function(pin) { return (Math.floor(pin/3)+1) + "RGB".substr(pin % 3, 1) },
              pinid: function(pin) { return "3." + pin; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 1, header: "Strobe",
              pinname: function(pin) { return ["Strobe"][pin]; },
              pinid: function(pin) { return ["3.15"][pin] },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 16, header: "Small LED/Opto",
              pinname: function(pin) { return (pin < 15 ? (Math.floor(pin/3)+1) + "RGB".substr(pin %3, 1) : "6"); },
              pinid: function(pin) { return "3." + (16 + pin); },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 32, header: "Power Outputs",
              pinname: function(pin) { return "Output " + (pin + 1); },
              pinid: function(pin) { return "3." + (32 + pin); },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 3, header: "Expansion Port", pinname: "Expansion Port",
              pinname: function(pin) { return ["Expansion C4", "Expansion C3", "Expansion A2"][pin]; },
              pinid: function (pin) { return ["1.PTC4", "1.PTC3", "1.PTA2"][pin]; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 4, header: "Plunger",
              pinname: function(pin) { return ["Plunger SDA", "Plunger CHA/SCL", "Plunger CHB", "Plunger Wiper/INT"][pin]; },
              pinid: function(pin) { return ["PTE20", "PTE21", "PTE22", "PTB0"][pin]; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 2, header: "Calibration",
              pinname: function(pin) { return ["Calibration A", "Calibration LED-"][pin]; },
              pinid: function(pin) { return ["PTE29", "PTE23"][pin]; },
              hovername: aioBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#aioBoardPWMOutputSelector"), aioBoard_headers, true, aioGpioPortAlias, aioOutPortAlias);


        // Build the Pinscape Lite board PWM output list
        buildGroupedPinList($("#liteBoardPWMOutputSelector"), [
            { groups: [0], pins: 2, header: "PWM Outputs",
              pinname: function(pin) { return ["Power 1", "Power 2"][pin]; },
              pinid: function(pin) { return ["1.PTA2", "1.PTA13"][pin] },
              hovername: liteBoardHoverName
            },
            { groups: [0], pins: 16, header: "Small LED/Opto",
              pinname: function(pin) { return "Small LEDs " + (1 + pin); },
              pinid: function (pin) { return "3." + pin; },
              hovername: liteBoardHoverName
            },
            { groups: [0], pins: 4, header: "Plunger",
              pinname: function(pin) { return ["Plunger SDA", "Plunger CHA/SCL", "Plunger CHB", "Plunger Wiper/INT"][pin]; },
              pinid: function(pin) { return ["PTE20", "PTE21", "PTE22", "PTB0"][pin]; },
              hovername: liteBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#liteBoardPWMOutputSelector"), liteBoard_headers, true, liteGpioPortAlias, liteOutPortAlias);  


        // Build the main board input list
        buildGroupedPinList($("#mainBoardInputSelector"), [
            { groups: [0], pins: 1, header: "N/C", pinname: "Not Conn", pinid: "Not Connected",
              hovername: function() { return "Not Connected"; }
            },
            { groups: [0], pins: 24, header: "Buttons", pinname: "Button 1",
              pinid: function(pin) { return expansionBoardFactoryConfig.buttons[pin+1].pin; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 4, header: "Extender", pinname: "Extender 1",
              pinid: function(pin) { return ["PTC4", "PTC3", "PTC0", "PTA2"][pin]; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 5, header: "Plunger",
              pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button"][pin]; },
              pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29"][pin]; },
              hovername: mainBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#mainBoardInputSelector"), mainBoard_headers, true, expGpioPortAlias, expOutPortAlias);


        // Build the Pinscape AIO board input list
        buildGroupedPinList($("#aioBoardInputSelector"), [
            { groups: [0], pins: 1, header: "N/C", pinname: "Not Conn", pinid: "Not Connected",
              hovername: function() { return "Not Connected"; }
            },
            { groups: [0], pins: 24, header: "Buttons", pinname: "Button 1",
              pinid: function(pin) { return pinscapeAIOFactoryConfig.buttons[pin+1].pin; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 4, header: "Expansion Port", pinname: "Expansion Port",
              pinname: function(pin) { return ["Expansion C4", "Expansiom C3", "Expansion C0", "Expansion A2"][pin]; },
              pinid: function(pin) { return ["PTC4", "PTC3", "PTC0", "PTA2"][pin]; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 4, header: "Plunger",
              pinname: function(pin) { return ["Plunger SDA", "Plunger CHA/SCL", "Plunger CHB", "Plunger Wiper/INT"][pin]; },
              pinid: function(pin) { return ["PTE20", "PTE21", "PTE22", "PTB0"][pin]; },
              hovername: aioBoardHoverName
            },
            { groups: [0], pins: 1, header: "Calibration",
              pinname: function(pin) { return ["Calibration A"][pin]; },
              pinid: function(pin) { return ["PTE29"][pin]; },
              hovername: aioBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#aioBoardInputSelector"), liteBoard_headers, true, liteGpioPortAlias, liteOutPortAlias);

        // Build the Pinscape Lite board input list
        buildGroupedPinList($("#liteBoardInputSelector"), [
            { groups: [0], pins: 1, header: "N/C", pinname: "Not Conn", pinid: "Not Connected",
              hovername: function() { return "Not Connected"; }
            },
            { groups: [0], pins: 24, header: "Buttons", pinname: "Button 1",
              pinid: function(pin) { return pinscapeLiteFactoryConfig.buttons[pin+1].pin; },
              hovername: liteBoardHoverName
            },
            { groups: [0], pins: 4, header: "Plunger",
              pinname: function(pin) { return ["Plunger SDA", "Plunger CHA/SCL", "Plunger CHB", "Plunger Wiper/INT"][pin]; },
              pinid: function(pin) { return ["PTE20", "PTE21", "PTE22", "PTB0"][pin]; },
              hovername: liteBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#liteBoardInputSelector"), liteBoard_headers, true, liteGpioPortAlias, liteOutPortAlias);


        // Build the power board pin list
        buildBoardPinButtons($("#powerBoardOutputSelector"), powerBoard_headers, false, expGpioPortAlias, expOutPortAlias);
        initBoardPinPageAdjustor(
            "powerBoardOutputSelector", $("#numPowerBoards"), "3.", 32, 32);

        buildBoardPinButtons($("#powerBoardOutputSelector"), powerBoard_headers, false, aioGpioPortAlias, aioOutPortAlias);
        initBoardPinPageAdjustor(
            "powerBoardOutputSelector", $("#numPowerBoards"), "3.", 32, 64);

        // Build the chime board pin list when we add or remove board
        buildBoardPinButtons($("#chimeBoardOutputSelector"), chimeBoard_headers, false, expGpioPortAlias, expOutPortAlias);
        initBoardPinPageAdjustor(
            "chimeBoardOutputSelector", $("#numChimeBoards"), "4.", 8, 0);

        buildBoardPinButtons($("#chimeBoardOutputSelector"), chimeBoard_headers, false, aioGpioPortAlias, aioOutPortAlias);
        initBoardPinPageAdjustor(
            "chimeBoardOutputSelector", $("#numChimeBoards"), "4.", 8, 8);


        // Initialize the page adjustor for one of the output boards
        function initBoardPinPageAdjustor(
            pageName, numBoardsField, typePrefix, outputsPerBoard, startingOutput)
        {
            // we haven't built any of these yet
            var numBoards = 0;

            // set up the adjustor function, and store it in the table so
            // that showChipPinPage() can automatically call it
            chipPinPageAdjustor[pageName] = function()
            {
                // if the number of chips is different from last time, update it
                var newNumBoards = +numBoardsField.val();
                if (newNumBoards != numBoards)
                {
                    // add new pins as needed
                    var page = $("#" + pageName);
                    buildGroupedPinList(page, [{
                        groups: ordinals(0, newNumBoards-1),
                        pins: outputsPerBoard, header: "Board 1", pinname: "Output 1",
                        pinid: function(pin, board) {
                            return typePrefix + (board*outputsPerBoard + startingOutput + pin);
                        },
                        hovername: function(pinName, pinNo) { 
                            return "JP" + (Math.floor(pinNo/16)+5) + "-" + ((pinNo%16)+1);
                        }
                    }]);
                    
                    // hide boards and pins that aren't currently available
                    page.find(".chipNo, .chipPin").each(function() {
                        var self = $(this);
                        self.toggle(+self.data("chip") < newNumBoards);
                    });

                    // rebuild the board indexer
                    buildChipIndexer(page, ordinals(0, newNumBoards - 1), outputsPerBoard, 1);
                }

                // remember the new chip count
                numBoards = newNumBoards;
            };
        }

        // Build the pin buttons for an expansion board pin selector.
        //
        // Header pins can be specified as GPIO port names or our usual
        // "n.m" output port codes (e.g., "3.7" for TLC5940 output port 7).
        // GPIO ports are untyped because they take their type from the
        // page context.  All other outputs must be typed.
        //
        // For a repeatable board, such as the power board or chime board,
        // the port number specified in a typed output will serve as the
        // base port number.  On second and subsequent instances of the
        // board, we'll bump up the actual port numbers by the number of
        // such ports on the board.
        //
        // If filterToList is true, we'll only make buttons available if
        // they appear in the page's list.
        function buildBoardPinButtons(page, headers, filterToList, gpioAlias, outAlias)
        {
            // get the image padding
            var picdiv = page.find(".pinimage");
            var btndiv = picdiv.find(".pinoverlay");
            var img = picdiv.find("img");

            // if filtering to the list, build a table of the pins in list
            var listPins = { };
            if (filterToList) {
                page.find(".pinlist .chipPin").each(function()
                {
                    var self = $(this);
                    var t = self.data("pintype");
                    var p = self.data("pin");
                    listPins[(t && t != 1 && t != 2 ? t + "." + p : p)] = true;
                });
            }

            // add each pin
            $.each(headers, function(jpName, header) {
                forEachPin(header, function(pin, n, x, y)
                {
                    // Our headers are populated with all pin names, but
                    // we can only assign pins tied to GPIO ports (PTxx names)
                    // or peripheral outputs (3.xx = TLC5940 output, 4.xx =
                    // 74HC595 output, 6.xx = TLC59116 output).
                    var dataPin = "", available = " available";
                    if (/^PT[A-E]\d+$/i.test(pin)) {
                        dataPin = "data-pin=\"" + pin + "\"";
                        var g = (gpioAlias[pin] || "").split("|");
                        dataHover = "data-hovername=\"" + g[0] + " (" + g[1] + ")\"";
                        if (filterToList && !listPins[pin])
                            available = "";
                    }
                    else if (/^([34])\.(\d+)$/.test(pin)) {
                        dataPin = "data-pin=\"" + RegExp.$2 + "\" "
                                  + "data-pintype=\"" + RegExp.$1 + "\" "
                                  + "data-basepin=\"" + RegExp.$2 + "\" ";
                        var g = outAlias[pin].split("|");
                        dataHover = "data-hovername=\"" + g[0] + " (" + g[1] + ")\"";
                        if (filterToList && !listPins[pin])
                            available = "";
                    }
                    else {
                        available = "";
                    }

                    // add the item
                    btndiv.append(
                        "<div class=\"pinButton" + available + "\" "
                        + dataPin + dataHover
                        + "style=\"left: " + x + "px; top: " + y + "px;\">"
                        + "</div>");
                })
            });

            // add hover and click handlers
            addPinEvents(page.find(".pinlist"), picdiv, picdiv.find(".pinButton"));
        }

        // Initialize a scrolling list with a section header.  The list
        // is structured into sections with header elements, given by
        // the jQuery set 'sections'.  As we scroll through the list, we
        // "pin" the current section's header at the top of the list,
        // so that the current section header is always visible.
        //
        // There's no native way to do this with browser objects, so we
        // use some special effects.  To make this work, the list needs
        // a special position:absolute item just *before* the container
        // element.  This is the fixed-in-place header.  It has to be
        // absolutely positioned at the top of the list, and it has to
        // be sized to match the list interior width and header element
        // height.  It should also use the same class as the 'sections'
        // elements so that it looks the same.
        //
        // On each scroll event, we look to see if a section header in
        // the list overlaps the position:absolute fixed header element.
        // If so, we move the header element up so that it looks like
        // the next section header is pushing it off the screen as it
        // scrolls up.  When the next section header is at the very
        // top, we restore the fixed header to its normal pinned
        // position and change its text to match the new current
        // section.
        //
        // The result is that it *looks* like each section header
        // scrolls to the top and then sticks there.  What's really
        // happening is that we have just the one sticky element that
        // we relabel to match the current section.
        //
        // NB: to make the "nudge" effect work, the container has to
        // be wrapped in another container of the same size with
        // overflow:hidden.
        function initScrollHeader(container, sections)
        {
            var hdr = container.prev().filter(".header");
            container.off("scroll.scrollHeader").on("scroll.scrollHeader", function()
            {
                // assume that the first section is current
                var ele = sections.first();

                // scan the section headers to find the first one still in view
                sections.each(function(idx)
                {
                    // get this section header's position and height
                    var self = $(this);
                    var y = self.position().top;
                    var ht = self.outerHeight();

                    // Check to see if it's in view, out of view, or overlapping
                    // the fixed header area.
                    if (y < 0 && idx+1 == sections.length)
                    {
                        // This is the last item, and it's going out of view.  It's
                        // now the fixed header item.
                        hdr.css("top", "").text(self.text());
                    }
                    else if (y > 0 && y < ht)
                    {
                        // It overlaps the fixed header area.  This means that we're
                        // in a transition between sections.  Create the special effect
                        // that makes it look like the next and previous headers are
                        // moving together, by positioning the fixed element so that
                        // it abuts this header above.  This will make it look like
                        // it's scrolling along with the list, even though it's really
                        // the position:absolute foreground element.
                        hdr.css("top", (y-ht) + "px").text(ele.text());
                        return false;
                    }
                    else if (y >= ht)
                    {
                        // This header is completely in view.  Set the fixed header
                        // so that it's at its normal position - this looks like a
                        // regular section header that's sticking at the top of the
                        // list.  Set the fixed header text to the *previous* section
                        // text - the first item in view within the scrolling area
                        // is part of the previous section, since the current section
                        // is the first one that's in view.
                        hdr.css("top", "").text(ele.text());
                        return false;
                    }
                    else
                    {
                        // The current element is completely out of view.  Remember
                        // this as the previous element and keep going.
                        ele = self;
                    }
                });
            });
        }

        // initialize all pin selector controls
        $(".pinselect").data({"active": true, "save": true}).each(function()
        {
            // set up the current value and warning icon spans
            $(this).html("<input class=\"pinval\" readonly>"
                         + "<span class=\"pinwarn\"><img src=\"pinwarn.png\"></span>");

            // add an expansion board alias field, if requested
            if ($(this).hasClass("withExpBoardAlias"))
            {
                // mark the input as an expansion board pin (to be hidden in
                // expansion board mode), and add the alias field
                $(this).children("input").addClass("expBoardPin").after(
                    "<input class=\"expBoardAlt\" readonly>");
            }
        });

        // Handle clicks in GPIO pin selectors.  These selectors all select
        // a GPIO pins with one specific function (PWM out, digital in,
        // ADC in, etc), show we show only the page for that function.  All
        // other page buttons are hidden, since it's not possible to change
        // the pin type for a specific functional assignment.
        $(".pinselect").click(function(ev)
        {
            // remove focus from the field, so that the text cursor isn't
            // flashing while the dialog is visible
            var self = $(this);
            self.children(".pinval").blur();

            // show the pin selector dialog with the KL25Z page
            showPinSelector(self);

            // Show only the appropriate KL25Z page select button.  A .pinselect
            // field is tied to a particular pin type, so we only need to show
            // the one button that's appropriate to the type.  For all .pinselect
            // fields, include a Not Connected option in the pin list.
            var gpiotype = (self.data("gpiotype") + " nc").split(" ");
            $("#pinTypeSelector > div").each(function() {
                var vis = $(this).data("page") == "gpioSelector" && $(this).data("filter") == gpiotype[0];
                $(this).toggle(vis).toggleClass("selected", vis);
                if (vis)
                    selectPage($(this), true, gpiotype);
            });
        });

        // On clicking a button input selector expansion board alias field,
        // show a pin selector.  Show the main expansion board page, and also
        // show the direct KL25Z input selector as an alternative.
        $("#buttonTab input.expBoardAlt").click(function(ev)
        {
            // don't propagate the event to the parent, since it would reopen
            // the dialog in plain KL25Z mode
            ev.preventDefault();
            ev.stopPropagation();
            
            // remove focus from the field, to prevent flashing cursors in the dialog
            var self = $(this);
            self.blur();
            
            // Show the pin selector
            showPinSelector(self.parents(".pinselect"));

            // choose the appropriate page depending on the hardware type
            var selector;
            switch (+$("input:radio[name=hardwareType]:checked").val())
            {
            case 1:   // Pinscape Expansion Boards
            default:  // other/unknown
                selector = "mainBoardInputSelector";
                break;

            case 2:   // AIO Board
                selector = "aioBoardInputSelector";
                break;

            case 3:   // Lite Board
                selector = "liteBoardInputSelector";
                break;
            }
            
            // Make the KL25Z digital input page and expansion board input
            // pages visible, and start with the expansion board page active.
            $("#pinTypeSelector > div").each(function() {
                var btn = $(this);
                var pageName = btn.data("page");
                var sel = (pageName == selector);
                var vis = sel;
                if (pageName == "gpioSelector" && btn.data("filter") == "dig-in") {
                    btn.data("curfilter", ["dig-in", "extern", "nc"]);
                    vis = true;
                }
                btn.toggle(vis).toggleClass("selected", sel);
                if (sel)
                    selectPage(btn, true, null);
            });
        });

        // Handle clicks in the output controller pin selectors.  These
        // selectors can choose any type of output pin (PWM out, digital out,
        // virtual out, TLC5940 out, 74HC595 out, TLC59116 out).  In expansion 
        // board mode, we add pages for the expansion boards.
        $("#outputTab .pinlabel, #outputTab .dispPinFunc, "
          + "#outputTab .dispPinType, #outputTab .dispPinLoc,"
          + "#outputTab .dispPinHeader, #outputTab .dispPinName").click(function(ev)
        {
            // remove focus from the field
            var self = $(this);
            var row = self.parents(".outPortRow");
            row.find(".dispPinName").blur();

            // show the dialog
            showPinSelector(row.find(".dispPinName").parent());

            // note the hardware mode (0=standalone, 1=expansion boards, 2=Pinscape AIO, 3=Pinscape Lite)
            var hwType = +$("input:radio[name=hardwareType]:checked").val();

            // get the selected row's pin and type, and the out port alias string
            var pintype = row.find(".pintype").val();
            var pinid = row.find(".pinval").val();
            var alias = (outPortAlias[pintype + "." + pinid] || "").split("|");

            // Show only the page select buttons for output pin types.
            var page;
            var foundSelected = false;
            $("#pinTypeSelector > div").each(function()
            {
                // get this button's dialog page name and the output type
                var pageName = $(this).data("page");
                var outtype = $(this).data("pintype");

                // figure out if this button is visible
                var vis = false;
                switch (pageName)
                {
                case "gpioSelector":
                    // KL2Z GPIO pages - enable for the PWM and Digital Out pins
                    vis = (outtype == 1 || outtype == 2);
                    break;

                case "tlc5940Selector":
                    // TLC5940.  This type is visible in standalone mode if we
                    // have any TLC5940 chips in the current configuration.
                    // In expansion board mode, we do have 5940 outputs, but we
                    // select these through the expansion board pages instead.
                    vis = (hwType == 0 && +$("#tlc_nchips").val() > 0);
                    break;

                case "tlc59116Selector":
                    // TLC59116.  This type is visible in standalone mode if
                    // we have any of these chips.
                    vis = (hwType == 0 && $("#tlc59116_chipsEnabled input:checked").length != 0);
                    break;

                case "hc595Selector":
                    // 74HC595.  Visible in standalone mode if we have any of
                    // these chips.
                    vis = (hwType == 0 && +$("#hc595_nchips").val() > 0);
                    break;

                case "virtualOutputSelector":
                    // Virtual out - always visible
                    vis = true;
                    break;

                case "mainBoardDigitalOutputSelector":
                    // Main expansion board digital outputs.  Enable in expansion
                    // board mode.
                    vis = (hwType == 1);
                    break;

                case "mainBoardPWMOutputSelector":
                    // Main expansion board PWM outputs.  Enable in expansion
                    // board mode.
                    vis = (hwType == 1);
                    break;

                case "aioBoardDigitalOutputSelector":
                    // Pinscape AIO digital outputs.  Enable in Pinscape AIO
                    // board mode.
                    vis = (hwType == 2);
                    break;

                case "aioBoardPWMOutputSelector":
                    // Pinscape AIO PWM outputs.  Enable in Pinscape AIO
                    // board mode.
                    vis = (hwType == 2);
                    break;

                 case "liteBoardDigitalOutputSelector":
                    // Pinscape Lite digital outputs.  Enable in Pinscape Lite
                    // board mode.
                    vis = (hwType == 3);
                    break;

                case "liteBoardPWMOutputSelector":
                    // Pinscape Lite PWM outputs.  Enable in Pinscape Lite
                    // board mode.
                    vis = (hwType == 3);
                    break;

                case "powerBoardOutputSelector":
                    // Power board outputs.  Enable in expansion board mode if we
                    // have at least one power board.
                    vis = ((hwType == 1 || hwType == 2 || hwType == 3) && +$("#numPowerBoards").val() > 0);
                    break;

                case "chimeBoardOutputSelector":
                    // Chime board outputs.  Enable in expansion board mode if we
                    // have at least one chime board.
                    vis = ((hwType == 1 || hwType == 2 || hwType == 3) && +$("#numChimeBoards").val() > 0);
                    break;

                }

                // Determine if this page is selected.  Use only the first
                // selected page we find.
                var selected = false;
                if (!foundSelected)
                {
                    switch (hwType)
                    {
                    case 0:
                    default:
                        // Standalone mode.  Each page in this mode selects a single
                        // output pin type, so we can match page to pin by type.
                        selected = (outtype == pintype);
                        break;

                    case 1:  // Pinscape expansion boards
                    case 2:  // Pinscape All-in-one boards
                    case 3:  // Pinscape Lite
                        // Expansion Board mode.  In this mode, each page can show a mix
                        // of types, and each type can appear on more than one page, so
                        // we can't match by type.  Instead, use the port alias.  Field
                        // [4] gives the board type.  If there's no port alias, fall back
                        // on the type-specific page.
                        selected = (alias[4] ? alias[4] == pageName : outtype == pintype);
                        break;
                    }
                }


                // If the page is selected, make it visible even if we wouldn't
                // have otherwise done so.
                if (selected) {
                    vis = true;
                    foundSelected = true;
                }

                // if the button is visible, show it
                $(this).toggle(vis);
                if (vis)
                {
                    // show the button's current selection status
                    $(this).toggleClass("selected", selected);

                    // if the button is selected, activate its page
                    if (selected)
                        selectPage($(this), true, null);
                }
            });
        });

        // handle clicks in the pin selector page buttons
        $("#pinTypeSelector > div").click(function() {
            selectPage($(this), false, null);
        });

        function selectPage(button, initial, pinFilter)
        {
            // remember the new active page button
            curpagebtn = button;

            // hide all pages
            $("#pinSelector .pinSelectorPage").css("display", "none");

            // show the selected page
            var pagename = button.data("page");
            var page = $("#" + pagename);
            page.css("display", "");

            // get its pin list
            curpinlst = page.find(".pinlist");

            // we don't have a selection on the new page yet
            curSelItem = null;

            // highlight the appropriate button
            $("#pinTypeSelector > div").removeClass("selected");
            button.addClass("selected");

            // set up the new page
            switch (pagename)
            {
            case "gpioSelector":
                // if the caller specified a filter, remember it
                if (pinFilter)
                    button.data("curfilter", pinFilter);

                // Show the KL25Z pin selector.  Use the caller's filter if provided,
                // otherwise use the button's current filter, otherwise use the
                // button's default filter.
                showKL25ZPinPage(pinFilter || button.data("curfilter") || button.data("filter").split(" "), initial);
                break;

            case "tlc5940Selector":
            case "hc595Selector":
            case "tlc59116Selector":
            case "mainBoardDigitalOutputSelector":
            case "mainBoardPWMOutputSelector":
            case "aioBoardDigitalOutputSelector":
            case "aioBoardPWMOutputSelector":
            case "liteBoardDigitalOutputSelector":
            case "liteBoardPWMOutputSelector":
            case "mainBoardInputSelector":
            case "aioBoardInputSelector":
            case "liteBoardInputSelector":
            case "powerBoardOutputSelector":
            case "chimeBoardOutputSelector":
                // show the chip pin selector
                showChipPinPage(pagename, page, initial, button.data("pintype"));
                break;

            case "virtualOutputSelector":
                showVirtualPage();
                break;
            }

            // If we have a list header, size it to match the list interior width.
            // We couldn't do this earlier because the page is invisible ("display:
            // none") when the dialog isn't open or a different page is active.  We
            // need the list to be visible in order to measure its width.
            var lst = page.find(".pinlist");
            lst.prev().filter(".header").css("width", lst.innerWidth() - sbwid);

            // if opening the dialog, make sure the button is in view
            if (initial)
                scrollIntoView(button, 0);
        }

        // show the virtual page
        function showVirtualPage()
        {
            // select the virtual out button if applicable
            $("#btnMakeVirtualPort").toggleClass(
                "selected", curpin.find(".pintype").val() == 5);

            // select the ZB port button if applicable
            $("#btnMakeZBPort").toggleClass(
                "selected", curpin.parents(".outPortRow").data("idx") == $("#zbPort").val());
        }

        // Show the pin selector dialog.  'opener' is the .pinselect INPUT child
        // that triggered the selection.  'positioner' is the visible element to
        // use as a reference point in positioning the dialog; this defaults to
        // the opener element if omitted.
        function showPinSelector(opener, positioner)
        {
            // use the opener as the default positioner
            positioner = positioner || opener;

            // forget any active gpio page filters from past runs
            pindlg.find(".pinTypeSelector > div").data("curfilter", null);

            // show the dialog
            pindlg.parent().css("display", "block");

            // show just the "virtual" page for sizing purposes
            pindlg.children(".pinSelectorPage").css("display", "none");
            $("#virtualOutputSelector").css("display", "");

            // move it align with the left of the field, centered vertically
            var ofs = positioner.offset();
            var dlght = pindlg.outerHeight() + 5;
            var dlgwid = pindlg.outerWidth();
            var winht = window.innerHeight - $("#nav").outerHeight();
            var winwid = window.innerWidth - getScrollBarWidth();
            var scrolly = $("html,body").scrollTop();
            var scrollx = $("html,body").scrollLeft();
            var x = ofs.left;
            var y = ofs.top + positioner.height()/2 - dlght/2;

            // if it goes out of view below, move it up
            if (y + dlght > scrolly + winht)
                y = scrolly + winht - dlght;

            // and if it goes out of view above, move it down
            if (y < scrolly)
                y = scrolly;

            // make sure it doesn't go out of the window to the right or left
            if (x + dlgwid > scrollx + winwid)
                x = scrollx + winwid - dlgwid;
            if (x < scrollx)
                x = scrollx;

            // position it
            pindlg.css({left: x + "px", top: y + "px"});

            // mark the opener's associated label as active
            curpinlbl = opener.parents(":has(.pinlabel)");
            curpinlbl.addClass("openDlgRow");

            // remember the opener
            curpin = opener;

            // add a dialog stack entry while we're open
            dialogStack.push({
                id: "pinDialog",
                keydown: function(ev) {
                    if (curpin && curpinlst)
                    {
                        function go(delta)
                        {
                            // If delta is +/- 10000, scroll by a page - figure the page size.
                            if (delta == -10000 || delta == 10000)
                            {
                                // refigure the delta in terms of elements per page
                                var pg = Math.floor(curpinlst.innerHeight() / curpinlst.children().first().innerHeight());
                                pg = (pg > 2 ? pg - 1 : 1);
                                delta = delta/10000*pg;
                            }

                            // Start at the current selection.  If there isn't one,
                            // select the first item initially.
                            var newsel = curSelItem;
                            if (!newsel)
                            {
                                // find the first item
                                newsel = curpinlst.find("div.available").first();

                                // If this is a down arrow or page down key, just go to
                                // the first item from an initial null selection.  This
                                // is nicer than jumping to the second item or next page
                                // immediately from no selection.
                                if (ev.which == 40 || ev.which == 34 || ev.which == 99) {
                                    pinselect(newsel, false, false);
                                    return;
                                }
                            }

                            // Seek forwards or backwards by the desired number of items;
                            // if we reach the end/beginning of the list, stop at the
                            // first/last element.
                            for ( ; delta < 0 ; ++delta)
                            {
                                newsel = newsel.prevAll(".available").first();
                                if (!newsel.length) {
                                    newsel = curpinlst.find("div.available").first();
                                    break;
                                }
                            }
                            for ( ; delta > 0 ; --delta)
                            {
                                newsel = newsel.nextAll(".available").first();
                                if (!newsel.length) {
                                    newsel = curpinlst.find("div.available").last();
                                    break;
                                }
                            }
                            
                            // select the new pin
                            pinselect(newsel, false, false);
                        }
    
                        // pin dialog is open
                        switch (ev.which)
                        {
                        case 38:
                            // up - select previous item or first item
                            go(-1);
                            ev.preventDefault();
                            return false;
                            
                        case 40:
                            // down - select next item or last item
                            go(1);
                            ev.preventDefault();
                            return false;

                        case 33:   // page up
                        case 105:  // keypad 9/page up
                            go(-10000);
                            ev.preventDefault();
                            return false;

                        case 35:   // end
                        case 97:   // keypad 1/end
                            go(9999);
                            ev.preventDefault();
                            return false;

                        case 36:   // home
                        case 103:  // keypad 7/home
                            go(-9999);
                            ev.preventDefault();
                            return false;

                        case 34:   // page down
                        case 99:   // keypad 3/page down
                            go(10000);
                            ev.preventDefault();
                            return false;
                            
                        case 13:
                        case 10:
                            // return/enter - close the dialog, selecting the current pin
                            pinselect(curSelItem, false, true);
                            return false;
                            
                        case 27:
                            // escape - close the dialog without changing the selection
                            dismissPinDlg();
                            return false;
                        }
                    }
                }
            });
        }

        // Show a KL25Z pin page in the pin selector dialog.
        //
        // 'gpiotype' is a string array giving the type of pin we're
        // selecting.  The first element must be one of the KL25Z GPIO
        // page keywords: dig-in, dig-out, pwm, adc, interrupt-in,
        // spi-mosi, or spi-sclk.
        //
        // Additional elements specify modifiers:
        //
        //   extern -> ONLY include external header pins in the list
        //   nc     -> ALSO include "Not Connected" in the list
        //
        // 'opening' is true if we're opening the dialog, false if we're
        // merely selecting a new page.
        function showKL25ZPinPage(gpiotype, opening)
        {
            // build a list of pin filters according to the pin type
            var pinFilter = function(p, name) { return true; };
            var primary = {
                "dig-in": function(p) { return p; },         // All pins can be used as digital inputs
                "dig-out": function(p) { return p; },        // ... or digital outputs.
                "adc": function(p) { return p && p.adc; },   // Other features are available on a subset of pins
                "pwm": function(p) { return p && p.pwm; },   // with no apparent pattern, so we use attributes to
                "interrupt-in": function(p) { return p && p.interrupt; },    // flag which features each pin supports.
                "spi-mosi": function(p) { return p && p.spi == "MOSI"; },
                "spi-sclk": function(p) { return p && p.spi == "SCLK"; }
            };

            // get the primary filter
            pinFilter = primary[gpiotype[0]];

            // add exclusion modifiers first
            var modifiers = gpiotype.slice(1);
            $.each(modifiers, function(k, v)
            {
                if (v == "extern") {
                    // external pins only - pin must be external AND match primary rule
                    pinFilter = (function(f) {
                        return function(p, name) { return p && !p.internal && f(p, name); };
                    })(pinFilter);
                }
            });

            // add inclusive modifiers last
            $.each(modifiers, function(k, v)
            {
                if (v == "nc") {
                    // NC - matches Not Connected always, or matches other conditions
                    pinFilter = (function(f) {
                        return function(p, name) { return name == "No connected" || f(p, name); };
                    })(pinFilter);
                }
            });

            // filter the KL25Z pin list and pin images to make available
            // the subset appropriate for this pin type
            $("#kl25zPinImg .pinButton, #lstKL25ZPins > div").each(function() {
                var name = $(this).data("pin");
                var gp = gpioPinsByName[name];
                $(this).toggleClass("available", !!pinFilter(gp, name));
            });

            // make the current selection active
            var sel = null;
            var val = curpin.find(".pinval").val();
            pinlst.children().each(function() {
                if (pinlistVal($(this)) == val)
                {
                    sel = $(this);
                    return false;
                }
            });

            // select the item
            sel = sel || pinlst.children().first();
            pinselect(sel, opening, false);

            // mark in-use pins in the list and board image
            markPinsInUse($("#lstKL25ZPins > div, #kl25zPinImg .pinButton"), gpiotype[0] == "pwm", "kl25z");
        }

        // Mark in-use pins.  'pins' is a jQuery list of the pins to mark,
        // which can include the text list and the image buttons.
        //
        // 'pwm' is true if this selector page selects PWM pins.  If so,
        // we'll show a distinctive style for pins that aren't directly
        // in use but whose PWM channels are in use by other pins.
        //
        // 'pageType' is one of:
        //   - "kl25Z", for direct KL25Z pin selection pages
        //   - "chip", for peripheral chips - TLC5940, 74HC595, TLC59116
        //   - "board", for expansion boards
        var markPinsInUsePending = 0;
        function markPinsInUse(pins, pwm, pageType)
        {
            // if we don't already have a pending timeout, set one
            if (markPinsInUsePending++ == 0)
                setTimeout(function() { go(); }, 0);
    
            function go()
            {
                // no longer pending
                markPinsInUsePending = 0;
                
                // Build a table of all pins current in use
                var inuse = pinsInUse();

                // note the current selection
                var keyCur = inuseID(curpin);
                var gCur = gpioPinsByName[keyCur] || { };

                // visit each item in the dialog list
                pins.each(function()
                {
                    // get this item and its in-use key
                    var self = $(this);
                    var key = inuseID(self);

                    // presume it won't be in use
                    self.removeClass("inuse pwmInuse").attr("title", "");

                    // if it's a GPIO pin, get its descriptor
                    var g = gpioPinsByName[key] || { };

                    // get the port name and the jumper name/internal name
                    var port = g.name;
                    var jumper = pinToJumper(key);

                    // combine the pin name and conflict or remark text into a hover title
                    function title(txt)
                    {
                        var lst = [];
                        var h = self.data("hovername");
                        if (h) lst.push(h);
                        if (txt) lst.push(txt);
                        return lst.join(" - ");
                    }

                    // if this is the current pin, don't show conflicts - just set the
                    // title to the remarks
                    if (key == keyCur)
                    {
                        self.attr("title", title(g.remarks));
                        self.addClass("current selected");
                        return;
                    }

                    // If desired, check the PWM channel.  If this list/pin item is
                    // associated with a PWM channel other than the current selection's
                    // channel, show the other user(s).  We don't show a conflict with
                    // the current selection's channel because reassigning the pin will
                    // remove the old assignment, which will free up the channel.  We'll
                    // effectively be moving the same channel to a new pin, which won't
                    // create a conflict.
                    var pwmch, pwmiu;
                    var pwmUsers;
                    if (pwm
                        && (pwmch = g.pwm)
                        && pwmch != gCur.pwm
                        && (pwmiu = inuse["pwm." + pwmch]))
                    {
                        // This PWM channel is in use.  Make a note of the other users.
                        pwmUsers = "PWM Channel " + pwmch + " is in use by " + pwmiu.inUseBy();
                    }

                    // Note if this is a GPIO port that's connected to an expansion
                    // board port in the current configuration.  If it is, it'll have
                    // an alias.
                    var alias = pageType == "kl25z" && gpioPortAlias[key];

                    // Check for conflicts, in order of descending priority
                    if (inuse[key])
                    {
                        // in use - add class highlighting and show other users in the title
                        self.addClass("inuse");
                        self.attr("title", title("In use by " + inuse[key].inUseBy()));
                    }
                    else if (pwmUsers)
                    {
                        // the pin isn't claimed, but its PWM channel is already in use
                        self.addClass("pwmInuse");
                        self.attr("title", title(pwmUsers));
                    }
                    else if (alias)
                    {
                        self.addClass("inuse");
                        self.attr("title", title("This pin is used by the expansion board ("
                                                 + alias.split("|")[0]) + ")");
                    }
                    else
                    {
                        // not in use - remove the class highlighting, and set the title to
                        // any general remarks for this pin
                        self.attr("title", title(g.remarks));
                    }
                });
            }
        }

        // Show a chip pin page in the pin selector dialog
        function showChipPinPage(pageName, page, opening, pagePinType)
        {
            // run the pin adjustor function for this page, if any
            (chipPinPageAdjustor[pageName] || function() { })();

            // find the selected item in the list
            var sel = null;
            var lst = page.find(".pinlist");
            var val = curpin.find(".pinval").val();
            var typ = curpin.find(".pintype").val();
            lst.children().each(function()
            {
                // Check for a match to the pin name and type.  The pin
                // type can come from the list item, if it has one, or
                // from the page.
                var self = $(this);
                if (self.data("pin") == val
                    && (self.data("pintype") || pagePinType) == typ)
                {
                    sel = $(this);
                    return false;
                }
            });

            // deselect all pins in the list
            lst.children(".chipPin").removeClass("selected current inuse pwmInuse").attr("title", "");

            // deselect all chips
            page.find(".chipIndexer div").removeClass("selected");

            // select the active pin if there is one, otherwise just select
            // our first chip with no pin selection
            if (sel)
                pinselect(sel, opening, false);
            else
                switchChip(page, 0, 0);

            // mark in-use items
            markPinsInUse(page.find(".chipPin, .pinButton"), page.data("pwm"), page.data("pagetype"));
        }
    
        // Select a new chip on a chip pin selector (TLC5940, 74HC595, TLC59116).
        // This switches among multiple copies of the current chip type.
        function switchChip(page, chipno, pinsPerChip)
        {
            // deselect all pin buttons
            var picdiv = page.find(".pinimage");
            var buttons = picdiv.find(".pinButton");
            buttons.removeClass("selected current inuse").attr("title", "");

            // count the pins in the image if the caller didn't tell us
            if (!pinsPerChip)
                pinsPerChip = buttons.filter(function() { return $(this).data("basepin") !== undefined; }).length;

            // renumber the pins to the range for the currently selected chip
            var firstpin = chipno * pinsPerChip;
            buttons.each(function()
            {
                // if this is an output pin, renumber it
                var self = $(this);
                var basepin = self.data("basepin");
                if (basepin !== undefined)
                {
                    // renumber to the base pin number (the pin index within the chip)
                    // plus the first pin for the selected chip
                    var pin = firstpin + (+basepin);
                    var typ = self.data("pintype");
                    self.data("pin", pin);
                }
            });

            // show the new chip as current
            picdiv.find(".chipIndexer div").removeClass("selected")
                .filter(function() { return $(this).data("idx") == chipno; }).addClass("selected");

            // mark in-use items
            markPinsInUse(page.find(".chipPin, .pinButton"), page.data("pwm"), page.data("pagetype"));
        }

        // Handle focus and keystrokes in a pinselect text field
        $(".pinselect .pinval").focus(function(ev) {
            // on gaining focus, select all text so we lose the flashing cursor
            this.select();
        }).keydown(function(ev) {
            switch (ev.which)
            {
            case 10:
            case 13:
            case 32:
                // open the pin selector popup on enter/return/space
                $(this).parents(".pinselect").click();
                ev.preventDefault();
                return false;
            }
        });

        // clicking on a pin warning icon shows its warning
        $(".pinwarn").click(function() {
            event.stopPropagation();
            alert($(this).attr("title"));
        });

        // field that activated pin selector popup, and its label
        var curpin, curpinlbl;

        // Current selected list item.  This is mostly for the keyboard
        // (arrow key) interface.  This is initially set to the current
        // value of the field that opened the dialog, and we update it
        // when we move the selection via the arrow keys.
        var curSelItem;

        // current selected page button - this is the button div that
        // selected the page (one of the #pinTypeSelector descendants)
        var curpagebtn;

        // current page's pin list
        var curpinlst;

        // dismiss the pin selector dialog
        function dismissPinDlg()
        {
            // hide the dialog
            pindlg.parent().css("display", "none");

            // remove the active highlighting from the label
            if (curpinlbl)
                curpinlbl.removeClass("openDlgRow");

            // set focus back to the field
            $(curpin).children(".pinval").focus();
    
            // clear the dialog tracker variables
            curpin = curpinlbl = curSelItem = curpinlst = null;

            // remove our dialog stack entry
            popDialogStack("pinDialog");
        }

        // get the value for a pinlist item
        function pinlistVal(item)
        {
            return item.data("pin");
        }

        // Default flags to set for certain special pin selections.  We'll
        // set these flags when one of these pins is selected as an output port.
        var specialPinFlags = {
            "1.PTB18": 0x05,    // Red on-board LED, PWM Out: Active Low + Gamma
            "2.PTB18": 0x01,    // Red on-board LED, Digital Out: Active Low
            "1.PTB19": 0x05,    // green on-board LED, PWM Out: Active Low + Gamma
            "2.PTB19": 0x05,    // green on-board LED, Digital Out: Active Low + Gamma
            "1.PTD0":  0x05,    // blue on-board LED, PWM Out: Active Low + Gamma
            "2.PTD0":  0x05     // blue on-board LED, Digital Out: Active Low + Gamma
        };

        // select an item in a pinlist
        function pinselect(item, initial, dismiss)
        {
            // If this is a 'dismiss' action, don't do anything if the pin
            // isn't available.  This prevents losing the selection when
            // clicking on an image pin button that's not currently enabled.
            // We allow these button elements to handle events even when
            // inactive to provide visual feedback when hovering over pin
            // areas, since it's nice to be able to identify a pin this way
            // even when it can't be selected for the current function.
            if (!item.hasClass("available"))
                return;

            // get the page
            var page = $("#" + curpagebtn.data("page"));

            // reset the selected and current state on all pins
            curpinlst.children().removeClass("selected current");
            page.find(".pinButton").removeClass("selected current");
            
            // Only allow selecting available items
            if (!item || !item.hasClass("available"))
                return;

            // get the new selected item's name and pin type
            var name = pinlistVal(item);
            var pintype = item.data("pintype") || curpagebtn.data("pintype");
            var opalias = outPortAlias[pintype + "." + name];

            // check for warnings associated with this GPIO pin (e.g., warnings
            // about re-assigning pins wired to the on-board LED)
            var g = gpioPinsByName[name];
            if (dismiss && g && g.warning)
            {
                if (!window.external.YesNoDialog(
                    g.warning
                    + "\r\n\r\n Voulez-vous continuer avec cette affectation des broches?"))
                return;
            }

            // If the selection is being made from the KL25Z pin selector
            // directly, and this pin has an expansion board alias in the
            // current hardware configuration, show a warning.
            var alias;
            if (dismiss && page.attr("id") == "gpioSelector" && (alias = gpioPortAlias[name]))
            {
                if (!window.external.YesNoDialog(
                    "Vous essayez d'attribuer une broche déjà câblée "
                    + "à une fonction spécifique sur la carte d'extension ("
                    + alias.split ("|") [0] + "). Le câblage physique sur le"
                    + "tableau peut rendre d'autres utilisations impossibles même si "
                    + "la fonction associée est désactivée dans le logiciel."
                    + "\r\n\r\n"
                    + "Voulez-vous vraiment continuer avec cette sélection de broches?"))
                    return;
            }

            // Warn about the power limits for expansion board pins connected
            // directly to KL25Z GPIO ports
            if (dismiss && !initial && /^(Extender \d|Plunger \d|Calibration\s|Expansion\s|Plunger\s|Cal Button\s)/i.test(opalias))
            {
                window.external.ShowAdviceDialog(
                    "RawOutputPowerLimitWarning",
                    "AVERTISSEMENT! \N\n"
                    + "Cette broche est connectée DIRECTEMENT à un port CPU sur la KL25Z."
                    + "Ces broches ont une capacité de gestion de puissance EXTRÊMEMENT faible."
                    + "NE JAMAIS CONNECTER UNE CHARGE SUPÉRIEURE À 4 mA À CE PIN."
                    + "La limite 4mA s'applique si la broche est utilisée en \"active"
                    + "mode high \ ou \ active low \. Dépassement de 4 mA dans l'un ou l'autre mode "
                    + "peut endommager le CPU, ce qui peut rendre l'ensemble de la KL25Z"
                    + "inopérante.");
            }

            // dismiss the dialog if desired, otherwise fix up the list display
            // for the new selection
            if (dismiss)
            {
                // set the value in the container field
                if (curpin)
                {
                    // set the pin type and value
                    $(".pintype", curpin).val(pintype);
                    $(".pinval", curpin).val(name).change();

                    // set the pin flags, if appropriate
                    var sf = specialPinFlags[pintype + "." + name] || 0;
                    curpin.parents(".outPortRow").find(".pinflags").val(sf).change();

                    // notify the parent .pinselect object of the change
                    curpin.parents(".pinselect").change();
                }

                // build a new in-use table and update warnings
                updatePinWarnings();

                // dismiss the dialog
                dismissPinDlg();
            }
            else
            {
                // get the list element
                var f = function() { return $(this).data("pin") == name; };
                var lstele = $.contains(curpinlst[0], item[0]) ? item : curpinlst.children().filter(f);

                // switch to the new chip, if there's a chip indexer
                if (page.find(".chipIndexer").length)
                    switchChip(page, lstele.data("chip"));

                // On the initial selection, set the 'current' class.  In all
                // cases, set 'selected'.
                var cl = "selected";
                if (initial)
                    cl += " current";

                // add the classes to the newly selected item
                lstele.addClass(cl);
                page.find(".pinButton").filter(f).addClass(cl);
                
                // scroll the list element into view
                scrollIntoView(lstele, 1, { top: curpinlst.prev(".header").outerHeight() });

                // remember it as the new item
                curSelItem = item;
            }
        }

        // any click in the window cover area dismisses the dialog, but not
        // in the dialog itself (stop propagation to prevent that)
        pindlg.click(function(ev) { ev.stopPropagation(); });
        pindlg.parent().click(function() { dismissPinDlg(); });
    }
});

// Open dialog stack.  Each element is an object defining global
// event interceptors.  Our document-level events handlers will
// call these in sequence, starting from the LAST element of the
// list (which corresponds to the topmost open dialog).  If a
// handler returns false, it cancels further processing of the
// key - it won't "bubble" to other dialogs or to the document
// handler.
//
//    .keydown(ev) -> keydown interceptor
//
var dialogStack = [];

// remove the topmost dialog stack matching the given ID
function popDialogStack(id)
{
    for (var i = dialogStack.length - 1 ; i >= 0 ; --i)
    {
        if (dialogStack[i].id == id)
        {
            // this is the match - remove this element
            dialogStack = $.grep(dialogStack, function(ele, idx) { return idx != i });
            return;
        }
    }
}

// Global keyboard handler
$(document).keydown(function(ev)
{
    // Run it past any dialogs in the stack first
    for (var i = dialogStack.length - 1 ; i >= 0 ; --i)
    {
        // call this handler - if it returns false, stop processing
        if (dialogStack[i].keydown(ev) === false)
            return false;
    }

    // if it's an arrow key, and focus isn't in a text-like INPUT
    // control, scroll the page
    if (ev.which == 38 || ev.which == 40)
    {
        // check for focus
        var ele = document.activeElement;
        if (!ele || $(ele).filter("input[type=text], select").length == 0)
        {
            // it's not in a text field or a select box - scroll the page
            $("html,body").stop(false, true).animate(
                { "scrollTop": $("html,body").scrollTop() + (ev.which == 38 ? -64 : 64) }, 100);
        }
    }
});

// Normalize a configuration.  This sets certain unused fields to
// default values to make comparisons more uniform.  We return a
// new configuration object - the original isn't modified.
function normalizeConfig(config)
{
    // if it's empty, return nothing
    if (!config)
        return { };

    // create a new copy of the object, so that we leave the
    // original unmodified
    config = JSON.parse(JSON.stringify(config));
    
    // remove the array counts for buttons and outputs
    if (config.buttons)
        delete config.buttons.count;
    if (config.outputs)
        delete config.outputs.count;

    // set "Not Connected" values for unused plunger sensor fields
    if (!config.plungerPins)
        config.plungerPins = { };
    switch (config.plungerType)
    {
    case 0:
        // No sensor - set all pins to "NC"
        config.plungerPins.a = "NC";
        config.plungerPins.b = "NC";
        config.plungerPins.c = "NC";
        config.plungerPins.d = "NC";
        break;
        
    case 1:
    case 3:
    case 8:
        // TSL1410R / TSL1412R, serial mode - pin 'd' is unused
        config.plungerPins.d = "NC";
        break;

    case 5:
        // Potentiometer - pins b, c, and d are unused
        config.plungerPins.b = "NC";
        config.plungerPins.c = "NC";
        config.plungerPins.d = "NC";
        break;

    case 6:
        // Quadrature sensors (e.g. AEDR-8300) - pins c and d are unused
        config.plungerPins.c = "NC";
        config.plungerPins.d = "NC";
        break;

    case 9:
        // VL6180X time-of-flight distance sensor - pin d is unused
        config.plungerPins.d = "NC";
        break;

    case 10:
        // AEAT-6012-A06 rotary absolute encoder - pin d is unsed
        config.plungerPins.d = "NC";
        break;

    case 11:
        // TCD1103GFG linear image sensor - all pins are used
        break;
    }

    // if the TV-ON feature is disabled, clear all fields
    if (config.TVon && config.TVon.enabled !== undefined) {
        if (!config.TVon.enabled) {
            config.TVon.statusPin = "NC";
            config.TVon.latchPin = "NC";
            config.TVon.relayPin = "NC";
            config.TVon.delay = 700;
        }

        // this is a pseudo-field, so remove it from the config
        delete config.TVon.enabled;
    }

    // if there's no IR hardware, ignore any code assignments
    var s;
    if ((s = config.IRRemote)
        && s.sensorPin == "NC"
        && s.ledPin == "NC")
    {
        // clear all codes by setting the protocol to 0
        if (s = config.IRCode1) {
            $.each(s, function(key, val) {
                if (/\d+/.test(key)) {
                    val.flags = 0;
                    val.keytype = 0;
                    val.keycode = 0;
                    var s1;
                    if ((s1 = config.IRCode2) && s1[key]) {
                        s1[key].protocol = 0;
                        s1[key].codeLo = 0;
                    }
                    if ((s1 = config.IRCode3) && s1[key]) {
                        s1[key].codeHi = 0;
                    }
                }
            });
        }
    }

    // zero all fields for unused IR codes, as indicated by protocol == 0
    if (s = config.IRCode2) {
        $.each(s, function(key, val) {
            if (/\d+/.test(key) && val && val.protocol == 0) {
                val.codeLo = 0;
                var s1;
                if ((s1 = config.IRCode1) && s1[key]) {
                    s1[key].flags = 0;
                    s1[key].keytype = 0;
                    s1[key].keycode = 0;
                }
                if ((s1 = config.IRCode3) && s1[key]) {
                    s1[key].codeHi = 0;
                }
            }
        });
    }

    // if the TLC5940 feature is disabled, clear all fields
    if (config.TLC5940) {
        if (config.TLC5940.nchips == 0) {
            config.TLC5940.SIN = "NC";
            config.TLC5940.SCLK = "NC";
            config.TLC5940.XLAT = "NC";
            config.TLC5940.BLANK = "NC";
            config.TLC5940.GSCLK = "NC";
        }
    }

    // if the 74HC595 feature is disabled, clear all fields
    if (config.HC595) {
        if (config.HC595.nchips == 0) {
            config.HC595.SIN = "NC";
            config.HC595.SCLK = "NC";
            config.HC595.LATCH = "NC";
            config.HC595.ENA = "NC";
        }
    }

    // if the TLC59116 feature is disabled, clear all fields
    if (config.TLC59116) {
        if (config.TLC59116.chipMask == 0) {
            config.TLC59116.SDA = "NC";
            config.TLC59116.SCL = "NC";
            config.TLC59116.RESET = "NC";
        }
    }

    // we don't provide access to several of the plunger variables - these
    // are set through the plunger viewer instead
    delete config.plungerCal;
    delete config.plungerCalRaw;
    delete config.plungerFilters;
    delete config.plungerBarCode;

    // if in standalone mode, clear all expansion board fields
    if (config.expansionBoards) {
        if (config.expansionBoards.type == 0) {
            config.expansionBoards.version = 0;
            config.expansionBoards.ext0 = 0;
            config.expansionBoards.ext1 = 0;
            config.expansionBoards.ext2 = 0;
        }
    }

    // if ZB Launch Ball is disabled, clear fields
    if (config.ZBLaunchBall) {
        if (config.ZBLaunchBall.port == 0) {
            config.ZBLaunchBall.keytype = 0;
            config.ZBLaunchBall.keycode = 0;
            config.ZBLaunchBall.pushDistance = 0;
        }
    }

    // string-ize all output port IDs
    $.each(config.outputs, function(k, v) {
        if (v.port && typeof v.port.pin != "string")
            v.port.pin = "" + v.port.pin;
    });

    // string-ize all numbers for consistent comparisons
    function numToString(val)
    {
        if (typeof val === "number")
            val = "" + val;
        if (typeof val === "object")
            $.each(val, function(k, v) { val[k] = numToString(v); });
        return val;
    }
    numToString(config);

    // if there's no night mode button, the button flags don't matter
    if (config.nightMode && config.nightMode.button == 0)
        config.nightMode.flags &= ~0x03;

    // return the updated config object
    return config;
}

// Normalize an external config (xconfig)
function normalizeXConfig(xc)
{
    // if it's empty, return nothing
    if (!xc)
        return { };

    // create a new copy of the object, so that we leave the
    // original unmodified
    xc = JSON.parse(JSON.stringify(xc));

    // populate the outputs and IRCommand lists, if missing
    populate("outputs", MaxOutputs, {desc: ""});
    populate("IRCommand", $("#irCommandTab .irCommandRow").length, {desc: ""});

    // populate a section with a given key with numbered elements up to
    // the limit, and remove any excess elements
    function populate(key, n, defEle)
    {
        // if the section doesn't exist, add it
        var group = xc[key];
        if (!group)
            group = xc[key] = { };

        // remove excess elements
        var delList = [];
        $.each(group, function(k, v) { var ik = +k; if (ik == 0 || ik > n) delList.push(k); });
        $.each(delList, function(k, v) { delete group[v]; });

        // add missing elements
        for (var i = 1 ; i <= n ; ++i) {
            var ki = i.toString();
            if (!(ki in group))
                group[ki] = defEle;
        }
    }

    // return the updated config object
    return xc;
}


// When configuration loading is in progress, we set this to the config
// template object being loaded.  Change handlers can use this for
// special dependency handling needed during loading.
var loadingConfig;

// Load a configuration into and/or from the UI.
//
// configFromUI() returns a new config object built from the current
//    UI state.  The config object contains information that's stored
//    in the device flash memory.
//
// xconfigFromUI() returns a new xconfig object built from the current
//    UI state.  The xconfig object contains additional descriptive
//    information about the configuration that isn't needed at run-time,
//    such as user-entered description strings for the stored IR commands
//    and output ports.
//
// configToUI(config, xconfig) updates the UI state to match the given
//    config and xconfig objects.  'config' is the flash configuration
//    stored on the board; 'xconfig' is the external configuration stored
//    locally on the PC.  The external config stores additional data
//    that's not needed for runtime operation on the board and takes up
//    a lot of space, such as descriptive strings for the output ports
//    and stored IR commands.
//
var configFromUI, xconfigFromUI, configToUI;
function configFunctionSetup()
{
    // Create a new configuration data object from the current UI state
    configFromUI = function()
    {
        // run through the control mappings
        var newconfig = fromUI(fields);

        // For compatibility with older firmware versions, remove settings
        // that don't exist in older firmware.
        if (config)
        {
            if (!getprop(config, "shiftButton"))
                delete newconfig.shiftButton;
            if (!getprop(config, "xbuttons"))
                delete newconfig.xbuttons;
            if (!getprop(config, "IRRemote"))
            {
                delete newconfig.IRRemote;
                delete newconfig.IRCode1;
                delete newconfig.IRCode2;
                delete newconfig.IRCode3;
            }
        }

        // return the new configuration object
        return newconfig;
    }

    // Create a new xconfig object from the UI state
    xconfigFromUI = function()
    {
        // read the current UI data from the external fields (xfields) list
        return fromUI(xfields);
    }

    // Update the UI state to reflect the contents of the given configuration object.
    // 'source' is a ConfigSource element giving the source of the configuration data.
    configToUI = function(config, xconfig, source)
    {
        // set the global loading flag
        loadingConfig = config;
    
        // If loading a board configuration, size the tables whose
        // sizes are fixed in the firmware version.
        if (source == ConfigSource.Board)
        {
            // size the button table
            sizeButtonTable(config);

            // size the IR command table
            if (sizeIRCommandTab(config))
            {
                // add field descriptors for the IR command rows
                $("#irCommandTab .irCommandRow").each(function()
                {
                    // get the row
                    var tr = $(this);
                    var idx = tr.data("irrow");

                    // Add the IR command code for the row.  The config stores
                    // the command in three parts: protocol, flags, and a 64-bit
                    // code word.  Combine these for display as hex integers in
                    // the format Protocol.Flags.CodeWord.
                    var code = tr.children(".irCode");
                    fields.push({ prop: "IRCode1." + idx + ".flags", ctl: code.children(".irFlags"), type: tText, datatype: dNumber });
                    fields.push({ prop: "IRCode2." + idx + ".protocol", ctl: code.children(".irProtocol"), type: tText, datatype: dNumber });
                    fields.push({ prop: "IRCode2." + idx + ".codeLo", ctl: code.children(".irCodeLo"), type: tText, datatype: dNumber });
                    fields.push({ prop: "IRCode3." + idx + ".codeHi", ctl: code.children(".irCodeHi"), type: tText, datatype: dNumber });
                    xfields.push({ prop: "IRCommand." + idx + ".desc", ctl: tr.find(".irDesc"), type: tText, datatype: dText });

                    // add the key mapping for the row
                    var km = tr.find(".keymapping");
                    var prop = "IRCode1." + idx;
                    fields.push({ prop: prop + ".keytype", ctl: km.children(".keytype"), type: tText, datatype: dNumber });
                    fields.push({ prop: prop + ".keycode", ctl: km.children(".keycode"), type: tText, datatype: dNumber });
                });
            }
        }

        // populate controls from the config and xconfig objects
        toUI(config, fields);
        toUI(xconfig, xfields);

        // update peripheral pin connection active status
        adjustPeripheralPins(true, true, true);
        
        // update pin warnings
        updatePinWarnings();

        // adjust the display size of the outputs table
        sizeOutputsTable();

        // we're no longer loading a configuration
        loadingConfig = false;
    }

    // read the UI controls and convert to a javascript hash
    // using the given field descriptor list
    function fromUI(fieldList)
    {
        // create a new empty config object
        var newconfig = { }

        // populate it from the field map
        for (var i = 0 ; i < fieldList.length ; ++i)
        {
            // get this field descriptor and its UI control
            var f = fieldList[i];
            var ctl = $(f.ctl);

            // retrieve the value, according to the control type
            var v = f.type.fromUI(ctl);

            // apply any declared data conversions on the value
            if (f.datatype)
                v = f.datatype.fromUI(v);

            // if there's a value-from-UI translator, run it
            if (f.fromUI)
                v = f.fromUI(v);

            // apply the filter, if any
            if (f.filter)
                v = f.filter(v);

            // if we ended up with a valid value, add it to the config
            if (typeof v != "undefined")
                setprop(newconfig, f.prop, v);
        }

        // return the result
        return newconfig;
    }

    // populate the UI controls from the given javascript hash
    // using the given field descriptor list
    function toUI(configObj, fieldList)
    {
        // run through the control mappings
        for (var i = 0 ; i < fieldList.length ; ++i)
        {
            // get this field descriptor and the config property
            var f = fieldList[i];
            var v = getprop(configObj, f.prop);

            // if we got a property, store it
            if (typeof v != "undefined")
            {
                // get the UI control
                var ctl = $(f.ctl);

                // if there's a declared datatype conversion, apply it
                if (f.datatype)
                    v = f.datatype.toUI(v);

                // if there's a property-to-UI conversion function, call it
                if (f.toUI)
                    v = f.toUI(v);

                // store the value in the control
                f.type.toUI(ctl, v);
            }
            else if (f.undefToUI)
                f.undefToUI();
        }
    }

    // control types
    var tText = {
        toUI:   function(ctl, val) { ctl.val(val).change(); },
        fromUI: function(ctl) { return ctl.val(); }
    };
    var tSelect = tText;
    var tCheckbox = {
        toUI:   function(ctl, val) { ctl.prop("checked", !!val).change(); },
        fromUI: function(ctl) { return ctl.prop("checked") ? 1 : 0; }
    };
    var tRadio = {
        toUI:   function(ctl, val) { ctl.val([val]).change(); },
        fromUI: function(ctl) { return $(ctl).filter(":checked").val(); }
    };
    var tPin = {
        toUI:   function(ctl, val) { ctl.val(val == "NC" ? "Not Connected" : val).change(); },
        fromUI: function(ctl) {
            var val = ctl.val();
            return (val == "Not Connected" ? "NC" : val);
        }
    };
    var tNone = {
        toUI:  function(ctl, val) { return undefined; },
        fromUI: function(ctl) { return undefined; }
    };

    // datatypes
    var dText = {
        toUI:   function(v) { return v; },
        fromUI: function(v) { return v; }
    };
    var dNumber = {
        toUI:   function(v) { return parseInt(v); },
        fromUI: function(v) { return parseInt(v); }
    };
    function dNumberScale(factor) {
        return {
            toUI:   function(v) { return parseInt(v)/factor; },
            fromUI: function(v) { return parseFloat(v)*factor; }
        };
    }

    // Mappings between controls and config variables
    var fields = [
        { prop: "USBID", ctl: "#popUsbID", type: tText,
          toUI: function(v) { var v = hex4(v.vendor) + hex4(v.product); ensureUsbId(v); return v; },
          fromUI: function(v) { return { vendor: parseInt(v.substr(0, 4), 16), product: parseInt(v.substr(4), 16) }; }
        },
        { prop: "pinscapeID", ctl: "#popPinscapeID", type: tSelect, datatype: dNumber },
        { prop: "joystick.enabled", ctl: "#ckJoystick", type: tCheckbox },
        { prop: "joystick.axisFormat", ctl: "#jsAxisList", type: tSelect, datatype: dNumber },
        { prop: "joystick.reportInterval", ctl: "#jsReportInterval", type: tText, datatype: dNumberScale(1000) },
        { prop: "accelerometer.stutter", ctl: "#accelStutterCount", type: tText, datatype: dNumber },
        { prop: "disconnectRebootTime", ctl: "#ckRebootEnable", type: tCheckbox,
          toUI: function(v) { return +v != 0; },
          fromUI: function(v) { return undefined; }
        },
        { prop: "disconnectRebootTime", ctl: "#txtRebootTime", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("#ckRebootEnable").prop("checked") ? v : 0; }
        },
        { prop: "accelerometer.orientation", ctl: "input:radio[name=accelOrientation]", type: tRadio, datatype: dNumber },
        { prop: "accelerometer.dynamicRange", ctl: "input:radio[name=accelRange]", type: tRadio, datatype: dNumber },
        { prop: "accelerometer.autoCenterMode", ctl: "#accelAutoCenterTime", type: tText, datatype: dNumber,
          fromUI: function(v) {
              // radio button value=1 is the custom time; value=0 and value=255 are 'default' and 'manual'
              var r = $("#autoCenterRadioButtons input:radio[name=autoCenterMode]:checked").val();
              return (r == 1 ? $("#accelAutoCenterTime").val() : r);
          },
          toUI: function(v) {
              $("#autoCenterRadioButtons input:radio[name=autoCenterMode]").val([v == 0 || v == 255 ? v : 1]).change();
              return v >= 1 && v <= 60 ? v : 5;
          }
        },

        { prop: "plungerType", ctl: "#plungerType", type: tSelect, datatype: dNumber },
        { prop: "calButtonPins.enabled", ctl: "", type: tText, datatype: dNumber,
          fromUI: function(v) {
              return ($("#calBtnEna").prop("checked") ? 0x01 : 0x00)
                  + ($("#calLEDEna").prop("checked") ? 0x02 : 0x00);
          },
          toUI: function(v) {
              $("#calBtnEna").prop("checked", (v & 0x01) != 0).change();
              $("#calLEDEna").prop("checked", (v & 0x02) != 0).change();
              return undefined;
          }
        },

        { prop: "ZBLaunchBall.pushDistance", ctl: "#zbDistance", type: tText, datatype: dNumberScale(1000) },
        { prop: "ZBLaunchBall.port", ctl: "#zbEnabled", type: tCheckbox,
          toUI: function(v) { return +v != 0; },
          fromUI: function(v) { return undefined; }
        },
        { prop: "ZBLaunchBall.port", ctl: "#zbPort", type: tText, datatype: dNumber },
        { prop: "ZBLaunchBall.keytype", ctl: "#keymapZB .keytype", type: tText, datatype: dNumber },
        { prop: "ZBLaunchBall.keycode", ctl: "#keymapZB .keycode", type: tText, datatype: dNumber },

        { prop: "plungerAutoZero.flags", ctl: "#plungerAutoZeroEnabled", type: tCheckbox,
          toUI: function(v) { return (v & 0x01) != 0; },
          fromUI: function(v) { return $("#plungerAutoZeroEnabled").prop("checked") ? 0x01 : 0x00; }
        },
        { prop: "plungerAutoZero.time", ctl: "#plungerAutoZeroTime", type: tText, datatype: dNumber },

        { prop: "TVon.delay", ctl: "#tvDelay", type: tText, datatype: dNumberScale(100) },

        { prop: "nightMode.button", ctl: "#nightModeButtonNo", type: tText, datatype: dNumber },
        { prop: "nightMode.output", ctl: "#nightModeOutputNo", type: tText, datatype: dNumber },
        { prop: "nightMode.flags", ctl: "", type: tRadio, datatype: dNumber,
          toUI: function(v) {
              // set the switch type: if flag bit 0x01 is set, it's switch mode (2), otherwise momentary toggle mode (1)
              $("input:radio[name=nightModeButtonType]").val([(v & 0x01) ? 2 : 1]).change();

              // set the shift status: if flag bit 0x02 is set, it's the shifted button, otherwise the primary button;
              // but this only applies in toggle mode, so bit 0x01 must not be set
              $("#nightModeButtonShift input").prop("checked", (v & 0x03) == 0x02);
              return undefined;
          },
          fromUI: function(v) {
              var v = 0;
              if ($("input:radio[name=nightModeButtonType]:checked").val() == 2) v |= 0x01;  // switch mode (2) -> flag 0x01
              if (!(v & 0x01) && $("#nightModeButtonShift input").prop("checked")) v |= 0x02; // shift button -> flag 0x02
              return v;
          }
        },
                  
        { prop: "expansionBoards.type", ctl: "input:radio[name=hardwareType]", type: tRadio, datatype: dNumber },
        { prop: "expansionBoards.version", ctl: "#expBoardVersion", type: tText },
        { prop: "expansionBoards.ext0", ctl: "#numMainBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { 
              var hwType = $("input:radio[name=hardwareType]:checked").val();
              return (hwType == 1 || hwType == 2 || hwType == 3) ? v : undefined;
          }
        },
        { prop: "expansionBoards.ext1", ctl: "#numPowerBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { 
              var hwType = $("input:radio[name=hardwareType]:checked").val();
              return (hwType == 1 || hwType == 2|| hwType == 3) ? v : undefined;
          }
        },
        { prop: "expansionBoards.ext2", ctl: "#numChimeBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { 
              var hwType = $("input:radio[name=hardwareType]:checked").val();
              return (hwType == 1 || hwType == 2|| hwType == 3) ? v : undefined;
          }
        },

        { prop: "TLC5940.nchips", ctl: "#tlc_nchips", type: tText, datatype: dNumber },
        { prop: "HC595.nchips", ctl: "#hc595_nchips", type: tText, datatype: dNumber },

        { prop: "shiftButton.index", ctl: "#shiftButton", type: tText, datatype: dNumber },
        { prop: "shiftButton.mode", ctl: "input:radio[name=shiftButtonMode]", type: tRadio, datatype: dNumber },

        { prop: "TLC59116.chipMask", type: tNone,
          toUI: function(v) {
              $("#tlc59116_chipsEnabled input").each(function() {
                  $(this).prop("checked", (v & (1 << $(this).data("address"))) != 0).change(); });
              return undefined;
          },
          undefToUI: function(v) { $("#tlc59116_chipsEnabled input").first().change(); },
          fromUI: function(v) {
              var mask = 0;
              $("#tlc59116_chipsEnabled input:checked").each(function() {
                  mask |= 1 << $(this).data("address"); });
              return mask;
          }
        }
        
    ];

    // Mappings between controls and xconfig variables
    var xfields = [ ];

    // add field descriptors for all of the pin selectors
    $(".pinselect").each(function()
    {
        // get the configuration property name
        var self = $(this);
        var prop = self.data("cfg");

        // add a field definition for it
        fields.push({
            prop: prop,
            ctl: self.children(".pinval"),
            type: tPin,
            filter: function(v) { return self.data("save") ? v : undefined; },
            undefToUI: function(v) { this.ctl.val("Not Connected"); }
        });
    });

    // add field descriptors for the button table key mappings
    $("#buttonTab .keymapping").each(function()
    {
        var self = $(this);
        var idx = self.data("idx");
        var xidx = self.data("xidx");
        var prop = idx ? "buttons." + idx : xidx ? "xbuttons." + xidx : null;
        if (prop)
        {
            var filter = function(v) { return self.data("outOfService") ? undefined : v; };
            fields.push({ prop: prop + ".keytype", ctl: self.children(".keytype"), type: tText, datatype: dNumber, filter: filter });
            fields.push({ prop: prop + ".keycode", ctl: self.children(".keycode"), type: tText, datatype: dNumber, filter: filter });
            if (idx)
                fields.push({ prop: prop + ".flags", ctl: self.children("input.keyflags"), type: tText, datatype: dNumber, filter: filter });
            self.parents("td").find(".IRCommand").each(function() {
                fields.push({ prop: prop + ".IRCommand", ctl: $(this), type: tText, datatype: dNumber, filter: filter });
            });
        }
    });

    // add field descriptors for the output port mappings
    $("#outputTab .outPortRow").each(function()
    {
        var self = $(this);
        var idx = self.data("idx");
        if (idx && idx != "end")
        {
            var prop = "outputs." + idx;
            fields.push({ prop: prop + ".port.type", ctl: self.find(".pintype"), type: tText, datatype: dNumber });
            fields.push({ prop: prop + ".port.pin", ctl: self.find(".pinval"), type: tText });
            fields.push({ prop: prop + ".flags", ctl: self.find(".pinflags"), type: tText, datatype: dNumber });
            fields.push({ prop: prop + ".flipperLogic", ctl: self.find(".flipperLogic"), type: tText, datatype: dNumber });
            xfields.push({ prop: prop + ".desc", ctl: self.find(".outPortDesc"), type: tText, datatype: dText });
        }
    });

    // Get a property by path, if present
    function getprop(obj, prop, defval)
    {
        // if we don't have an object, stop here
        if (!obj)
            return obj;

        // traverse the dot-separated property list
        prop = prop.split(".");
        while (prop.length)
        {
            // descend only if the next property is present
            var p = prop.shift();
            if (p in obj)
                obj = obj[p];
            else
                return defval;
        }

        // return the final evaluated object
        return obj;
    }

    // Does a property exist?
    function hasprop(obj, prop)
    {
        // if there's no object, the property doesn't exist
        if (!obj)
            return false;

        // traverse the dot-separated property list
        prop = prop.split(".");
        while (prop.length)
        {
            // descend only if the next property is present
            var p = prop.shift();
            if (p in obj)
                obj = obj[p];
            else
                return false;
        }

        // if we made it to the end of the list, the property exists
        return true;
    }
    
    // Set a property by path, creating intermediate
    // container objects as necessary.
    function setprop(obj, prop, val)
    {
        // traverse the dot-separated property list
        prop = prop.split(".");
        while (prop.length > 1)
        {
            // if the next property isn't present, create an empty object for it
            var p = prop.shift();
            if (!(p in obj))
                obj[p] = { };

            // traverse into the subobject
            obj = obj[p];
        }

        // set the final property
        obj[prop[0]] = val;
    }
}

// Convert a configuration set from UI format to USB format.

function configToUSB(uicfg)
{
    // Get the config var format descriptors.  This tells us how to format
    // the variables for the USB messages.
    var vardescs = window.external.GetConfigVarDescs().split("|");

    // Format each variable into a USB byte list
    var usb = [];
    $.each(vardescs, function(i, desc)
    {
        // Each variable descriptor uses this format:
        //   <varnum> <varname> <desc>
        // Split into the three parts.
        desc = desc.split(" ");
        var varid = desc[0];
        var varname = desc[1];
        var format = desc[2];

        // The <value> can be a substitution type, or an object.
        // The substitution types are of the form $X, where X is a
        // one-letter type code.  Object types use javascript object
        // syntax.  First, turn the type codes into strings, then
        // parse the descriptor into a javascript string or object.
        function parse(format, val)
        {
            if (/\{/.test(format))
            {
                // object format
                $.each(format.substr(1, format.length-2).split(","), function(k, v)
                {
                    // each field is a "property:value" - split at the ":" and
                    // process the field
                    v = v.split(":");
                    parse(v[1], val[v[0]]);
                });
            }
            else
            {
                // scalar value - check which type we have
                switch (format)
                {
                case "$B":      // byte - integer value to USB byte
                    bytes.push(parseInt(val || 0));
                    break;

                case "$W":      // word - integer value to USB two bytes little-endian 
                    var ii = parseInt(val || 0);
                    bytes.push(ii & 0xff);
                    bytes.push((ii >> 8) & 0xff);
                    break;

                case "$D":      // dword - integer value to USB four bytes little-endian
                    var ii = parseInt(val || 0);
                    bytes.push(ii & 0xff);
                    bytes.push((ii >> 8) & 0xff);
                    bytes.push((ii >> 16) & 0xff);
                    bytes.push((ii >> 24) & 0xff);
                    break;
    
                case "$P":      // port number - port name in "PTxx" format to USB byte
                    bytes.push(parseGPIOName(val));
                    break;

                case "$o":      // output port: object with {type:, pin:} fields to USB type byte + pin byte
                    // add the type byte
                    bytes.push(parseInt(val.type));
    
                    // interpret the pin name
                    switch (val.type)
                    {
                    case 1:
                    case 2:
                        // GPIO pins - the pin is a GPIO name
                        bytes.push(parseGPIOName(val.pin));
                        break;

                    case 3:
                    case 4:
                    case 6:
                        // TLC5940, 74HC595, TLC59116 ports - the pin is a 
                        // port number
                        bytes.push(parseInt(val.pin));
                        break;

                    default:
                        // pin is unused in all other types
                        bytes.push(0);
                        break;
                    }
                    break;
                }
            }

            function parseGPIOName(val)
            {
                if (/PT([A-E])(\d+)/i.test(val))
                {
                    var port = RegExp.$1.charCodeAt(0) - 65;
                    var pin = parseInt(RegExp.$2);
                    return (port << 5) | (pin & 0x1F);
                }
                else if (typeof val == "undefined" || val == "NC")
                {
                    // not connected
                    return 255;
                }
                else
                {
                    // anything else is invalid - use NC, but flag it internally by adding 256
                    // (the extra 256 will be masked out when we transmit the bytes via USB)
                    return 255 + 256;
                }
            }
        }

        // get the current UI settings for the current variable
        var uival = uicfg[varname];

        // check for an array variable
        if (typeof uival != "undefined")
        {
            if (/\d+\[\]/.test(varid))
            {
                // array - start at index 1 and continue until we run out of entries
                var arr = uicfg[varname];
                for (var j = 1 ; j in arr ; ++j)
                {
                    // the USB data starts with the variable ID and array index 
                    var bytes = [parseInt(varid), j];
                    parse(format, arr[j]);
                    usb.push(bytes.join(" "));
                }
            }
            else
            {
                // scalar variable - the USB data starts with the variable ID
                var bytes = [parseInt(varid)];
                parse(format, uival);
                usb.push(bytes.join(" "));
            }
        }
    });

    // return the usb list
    return usb;
}

// build a comma-separated list
function serialComma(lst, conjunction)
{
    if (lst.length < 1)
        return "";
    else if (lst.length == 1)
        return lst[0];
    else if (lst.length == 2)
        return lst[0] + " " + conjunction + " " + lst[1];
    else
        return lst.slice(0, -1).join(", ") + ", " + conjunction + " " + lst[lst.length-1];
}

// build a table of in-use pins
function pinsInUse()
{
    // generate a description of the list of users of an in-use pin
    var users = function() {
        return serialComma($.map(this.fields, function(ele) { return ele.data("desc"); }), "and");
    };

    function add(ele, v)
    {
        // create an entry for this name, if it's empty
        var t = inuse[v];
        if (!t)
            inuse[v] = t = {
                name: v,
                gpio: gpioPinsByName[v],
                inUseBy: users,
                fields: []
            };
        
        // add this pin's description to the list
        t.fields.push(ele);
    }

    // run through the .pinselect fields, and enroll each active one
    var inuse = { };
    $(".pinselect").each(function()
    {
        // only consider active items
        var self = $(this);
        if (self.data("active"))
        {
            // get the pin by name; proceed if we're connected to a pin
            var v = self.children(".pinval").val();
            if (v != "No connected" && gpioPinsByName[v])
            {
                // add an entry for the pin name
                add(self, v);

                // if this is a PWM pin, also add an entry for PWM channel
                if (/\b(pwm)\b/.test(self.data("gpiotype")))
                    add(self, "pwm." + gpioPinsByName[v].pwm);

                // if it's a PWM pin that needs independent period control,
                // add an entry for the whole TPM unit
                if (/\b(tpm)\b/.test(self.data("gpiotype")))
                    add(self, "tpm." + pwmToTpm(gpioPinsByName[v].pwm));

                // if it has a SPI function, add an entry for that
                if (/\b(spi-)/.test(self.data("gpiotype")))
                    add(self, "spi." + gpioPinsByName[v].spi);
            }
        }
    });

    // add the output ports
    $("#outputTab .outPortRow").each(function()
    {
        // only consider GPIO pins
        var self = $(this);
        var v = self.find(".pinval").val();
        var typ = +self.find(".pintype").val();
        switch (typ)
        {
        case 1: // PWM GPIO
        case 2: // Digital Out GPIO
            // get the pin by name; proceed if we're connected
            if (v != "NC" && gpioPinsByName[v])
            {
                // add an entry for the pin name
                add(self, v);

                // if it's used as a PWM pin, add an entry for the PWM channel
                if (typ == 1 && gpioPinsByName[v].pwm)
                    add(self, "pwm." + gpioPinsByName[v].pwm);
            }
            break;

        case 3: // TLC5940
            add(self, "tlc5940." + v);
            break;

        case 4: // 74HC595
            add(self, "hc595." + v);
            break;

        case 6: // TLC59116
            add(self, "tlc59116." + v);
            break;
        }
    });

    // return the table
    return inuse;
}

// create the in-use table ID for a pin selection
function inuseID(ele)
{
    // If the element has a "pin" data field, use that, along with
    // the "pintype" field if present.  Don't use a prefix for GPIO
    // port types (output types 1 and 2).
    var pinval = ele.data("pin");
    var pintype = ele.data("pintype");

    // If there's no "pin" data element, use the .pinval and .pintype fields
    if (pinval === undefined) {
        pinval = ele.find(".pinval").val();
        pintype = ele.find(".pintype").val();
    }
    
    // If the element has a .pintype field, apply the prefix for the type.
    // These fields apply to output rows, so the type ID corresponds to the
    // output type byte in the USB output port setup messages:
    // 
    //   type 3 -> TLC5940  -> prefix "tlc5940."
    //   type 4 -> 74HC595  -> prefix "hc595."
    //   type 6 -> TLC59116 -> prefix "tlc59116."
    //
    var pfx = { 3: "tlc5940.", 4: "hc595.", 6: "tlc59116." }[pintype] || "";

    // return the prefix plus the pin name
    return pfx + pinval;
}

// Update pin warnings.  This updates all of the visible warning icons
// attached to .pinselect and .outPortRow pin selector fields.
function updatePinWarnings()
{
    genPinWarnings(function(item, msg) {
        var warn = item.find(".pinwarn");
        if (msg) {
            warn.addClass("active");
            warn.attr("title", msg);
        }
        else {
            warn.removeClass("active");
        }
    });
}

// Determine if there are any warnings.  Returns a list of the .pinselect
// and .outPortRow items with warnings.
function getPinWarnings()
{
    var lst = [];
    genPinWarnings(function(item, msg) {
        if (msg)
            lst.push(item);
    });
    return lst;
}

// General pin warning handler.  We run through the .pinselect fields
// and .outPortRow items, checking each one to see if it has a conflict.
// For each conflict, we call the callback function:
//
//   cb(item, warningMessage)
//
// For items without conflicts, we call the callback with no message.
//
function genPinWarnings(cb)
{
    // get the in-use table
    var inuse = pinsInUse();

    // run through the pin selectors and update warnings
    $(".pinselect, #outputTab .outPortRow").each(function()
    {
        // check to see if this item has multiple users
        var self = $(this);
        var pin = inuseID(self);
        var pintype = self.find(".pintype").val();
        var gpiotype = self.data("gpiotype");
        var pwm = (/\b(pwm)\b/.test(gpiotype) || pintype == "1") && nullobj(gpioPinsByName[pin]).pwm;
        var tpm = /\b(tpm)\b/.test(gpiotype) && pwmToTpm(nullobj(gpioPinsByName[pin]).pwm);
        var spi = /b(spi-)/.test(gpiotype) && nullobj(gpioPinsByName[pin]).spi;
        var warn = self.find(".pinwarn");
        if (self.hasClass("pinselect") && !self.data("active"))
        {
            // it's inactive, so it can't be in conflict
            cb(self, undefined);
        }
        else if (inuse[pin] && inuse[pin].fields.length > 1)
        {
            // this one is in use multiple times - activate the warning
            cb(self, "This pin is assigned to multiple functions ("
               + inuse[pin].inUseBy() + ")");
        }
        else if (pwm && inuse["pwm." + pwm] && inuse["pwm." + pwm].fields.length > 1)
        {
            // the PWM channel is overcommitted
            cb(self, "Le canal PWM de cette broche est utilisé plusieurs fois "
               + "(Canal PWM" + pwm + ", utilisé par" + inuse ["pwm." + Pwm].inUseBy ()
               + "). Le canal PWM attribué à une broche ne peut pas être modifié"
               + "(il est câblé dans le CPU), donc un seul des"
               + pwmChannels[pwm].orList () + "peut être utilisé simultanément"
               + "comme sorties PWM. Les autres broches peuvent encore être utilisées pour d'autres"
               + ", tant qu'ils ne sont pas affectés en tant que sorties PWM.");
        }
        else if (tpm && inuse["tpm." + tpm] && inuse["tpm." + tpm].fields.length > 1)
        {
            cb(self, "Unité de contrôleur TPM du canal PWM de cette broche (canal PWM "
               + pwm + ", l'unité TPM" + tpm + "est utilisée par plus d'une fonction"
               + "qui nécessite le contrôle de la fréquence PWM (" + inuse ["tpm." + tpm].inUseBy ()
               + "). Une seule des broches suivantes peut être utilisée simultanément"
               + "pour l'une de ces fonctions:" + tpmUnits[tpm].orList () + ". Vous devez"
               + "basculer l'une de ces fonctions sur une broche compatible PWM avec une autre"
               + "Numéro d'unité TPM. Ceci est une limitation matérielle de la KL25Z; PWM"
               + "la fréquence est contrôlée par l'unité TPM, qui contient un groupe"
               + "de canaux, plutôt que les canaux individuels, donc fonctionne"
               + "qui nécessitent un contrôle de fréquence indépendant doit être attribué aux"
               + "canaux situés sur des unités TPM distinctes.");
        }
        else if (spi && inuse["spi." + spi] && inuse["spi." + spi].fields.length > 1)
        {
            // the SPI controller is overcommitted
            cb(self, "This pin's SPI controller function is used more than once "
               + "(" + spi + ", used by " + inuse["spi." + spi].inUseBy()
               + "). Each SPI function can only be assigned to one pin.");
        }
        else
        {
            // turn off this one's warning
            cb(self, undefined);
        }
    });
}


// treat a return key in a text field as a commit
$("input[type='text']").keydown(function(event) {
    if (event.which == 13)
        $(this).change();
});

// update highlighting on selection change in a radio button table
$("table.radio input:radio").change(function() {
    $("td", $(this).parents("table.radio")).each(function() {
        $(this).toggleClass("selected", $("input:radio", $(this)).prop("checked"));
    });
});

function hex4(val)
{
    return ("0000" + (+val).toString(16).toUpperCase()).substr(-4);
}

$(function() {
    // On text field changes, remember the old value on each change.
    // Note that event binding order is important - this is bound last so
    // that it runs after other handlers have a chance to use the old value.
    $("input:text").change(function() {
        $(this).data("oldVal", $(this).val());
    });

    // initialize everyone's oldVal to their initial value
    $("input:text").each(function() {
        $(this).data("oldVal", $(this).val()); });
    
});

// show PWM port help
$("a.pwmHelp").click(function(ev) {
    window.external.ShowHelp("HelpPWM.htm");
    ev.preventDefault();
});

// show SPI port help
$("a.spiHelp").click(function(ev) {
    window.external.ShowHelp("HelpSPI.htm");
    ev.preventDefault();
});

// show output port flag help
$("a.outPortOptionsHelp").click(function(ev) {
    window.external.ShowHelp("HelpOutPortOptions.htm");
    ev.preventDefault();
});

// show button assignment help
$("a.btnHelp").click(function(ev) {
    window.external.ShowHelp("HelpKeyAssignments.htm");
    ev.preventDefault();
});

</script>

</body>
</html>
